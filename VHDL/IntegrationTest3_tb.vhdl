-- Test BenchVHDL for IBM SMS ALD group IntegrationTest3 (Copied from Integrationtest2)
-- Title: IntegrationTest3
-- IBM Machine Name 1411
-- Generated by GenerateHDL on 11/18/2020 4:29:07 PM

-- Included from HDLTemplate.vhdl

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;  -- For use in test benches only
use WORK.ALL;

-- End of include from HDLTemplate.vhdl

entity IntegrationTest3_tb is
   PORT (
      CLK: in  STD_LOGIC;
      SW:  in  STD_LOGIC_VECTOR(15 downto 0);
      LED: out STD_LOGIC_VECTOR(15 downto 0) 
);
   
end IntegrationTest3_tb;

architecture behavioral of IntegrationTest3_tb is

	-- Component Declaration for the Unit Under Test (UUT)

	component IntegrationTest3
	    Port (
		FPGA_CLK: in STD_LOGIC;
		PP_SPECIAL_OR_12V_POWER_FOR_OSC: in STD_LOGIC;
		MV_36_VOLTS: in STD_LOGIC;
		PS_INSTRUCTION_CHECK_GATE_STAR_1311: in STD_LOGIC;
		MS_FORMS_STACK_GO_F_CH_STAR_1414_STAR: in STD_LOGIC;
		PS_COMP_DISABLE_CYCLE_STAR_1412_19: in STD_LOGIC;
		PS_START_AUTO_STARTMODE_STAR_AUTS_STAR: in STD_LOGIC;
		PS_RESET_STOP_KEY_LATCH_STAR_AUTS_STAR: in STD_LOGIC;
		M36_VOLTS: in STD_LOGIC;
		PS_BRANCH_TO_A_COND_STAR_1412_19: in STD_LOGIC;
		PS_SET_NO_SCAN_CTRL_STAR_1412_19: in STD_LOGIC;
		PS_SET_B_CYCLE_CTRL_STAR_1412_19: in STD_LOGIC;
		PS_NO_BRANCH_COND_STAR_1412_19: in STD_LOGIC;
		PS_LAST_EXECUTE_CYCLE_STAR_1412_19: in STD_LOGIC;
		MC_BUFFER_INQ_REQUEST: in STD_LOGIC;
		MC_BUFFER_OUTQUIRY_PULSE: in STD_LOGIC;
		PS_SPEC_BRANCH_LATCH_STAR_1414_STAR: in STD_LOGIC;
		MC_PRINTER_CHANNEL_9: in STD_LOGIC;
		MC_PRINTER_CHANNEL_12: in STD_LOGIC;
		MC_FORMS_BUSY_STATUS_TO_CPU: in STD_LOGIC;
		MC_READ_COLUMN_BINARY: in STD_LOGIC;
		MC_1301_READY_E_CH: in STD_LOGIC;
		MC_1405_READY_E_CH: in STD_LOGIC;
		MC_BUFFER_READY: in STD_LOGIC;
		PS_E_CH_READY_BUS_STAR_SIF: in STD_LOGIC;
		PS_E_CH_READY_BUS_STAR_1412_19: in STD_LOGIC;
		MC_TAPE_READY: in STD_LOGIC;
		MC_TAPE_READY_F_CH_JRJ: in STD_LOGIC;
		MC_BUFFER_READY_JRJ: in STD_LOGIC;
		MC_SELECT_AND_REWIND_STAR_E_CH: in STD_LOGIC;
		MC_1301_BUSY_E_CH: in STD_LOGIC;
		PS_E_CH_BUSY_BUS_STAR_1412_19: in STD_LOGIC;
		MC_1405_BUSY_E_CH: in STD_LOGIC;
		MC_BUFFER_BUSY: in STD_LOGIC;
		MC_BUFFER_BUSY_JRJ: in STD_LOGIC;
		MC_TAPE_BUSY: in STD_LOGIC;
		MC_TAPE_BUSY_F_CH_JRJ: in STD_LOGIC;
		MC_1301_ERROR_E_CH: in STD_LOGIC;
		MC_1405_ERROR_E_CH: in STD_LOGIC;
		MC_BUFFER_ERROR: in STD_LOGIC;
		MC_BUFFER_ERROR_JRJ: in STD_LOGIC;
		PS_E_CH_CHECK_BUS_STAR_SIF: in STD_LOGIC;
		PS_E_CH_CHECK_BUS_STAR_1412_19: in STD_LOGIC;
		MC_TAPE_ERROR: in STD_LOGIC;
		MC_TAPE_ERROR_F_CH_JRJ: in STD_LOGIC;
		MC_1301_E_CH_CONDITION: in STD_LOGIC;
		MC_1405_CONDITION_E_CH: in STD_LOGIC;
		MC_BUFFER_CONDITION: in STD_LOGIC;
		MC_BUFFER_CONDITION_JRJ: in STD_LOGIC;
		MC_SEL_OR_TAPE_IND_ON_CH_1: in STD_LOGIC;
		MC_RBC_ERROR_1405_E_CH: in STD_LOGIC;
		PS_E_CH_COND_LATCH_STAR_SIF: in STD_LOGIC;
		MV_CONSOLE_PWR_SUPPLY_36_VOLTS: in STD_LOGIC;
		PS_OP_MOD_SYM_IO_STATUS_STAR_1414_STAR: in STD_LOGIC;
		PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF: in STD_LOGIC;
		PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF_JRJ: in STD_LOGIC;
		PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF: in STD_LOGIC;
		PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF_JRJ: in STD_LOGIC;
		MS_I_OR_O_OP_CODES_STAR_12_19: in STD_LOGIC;
		MS_E_CH_2_CHAR_OP_CODES_STAR_1414_STAR: in STD_LOGIC;
		PS_P_OR_Q_2_CHAR_OP_1412_19: in STD_LOGIC;
		MC_1301_END_ADDR_TRF_E_CH: in STD_LOGIC;
		MC_BUFFER_END_OF_TRANSFER: in STD_LOGIC;
		PS_E_CH_EXT_END_OF_TRF_STAR_1311: in STD_LOGIC;
		PS_E_CH_EXT_END_OF_TRF_STAR_SIF: in STD_LOGIC;
		PS_E_CH_EXT_END_OF_TRF_STAR_1412_19: in STD_LOGIC;
		MC_1405_END_OF_OP_STAR_E_CH: in STD_LOGIC;
		UNNAMED_26_DOT_00_DOT_01_DOT_0: in STD_LOGIC;
		MC_TAPE_IN_PROCESS: in STD_LOGIC;
		MC_TAPE_IN_PROCESS_F_CH_JRJ: in STD_LOGIC;
		MC_1301_END_OF_OP_STAR_E_CH: in STD_LOGIC;
		PS_GATE_OFF_E_CH_EXT_END_OF_TRF: in STD_LOGIC;
		MS_E_CH_SEL_ODD_PARITY_STAR_1412_19: in STD_LOGIC;
		PS_E_CH_SELECT_7_BIT_UNIT_STAR_SIF: in STD_LOGIC;
		PS_END_OF_RECORD_STAR_1311: in STD_LOGIC;
		PS_E_CH_SIF_SENSE_OR_CONTROL: in STD_LOGIC;
		PS_INT_END_OF_XFER_STAR_1311: in STD_LOGIC;
		PS_F_CH_RESET_STAR_1414: in STD_LOGIC;
		PS_F_CH_SELECT_ODD_PARITY_STAR_1414: in STD_LOGIC;
		PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_SIF: in STD_LOGIC;
		PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_2_9: in STD_LOGIC;
		PS_F_CH_SELECT_7_BIT_UNIT_STAR_SIF: in STD_LOGIC;
		PS_F_CH_SELECT_7_BIT_UNIT_STAR_1414: in STD_LOGIC;
		MC_FILE_INVALID_ADDRESS_1405: in STD_LOGIC;
		MS_E_CH_U_SEL_K_DOT_S_OP_MOD: in STD_LOGIC;
		MS_F_CH_U_SEL_K_DOT_S_OP_MOD: in STD_LOGIC;
		MS_RECOVER_LATCH_STAR_1311: in STD_LOGIC;
		PS_GT_OFF_E_CH_ST_SPL_DLY: in STD_LOGIC;
		PS_BLOCK_IO_LAST_EXECUTE: in STD_LOGIC;
		MS_F_CH_CON_LAT_SET_STAR_1414_STAR: in STD_LOGIC;
		MC_1301_ERROR_F_CH: in STD_LOGIC;
		MC_1405_ERROR_F_CH: in STD_LOGIC;
		PS_F_CH_CHECK_STAR_SIF: in STD_LOGIC;
		PS_F_CH_CHECK_BUS_STAR_1414_STAR: in STD_LOGIC;
		MC_RBC_ERROR_1405_F_CH: in STD_LOGIC;
		PS_F_CH_CHECK_STAR_1412_19: in STD_LOGIC;
		MS_F_CH_COND_LATCH_STAR_SIF: in STD_LOGIC;
		TW_RBC_ERROR_1405_F_CH: in STD_LOGIC;
		MC_1301_F_CH_CONDITION: in STD_LOGIC;
		MC_1405_CONDITION_F_CH: in STD_LOGIC;
		MC_SEL_OR_TI_ON_CH_2: in STD_LOGIC;
		PS_F_CH_COND_BUS_STAR_1414_STAR: in STD_LOGIC;
		MS_SET_F_CH_CON_LATCH_STAR_1414_STAR: in STD_LOGIC;
		PS_F_CH_SIF_SENSE_OR_CONTROL: in STD_LOGIC;
		MC_1301_READY_F_CH: in STD_LOGIC;
		MC_1405_READY_F_CH: in STD_LOGIC;
		PS_F_CH_READY_BUS_STAR_1414_STAR: in STD_LOGIC;
		PS_F_CH_READY_BUS_STAR_1412_19: in STD_LOGIC;
		PS_F_CH_READY_BUS_STAR_SIF: in STD_LOGIC;
		MC_SELECT_AND_REWIND_STAR_F_CH: in STD_LOGIC;
		PS_F_CH_BUSY_BUS_STAR_1414_STAR: in STD_LOGIC;
		PS_F_CH_BUSY_BUS_STAR_1412_19: in STD_LOGIC;
		MC_1301_BUSY_F_CH: in STD_LOGIC;
		MC_1405_BUSY_F_CH: in STD_LOGIC;
		PS_F_CH_CLR_LATCH_STAR_1414_STAR: in STD_LOGIC;
		PS_RESET_F_CH_CLR_LAT_STAR_1414_STAR: in STD_LOGIC;
		MC_SELECT_AT_LOAD_POINT_STAR_F_CH: in STD_LOGIC;
		MC_WRITE_CONDITION_STAR_F_CH: in STD_LOGIC;
		PS_ASSEMBLY_TO_F_CH_STAR_1414_STAR: in STD_LOGIC;
		PS_GATE_F_CH_ST_SAMPLE_A_STAR_1414_STAR: in STD_LOGIC;
		MC_1301_END_ADDR_TRF_F_CH: in STD_LOGIC;
		PS_SET_F_CH_EXT_END_TRF_STAR_SIF: in STD_LOGIC;
		PS_F_CH_EXT_END_OF_TRF_BUS_STAR_1414: in STD_LOGIC;
		PS_SET_F_CH_EXT_END_TRF_STAR_1412_19: in STD_LOGIC;
		MC_1301_END_OF_OP_STAR_F_CH: in STD_LOGIC;
		MC_1405_END_OF_OP_STAR_F_CH: in STD_LOGIC;
		MC_1403_PRINT_BUFFER_BUSY: in STD_LOGIC;
		MC_I_O_PRINTER_READY: in STD_LOGIC;
		MC_SELECT_AT_LOAD_POINT_STAR_E_CH: in STD_LOGIC;
		MC_WRITE_CONDITION_STAR_E_CH: in STD_LOGIC;
		PS_GATE_ON_E_CH_END_ADDR_TRF: in STD_LOGIC;
		PS_WR_INHIBIT_STAR_7631_STAR_E_CH: in STD_LOGIC;
		PS_SET_E_CH_NO_TRANS_LAT_STAR_SIF: in STD_LOGIC;
		PS_SET_E_CH_NO_TRANS_LAT_STAR_12_19: in STD_LOGIC;
		MC_BUFFER_NO_TRANS_COND: in STD_LOGIC;
		MC_BUFFER_NO_TRANS_COND_JRJ: in STD_LOGIC;
		MC_ADDR_COMP_TRUE_F_CH: in STD_LOGIC;
		MC_FAST_FILE_ON_LINE_F_CH: in STD_LOGIC;
		MS_1311_F_CH_END_ADDR_TRF: in STD_LOGIC;
		PS_WR_INHIBIT_STAR_7631_STAR_F_CH: in STD_LOGIC;
		PS_F_CH_NO_TRF_LATCH_STAR_SIF: in STD_LOGIC;
		PS_SET_F_CH_NO_TRANS_LAT_STAR_1414_STAR: in STD_LOGIC;
		PS_F_CH_NO_TRANS_LAT_STAR_12_19: in STD_LOGIC;
		MC_E_CH_FILE_DIGIT_RING_7: in STD_LOGIC;
		MC_F_CH_FILE_DIGIT_RING_7: in STD_LOGIC;
		MINUS_36_VOLTS: in STD_LOGIC;
		PS_OPTIONAL_SYNC_COND_STAR_CE: in STD_LOGIC;
		MS_OPTIONAL_SYNC_COND_A: in STD_LOGIC;
		MS_OPTIONAL_SYNC_COND_B: in STD_LOGIC;
		PS_BLOCK_ADDR_MOD_OR_1_STAR_1412_19: in STD_LOGIC;
		PS_ADDR_MOD_SET_TO_1_STAR_1412_19: in STD_LOGIC;
		PS_1311_SET_AAR: in STD_LOGIC;
		PS_1311_SET_DAR_STAR_1401: in STD_LOGIC;
		PS_1311_RESET_AAR: in STD_LOGIC;
		MS_1311_RESET_DAR_STAR_1401: in STD_LOGIC;
		MS_SCAN_RESTART_LATCH_STAR_1311: in STD_LOGIC;
		PS_BLOCK_BAR_RO_E_CH_STAR_1311: in STD_LOGIC;
		PS_BLOCK_BAR_RO_F_CH_STAR_1311: in STD_LOGIC;
		PS_1311_RO_DAR_STAR_1401: in STD_LOGIC;
		PS_E2_FULL_LATCH_STAR_SIF: in STD_LOGIC;
		MS_F_CH_OUTPUT_WM_CYCLE_STAR_1414_STAR: in STD_LOGIC;
		PS_OUTPUT_FIELD_CYCLE_STAR_1414_STAR: in STD_LOGIC;
		PS_ASM_CH_A_BIT_STAR_STERLING: in STD_LOGIC;
		MS_SET_F_U_SEL_REG_2_BIT_STAR_1414_STAR: in STD_LOGIC;
		MS_SET_F_U_SEL_REG_1_BIT_STAR_1414_STAR: in STD_LOGIC;
		MV_CONSOLE_C_INPUT_STAR_CHK_OP: in STD_LOGIC;
		MC_BUFFER_STROBE: in STD_LOGIC;
		MC_SET_ECH_STROB_TR_E_FR_FEATS: in STD_LOGIC;
		TW_SET_ECH_STROB_TR_E_FR_FEATS: in STD_LOGIC;
		MC_BUFFER_STROBE_JRJ: in STD_LOGIC;
		MC_TAPE_WRITE_STROBE: in STD_LOGIC;
		MC_TAPE_WRITE_STROBE_F_CH_JRJ: in STD_LOGIC;
		MC_1301_STROBE_E_CH: in STD_LOGIC;
		MC_1405_STROBE_E_CH: in STD_LOGIC;
		MC_TAPE_READ_STROBE: in STD_LOGIC;
		MC_TAPE_READ_STROBE_F_CH_JRJ: in STD_LOGIC;
		MS_F_CH_STK_SEL_OP_CODE_STAR_1414_STAR: in STD_LOGIC;
		PS_F_CH_WRITE_LATCH_STAR_1414_STAR: in STD_LOGIC;
		MS_F_SET_MOVE_MODE_LATCH_STAR_1414_STAR: in STD_LOGIC;
		MC_1301_STROBE_F_CH: in STD_LOGIC;
		MC_SET_FCH_STROB_TR_E_FR_FEATS: in STD_LOGIC;
		TW_SET_FCH_STROB_TR_E_FR_FEATS: in STD_LOGIC;
		MC_1405_STROBE_F_CH: in STD_LOGIC;
		PS_GATE_SET_F1_REG_STAR_1414_STAR: in STD_LOGIC;
		PS_GATE_RESET_F2_FULL_STAR_1414_STAR: in STD_LOGIC;
		PS_RGEN_EXTN_CTRL_STAR_STERLING: in STD_LOGIC;
		PS_PULL_OFF_CMP_HI_STAR_1311_SCAN: in STD_LOGIC;
		PS_PULL_OFF_CMP_LO_STAR_1311_SCAN: in STD_LOGIC;
		PS_SIMULATE_CMP_HI_STAR_1311_SCAN: in STD_LOGIC;
		PS_SIMULATE_CMP_EQ_STAR_1311_SCAN: in STD_LOGIC;
		PS_SIMULATE_CMP_LO_STAR_1311_SCAN: in STD_LOGIC;
		PS_CMP_MODE_B_CYCLE_STAR_1311: in STD_LOGIC;
		M36_VOLTS_ON_CONSOLE: in STD_LOGIC;
		PS_INTERLOCK_F_CH_STAR_1414_STAR: in STD_LOGIC;
		MC_READER_BUSY: in STD_LOGIC;
		MC_READER_BUSY_JRJ: in STD_LOGIC;
		MC_PUNCH_BUSY: in STD_LOGIC;
		MC_PUNCH_BUSY_JRJ: in STD_LOGIC;
		MC_PAPER_TAPE_READER_BUSY: in STD_LOGIC;
		MC_PAPER_TAPE_READY_BUSY_JRJ: in STD_LOGIC;
		MC_I_O_CLOCK_080_090_TIME: in STD_LOGIC;
		MC_I_O_CLOCK_080_090_TIME_JRJ: in STD_LOGIC;
		PS_INTERRUPT_REQUEST_STAR_SIF: in STD_LOGIC;
		PS_INTERRUPT_REQUEST_JRJ: in STD_LOGIC;
		PS_INTERRUPT_REQUEST_STAR_1414_STAR: in STD_LOGIC;
		PS_I_OP_DOT_I_CYCLE_DOT_E_STAR_AUTS_STAR: in STD_LOGIC;
		MC_ANY_SEEK_COMP_STAR_E_CH_1405: in STD_LOGIC;
		MC_ANY_SEEK_COMP_STAR_E_CH_1301: in STD_LOGIC;
		MC_ANY_SEEK_COMP_STAR_F_CH_1301: in STD_LOGIC;
		MC_ANY_SEEK_COMP_STAR_F_CH_1405: in STD_LOGIC;
		PS_2ND_CND_A_BRANCH_STAR_SIF: in STD_LOGIC;
		PS_2ND_CND_A_BRANCH_STAR_SIF_JRJ: in STD_LOGIC;
		PS_2ND_CND_A_BRANCH_STAR_1414_STAR: in STD_LOGIC;
		PS_NO_BRANCH_CND_INTER_STAR_SIF: in STD_LOGIC;
		PS_NO_BRANCH_CND_INTER_STAR_SIF_JRJ: in STD_LOGIC;
		PS_NO_BRANCH_CND_INTER_STAR_1414_STAR: in STD_LOGIC;
		M6_V: in STD_LOGIC;
		MY_CHAR_SEL_ERROR_CHK_1_STAR_2_STAR: in STD_LOGIC;
		MY_CHAR_SEL_ERROR_CHK_2_STAR_2_STAR: in STD_LOGIC;
		CONS_36V: in STD_LOGIC;
		MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO: in STD_LOGIC;
		PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC: in STD_LOGIC;
		MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO: in STD_LOGIC;
		MV_CONS_PRINTER_C2_CAM_NC: in STD_LOGIC;
		MV_CONS_PRINTER_C2_CAM_NO: in STD_LOGIC;
		MV_CONS_PRINTER_SPACE_NO: in STD_LOGIC;
		MV_CONS_PRINTER_C1_CAM_NO: in STD_LOGIC;
		MV_CONS_PRINTER_C1_CAM_NC: in STD_LOGIC;
		MV_CONS_PRINTER_C3_OR_C4_NO: in STD_LOGIC;
		MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC: in STD_LOGIC;
		MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO: in STD_LOGIC;
		MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO: in STD_LOGIC;
		MB_CONS_PRINTER_EVEN_BIT_CHECK: in STD_LOGIC;
		MV_CONS_PRINTER_ODD_BIT_CHECK: in STD_LOGIC;
		MV_CONS_PRINTER_LAST_COLUMN_SET: in STD_LOGIC;
		MV_KEYBOARD_LOCK_MODE_STAR_NO: in STD_LOGIC;
		MV_KEYBOARD_UNLOCK_MODE: in STD_LOGIC;
		PS_E1_INPUT_STAR_SIF_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_E1_INPUT_STAR_1412_19_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_E_CH_TAU_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_I_O_SYNC_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_E_CH_1301_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_E_CH_1405_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MV_CONS_PRTR_TO_CPU_BUS: in STD_LOGIC_VECTOR (5 downTo 0);
		PS_F1_INPUT_STAR_SIF_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_F1_INPUT_STAR_1414_STAR_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_F1_INPUT_STAR_1412_19_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_F_CH_1301_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_F_CH_1405_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		MC_F_CH_TAU_TO_CPU_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_0_B1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_0_B2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_0_D1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_0_D2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_1_B1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_1_B2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_1_D1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_1_D2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_2_B1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_2_B2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_2_D1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_2_D2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_3_B1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_3_D1_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_3_D2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PV_SENSE_CHAR_3_B2_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_B_DATA_REG_STAR_0_STAR_Z_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_B_DATA_REG_STAR_1_STAR_Z_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_B_DATA_REG_STAR_2_STAR_Z_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		PS_B_DATA_REG_STAR_3_STAR_Z_BUS: in STD_LOGIC_VECTOR (7 downTo 0);
		SWITCH_ROT_STOR_SCAN_DK6: in STD_LOGIC_VECTOR(5 downTo 0);
		SWITCH_MOM_CONS_START: in STD_LOGIC;
		SWITCH_MOM_CE_START: in STD_LOGIC;
		SWITCH_MOM_CONS_STOP_PL1: in STD_LOGIC;
		SWITCH_MOM_CE_STOP_SW_PL1: in STD_LOGIC;
		SWITCH_TOG_I_O_CHK_ST_PL1: in STD_LOGIC;
		SWITCH_TOG_ADDR_STOP_PL1: in STD_LOGIC;
		SWITCH_REL_PWR_ON_RST: in STD_LOGIC;
		SWITCH_MOM_CO_CPR_RST: in STD_LOGIC;
		SWITCH_MOM_CE_CPR_RST: in STD_LOGIC;
		SWITCH_MOM_PROG_RESET: in STD_LOGIC;
		SWITCH_TOG_1401_MODE_PL1: in STD_LOGIC;
		SWITCH_ROT_CHECK_CTRL_DK2: in STD_LOGIC_VECTOR(5 downTo 0);
		SWITCH_MOM_IO_CHK_RST_PL1: in STD_LOGIC;
		SWITCH_ROT_M_RTC_023_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_M_RTC_578_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_MRTC_01234_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_MRTC_56789_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_HRTC_01234_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_HRTC_56789_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_HRTC_012_CC: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_REL_RTC_BUSY: in STD_LOGIC;
		SWITCH_ROT_TENS_SYNC_DK2: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_TENS_SYNC_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_UNITS_SYNC_DK2: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_UNITS_SYNC_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_SCAN_GATE_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_THOUS_SYNC_DK2: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_THOUS_SYNC_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_HUNDS_SYNC_DK2: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_HUNDS_SYNC_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_ADDR_ENTRY_DK3: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_ADDR_SEL_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_MOM_ADDR_DISP: in STD_LOGIC;
		SWITCH_ROT_STOR_SCAN_DK5: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_TOG_ASTERISK_PL2: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_1_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_2_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_4_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_8_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_A_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_B_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_C_PL1: in STD_LOGIC;
		SWITCH_TOG_SENSE_SW_W_PL1: in STD_LOGIC;
		SWITCH_MOM_1ST_TST_SW_PL1: in STD_LOGIC;
		SWITCH_MOM_2ND_TST_SW_PL1: in STD_LOGIC;
		SWITCH_MOM_3RD_TST_SW_PL1: in STD_LOGIC;
		SWITCH_ALT_PRIORITY_PL1: in STD_LOGIC;
		SWITCH_ALT_PRIORITY_PL2: in STD_LOGIC;
		SWITCH_ROT_I_O_UNIT_DK1: in STD_LOGIC_VECTOR(5 downTo 0);
		SWITCH_ROT_MODE_SW_DK: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_MODE_SW_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_TOG_CH_1: in STD_LOGIC;
		SWITCH_TOG_CH_2: in STD_LOGIC;
		SWITCH_TOG_AUTO_START_PL1: in STD_LOGIC;
		SWITCH_ROT_ADDR_ENTRY_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_TOG_WR_INHIBIT_PL1: in STD_LOGIC;
		SWITCH_ROT_STOR_SCAN_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_CYCLE_CTRL_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_ADDR_ENTRY_DKA: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_CHECK_CTRL_DK1: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_TOG_INHIBIT_PO_PL1: in STD_LOGIC;
		SWITCH_ROT_STOR_SCAN_DK4: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_TOG_ASTERISK_PL1: in STD_LOGIC;
		SWITCH_ROT_STOR_SCAN_DK3: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_ROT_ADDR_ENTRY_DK2: in STD_LOGIC_VECTOR(12 downTo 0);
		SWITCH_TOG_INHIBIT_PO_PL2: in STD_LOGIC;
		SWITCH_MOM_STARTPRINT: in STD_LOGIC;
		SWITCH_ROT_CYCLE_CTRL_DK2: in STD_LOGIC_VECTOR(5 downTo 0);
		PS_1ST_CLOCK_PULSE_1: out STD_LOGIC;
		PS_CLOCK_STOPPED_STAR_AUTS_STAR: out STD_LOGIC;
		PS_CLOCK_STOPPED: out STD_LOGIC;
		MS_CLOCK_STOPPED: out STD_LOGIC;
		MS_LOGIC_GATE_B_1: out STD_LOGIC;
		PS_LOGIC_GATE_C_1: out STD_LOGIC;
		MS_LOGIC_GATE_D_1: out STD_LOGIC;
		PS_LOGIC_GATE_D_1: out STD_LOGIC;
		PS_LOGIC_GATE_E_1: out STD_LOGIC;
		PS_LOGIC_GATE_B_OR_C: out STD_LOGIC;
		PS_LOGIC_GATE_D_OR_E_OR_F: out STD_LOGIC;
		PS_LOGIC_GATE_EARLY_B: out STD_LOGIC;
		PS_LOGIC_GATE_EARLY_B_OR_S: out STD_LOGIC;
		PS_I_CYCLE_1: out STD_LOGIC;
		PS_I_CYCLE_DOT_NOT_CR_DISABLE: out STD_LOGIC;
		MS_F_CYCLE_DOT_ANY_LAST_GATE: out STD_LOGIC;
		PS_E_CYCLE_CTRL: out STD_LOGIC;
		PS_E_CYCLE: out STD_LOGIC;
		PS_E_CYCLE_CTRL_STAR_1311: out STD_LOGIC;
		PS_F_CYCLE_CTRL: out STD_LOGIC;
		PS_F_CYCLE: out STD_LOGIC;
		PS_LAST_INSN_RO_CYCLE_2: out STD_LOGIC;
		MS_START_KEY: out STD_LOGIC;
		PS_RUN_OR_IE_MODE_STAR_AUTS_STAR: out STD_LOGIC;
		PS_BRANCH_TO_A_CONDITIONS: out STD_LOGIC;
		PS_E_CH_READY_BUS: out STD_LOGIC;
		MS_E_CH_NOT_READY: out STD_LOGIC;
		MS_COMPUTER_RESET_1: out STD_LOGIC;
		MS_COMPUTER_RESET_2: out STD_LOGIC;
		MC_COMP_RESET_TO_TAPE_STAR_E_CH: out STD_LOGIC;
		MC_E_CH_COMP_RESET_TO_1301: out STD_LOGIC;
		MC_E_CH_COMP_RESET_TO_1405: out STD_LOGIC;
		MC_COMP_RESET_TO_TAPE_STAR_F_CH: out STD_LOGIC;
		MC_F_CH_COMP_RESET_TO_1301: out STD_LOGIC;
		MC_F_CH_COMP_RESET_TO_1405: out STD_LOGIC;
		MC_COMP_RESET_TO_BUFFER: out STD_LOGIC;
		MS_PROGRAM_RESET_6: out STD_LOGIC;
		MS_PROGRAM_RESET_2: out STD_LOGIC;
		PS_1401_MODE: out STD_LOGIC;
		MS_1401_MODE: out STD_LOGIC;
		MC_1401_MODE_TO_1405: out STD_LOGIC;
		PS_OP_REG_ARS_C_BIT: out STD_LOGIC;
		PS_OP_REG_ARS_NOT_C_BIT: out STD_LOGIC;
		PS_OP_DCDR_NOT_B_DOT_NOT_A_DOT_NOT_8_B: out STD_LOGIC;
		PS_OP_DCDR_B_DOT_A_DOT_8_B: out STD_LOGIC;
		PS_OP_DCDR_B_DOT_NOT_A_DOT_NOT_8_B: out STD_LOGIC;
		PS_OP_DCDR_B_DOT_NOT_A_DOT_8_B: out STD_LOGIC;
		PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_NOT_1_B: out STD_LOGIC;
		PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_1_B: out STD_LOGIC;
		PS_OP_DCDR_NOT_4_DOT_2_DOT_NOT_1_B: out STD_LOGIC;
		PS_OP_DCDR_4_DOT_2_DOT_NOT_1_B: out STD_LOGIC;
		PS_OP_DCDR_4_DOT_NOT_2_DOT_NOT_1_B: out STD_LOGIC;
		PS_OP_DCDR_4_DOT_2_DOT_1_B: out STD_LOGIC;
		PS_NOT_B_DOT_NOT_A_DOT_8_OP_MOD: out STD_LOGIC;
		PS_NOT_B_DOT_NOT_A_DOT_NOT_8_OP_MOD: out STD_LOGIC;
		PS_NOT_4_DOT_NOT_2_DOT_NOT_1_OP_MOD: out STD_LOGIC;
		PS_NOT_4_DOT_NOT_2_DOT_1_OP_MOD: out STD_LOGIC;
		PS_NOT_4_DOT_2_DOT_1_OP_MOD: out STD_LOGIC;
		PS_NOT_4_DOT_2_DOT_NOT_1_OP_MOD: out STD_LOGIC;
		PS_4_DOT_2_DOT_NOT_1_OP_MOD: out STD_LOGIC;
		PS_4_DOT_2_DOT_1_OP_MOD: out STD_LOGIC;
		PS_4_DOT_NOT_2_DOT_1_OP_MOD: out STD_LOGIC;
		PS_4_DOT_NOT_2_DOT_NOT_1_OP_MOD: out STD_LOGIC;
		PS_S_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_B_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_E_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_F_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_LOZ_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_R_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_PERCENT_SIGN_OP_MODIFIER: out STD_LOGIC;
		PS_A_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_RECORD_MARK_OP_MODIFIER: out STD_LOGIC;
		PS_C_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_D_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_L_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_EXCLAM_MK_OP_MODIFIER: out STD_LOGIC;
		PS_ONE_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_TWO_SYMBOL_OP_MODIFIER: out STD_LOGIC;
		PS_ASTERISK_OP_MODIFIER: out STD_LOGIC;
		MS_COND_TEST_BRANCH_OP_CODE: out STD_LOGIC;
		MS_INTERRUPT_TEST_OP_CODE: out STD_LOGIC;
		PS_M_OR_L_OP_CODES: out STD_LOGIC;
		MC_CPU_READY_TO_TID: out STD_LOGIC;
		PS_E_CH_DISCON_LATCH: out STD_LOGIC;
		PS_E_CH_DISCON_LATCH_JRJ: out STD_LOGIC;
		MC_E_CH_DISCON_TO_1301: out STD_LOGIC;
		MC_E_CH_DISCON_TO_1405: out STD_LOGIC;
		MS_E_CH_EXT_END_OF_TRANSFER: out STD_LOGIC;
		PS_I_O_COML_AT_LATCH: out STD_LOGIC;
		PS_LOZENGE_OR_ASTERISK: out STD_LOGIC;
		PS_I_O_ASTERISK_LATCH: out STD_LOGIC;
		MC_UNIT_1_SELECT_TO_I_O: out STD_LOGIC;
		MC_UNIT_2_SELECT_TO_I_O: out STD_LOGIC;
		MC_UNIT_4_SELECT_TO_I_O: out STD_LOGIC;
		MC_UNIT_8_SEL_TO_I_O: out STD_LOGIC;
		MC_SELECT_UNIT_P: out STD_LOGIC;
		MC_SELECT_UNIT_D: out STD_LOGIC;
		MS_E_CH_SELECT_UNIT_K: out STD_LOGIC;
		MC_SELECT_UNIT_Q: out STD_LOGIC;
		MC_E_CH_SELECT_UNIT_R: out STD_LOGIC;
		MC_SELECT_UNIT_L: out STD_LOGIC;
		MC_E_CH_SELECT_UNIT_M: out STD_LOGIC;
		MC_SELECT_UNIT_N: out STD_LOGIC;
		PS_E_CH_SELECT_UNIT_F: out STD_LOGIC;
		MC_ODD_PARITY_TO_TAPE_STAR_E_CH: out STD_LOGIC;
		MC_UNIT_SEL_F_STAR_E_CH_1301: out STD_LOGIC;
		MC_UNIT_SEL_F_STAR_E_CH_1405: out STD_LOGIC;
		PS_E_CH_UNOVLP_IN_PROCESS: out STD_LOGIC;
		PS_E_CH_IN_PROCESS: out STD_LOGIC;
		MS_LOAD_CYCLE: out STD_LOGIC;
		PS_E_CH_INT_END_OF_TRANSFER: out STD_LOGIC;
		MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_E_CH: out STD_LOGIC;
		MS_F_CH_RESET: out STD_LOGIC;
		MS_F_CH_RESET_1: out STD_LOGIC;
		PS_F_CH_U_SEL_A_DOT_NOT_8_DOT_NOT_1: out STD_LOGIC;
		MC_ODD_PARITY_TO_TAPE_STAR_F_CH: out STD_LOGIC;
		PS_F_CH_SELECT_UNIT_F_LN_2: out STD_LOGIC;
		MC_UNIT_SEL_F_F_CH_1301: out STD_LOGIC;
		MC_UNIT_SELECT_F_STAR_F_CH_1405: out STD_LOGIC;
		PS_F_CH_UNOVLP_IN_PROCESS: out STD_LOGIC;
		PS_F_CH_IN_PROCESS: out STD_LOGIC;
		PS_E_CH_STATUS_SAMPLE_B: out STD_LOGIC;
		MS_E_CH_STATUS_SAMPLE_B_DELAY: out STD_LOGIC;
		PS_E_CH_SECOND_SAMPLE_B: out STD_LOGIC;
		MS_E_CH_STATUS_SAMPLE_B: out STD_LOGIC;
		PS_E_CH_STATUS_SAMPLE_B_DELAY: out STD_LOGIC;
		PS_E_CH_STATUS_SAMPLE_A: out STD_LOGIC;
		PS_E_CH_STATUS_SAMPLE_A_DELAY: out STD_LOGIC;
		PS_F_CH_CONDITION: out STD_LOGIC;
		MS_F_CH_CHECK: out STD_LOGIC;
		MS_F_CH_END_OF_RECORD_LATCH: out STD_LOGIC;
		PS_F_CH_INT_END_OF_TRANSFER: out STD_LOGIC;
		PS_F_CH_READY_BUS: out STD_LOGIC;
		MS_F_CH_NOT_READY: out STD_LOGIC;
		MS_F_CH_BUSY: out STD_LOGIC;
		MS_F_CH_WRONG_LENGTH_RECORD: out STD_LOGIC;
		MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_F_CH: out STD_LOGIC;
		MC_READ_TAPE_CALL_STAR_F_CH: out STD_LOGIC;
		MC_WRITE_TAPE_CALL_STAR_F_CH: out STD_LOGIC;
		MC_WRITE_TAPE_MK_CALL_STAR_F_CH: out STD_LOGIC;
		MC_ERASE_CALL_STAR_F_CH: out STD_LOGIC;
		MC_REWIND_UNLOAD_STAR_F_CH: out STD_LOGIC;
		MC_REWIND_CALL_STAR_F_CH: out STD_LOGIC;
		MC_BACKSPACE_CALL_STAR_F_CH: out STD_LOGIC;
		MC_DISCONNECT_CALL_STAR_F_CH: out STD_LOGIC;
		MC_TURN_OFF_TI_STAR_F_CH: out STD_LOGIC;
		MC_RESET_TAPE_SEL_REG_STAR_CH_F: out STD_LOGIC;
		MC_SET_TAPE_SEL_REG_STAR_CH_F: out STD_LOGIC;
		PS_F_CH_STATUS_SAMPLE_A_DELAY: out STD_LOGIC;
		PS_F_CH_STATUS_SAMPLE_A: out STD_LOGIC;
		PS_F_CH_STATUS_SAMPLE_B: out STD_LOGIC;
		PS_F_CH_SECOND_SAMPLE_B: out STD_LOGIC;
		PS_F_CH_STATUS_SAMPLE_B_1: out STD_LOGIC;
		MS_F_CH_INT_END_OF_XFER_DELAYED: out STD_LOGIC;
		PS_F_CH_STATUS_SAMPLE_B_DELAY: out STD_LOGIC;
		PS_F_CH_DISCON_LATCH: out STD_LOGIC;
		MC_F_CH_DISCON_TO_1301: out STD_LOGIC;
		MC_F_CH_DISCON_TO_1405: out STD_LOGIC;
		MS_F_CH_EXT_END_OF_TRANSFER: out STD_LOGIC;
		MS_1401_I_O_END: out STD_LOGIC;
		MC_CORRECT_TRANS_TO_BUFFER: out STD_LOGIC;
		MC_RESET_SELECT_BUFFER_LATCHES: out STD_LOGIC;
		MC_READY_TO_BUFFER: out STD_LOGIC;
		MC_1401_MODE_TO_BUFFER: out STD_LOGIC;
		MC_STACK_SELECT_TO_BUFFER: out STD_LOGIC;
		MC_FORMS_CTRL_TO_BUFFER: out STD_LOGIC;
		MC_FORMS_STACKER_GO: out STD_LOGIC;
		MC_TURN_OFF_TAPE_IND_STAR_E_CH: out STD_LOGIC;
		MC_RESET_TAPE_SEL_REG_STAR_E_CH: out STD_LOGIC;
		MC_SET_TAPE_SEL_REG_STAR_E_CH: out STD_LOGIC;
		MC_DISCONNECT_CALL_STAR_E_CH: out STD_LOGIC;
		MC_READ_TAPE_CALL_STAR_E_CH: out STD_LOGIC;
		MC_WRITE_TAPE_CALL_STAR_E_CH: out STD_LOGIC;
		MC_WRITE_TAPE_MK_CALL_STAR_E_CH: out STD_LOGIC;
		MC_ERASE_CALL_STAR_E_CH: out STD_LOGIC;
		MC_REWIND_UNLOAD_STAR_E_CH: out STD_LOGIC;
		MC_REWIND_CALL_STAR_E_CH: out STD_LOGIC;
		MC_BACKSPACE_CALL_STAR_E_CH: out STD_LOGIC;
		PS_E_CH_2ND_ADDR_TRF: out STD_LOGIC;
		MS_E_CH_END_OF_2ND_ADDR_TRF: out STD_LOGIC;
		MC_1405_START_GATE_STAR_E_CH: out STD_LOGIC;
		MC_1301_START_GATE_STAR_E_CH: out STD_LOGIC;
		MC_SEEK_TEST_OP_STAR_E_CH_TO_1405: out STD_LOGIC;
		MC_SEEK_TEST_OP_STAR_E_CH_TO_1301: out STD_LOGIC;
		MC_FILE_STROBE_1ST_ADDR_STAR_E_CH: out STD_LOGIC;
		MC_FILE_STROBE_2ND_ADDR_STAR_E_CH: out STD_LOGIC;
		MC_FILE_DIGIT_ADVANCE_STAR_E_CH: out STD_LOGIC;
		MC_FILE_ADDR_TRF_GATE_STAR_E_CH: out STD_LOGIC;
		MC_E_CH_RBCI_RESET_1405: out STD_LOGIC;
		PS_E_CH_NO_STATUS_ON: out STD_LOGIC;
		PS_F_CH_2ND_ADDR_TRF: out STD_LOGIC;
		PS_F_CH_END_OF_2ND_ADDR_TRF: out STD_LOGIC;
		MC_1301_START_GATE_STAR_F_CH: out STD_LOGIC;
		MC_1405_START_GATE_STAR_F_CH: out STD_LOGIC;
		MC_SEEK_TEST_OP_STAR_F_CH_TO_1405: out STD_LOGIC;
		MC_FILE_STROBE_1ST_ADDR_STAR_F_CH: out STD_LOGIC;
		MC_FILE_STROBE_2ND_ADDR_STAR_F_CH: out STD_LOGIC;
		MC_FILE_DIGIT_ADVANCE_STAR_F_CH: out STD_LOGIC;
		MC_FILE_ADDR_TRF_GATE_STAR_F_CH: out STD_LOGIC;
		MC_SEEK_TEST_OP_STAR_F_CH_TO_1301: out STD_LOGIC;
		MC_F_CH_RBCI_RESET_1405: out STD_LOGIC;
		PS_F_CH_NO_TRANSFER_LATCH: out STD_LOGIC;
		PS_F_CH_NO_STATUS_ON: out STD_LOGIC;
		MS_F_CH_NO_TRANSFER_LATCH: out STD_LOGIC;
		MY_MEM_AR_NOT_TTHP4B: out STD_LOGIC;
		PS_ADDRESS_STOP: out STD_LOGIC;
		PS_OPTIONAL_SYNC_COND_CE: out STD_LOGIC;
		MC_UNIT_NU_0_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_SELECT_NO_0_TO_BUFFER: out STD_LOGIC;
		MC_SEEK_STAR_E_CH_1405: out STD_LOGIC;
		MC_UNIT_NU_1_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MS_E_CH_UNIT_NUMBER_1: out STD_LOGIC;
		MC_SELECT_NO_1_TO_BUFFER: out STD_LOGIC;
		MC_SINGLE_REC_STAR_E_CH_TO_1405: out STD_LOGIC;
		MC_UNIT_NU_2_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_SELECT_NO_2_TO_BUFFER: out STD_LOGIC;
		MC_FULL_TRACK_WITHOUT_IA_STAR_1405_E_CH: out STD_LOGIC;
		MC_UNIT_NU_3_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_SELECT_NO_3_TO_BUFFER: out STD_LOGIC;
		MC_WRITE_CHECK_STAR_E_CH_TO_1405: out STD_LOGIC;
		MC_UNIT_NU_4_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_WRITE_ADDR_STAR_E_CH_TO_1405: out STD_LOGIC;
		MC_UNIT_NU_5_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_UNIT_NU_6_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_UNIT_NU_7_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_UNIT_NU_8_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MC_UNIT_NU_9_TO_TAU_STAR_E_CH: out STD_LOGIC;
		MS_F_CH_UNIT_NUMBER_0: out STD_LOGIC;
		MC_UNIT_NU_0_TO_TAU_STAR_F_CH: out STD_LOGIC;
		PS_F_CH_UNIT_NUMBER_0: out STD_LOGIC;
		MC_SEEK_STAR_F_CH_1405: out STD_LOGIC;
		MC_UNIT_NU_1_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MS_F_CH_UNIT_NUMBER_1: out STD_LOGIC;
		PS_F_CH_UNIT_NUMBER_1: out STD_LOGIC;
		MC_SINGLE_REC_STAR_F_CH_TO_1405: out STD_LOGIC;
		MC_UNIT_NU_2_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MS_F_CH_UNIT_NUMBER_2: out STD_LOGIC;
		MC_FULL_TRACK_WITHOUT_IA_STAR_1405_F_CH: out STD_LOGIC;
		MS_F_CH_UNIT_NUMBER_3: out STD_LOGIC;
		MC_UNIT_NU_3_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MC_WRITE_CHECK_STAR_F_CH_TO_1405: out STD_LOGIC;
		MC_UNIT_NU_4_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MC_WRITE_ADDR_STAR_F_CH_TO_1405: out STD_LOGIC;
		MC_UNIT_NU_5_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MC_UNIT_NU_6_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MC_UNIT_NU_7_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MC_UNIT_NU_8_TO_TAU_STAR_F_CH: out STD_LOGIC;
		MC_UNIT_NU_9_TO_TAU_STAR_F_CH: out STD_LOGIC;
		PS_E_CH_OUTPUT_MODE: out STD_LOGIC;
		PS_E_CH_INPUT_MODE: out STD_LOGIC;
		MC_OUTPUT_MODE_TO_BUFFER: out STD_LOGIC;
		MC_INPUT_MODE_TO_BUFFER: out STD_LOGIC;
		MC_OUTPUT_OP_TO_1301_STAR_E_CH: out STD_LOGIC;
		MC_OUTPUT_OP_TO_1405_STAR_E_CH: out STD_LOGIC;
		MC_INPUT_OP_TO_1405_STAR_E_CH: out STD_LOGIC;
		MC_INPUT_OP_TO_1301_STAR_E_CH: out STD_LOGIC;
		MS_E_CH_MOVE_MODE: out STD_LOGIC;
		MS_E_CH_LOAD_MODE: out STD_LOGIC;
		MS_E_CH_INTERLOCK: out STD_LOGIC;
		MC_LOAD_MODE_TO_1301_STAR_E_CH: out STD_LOGIC;
		MC_LOAD_MODE_TO_1405_STAR_E_CH: out STD_LOGIC;
		PS_SET_E2_REG: out STD_LOGIC;
		PS_SET_E1_REG: out STD_LOGIC;
		PS_F_CH_OUTPUT_MODE: out STD_LOGIC;
		PS_F_CH_INPUT_MODE: out STD_LOGIC;
		MS_INPUT_MODE_F_CH: out STD_LOGIC;
		MC_INPUT_OP_TO_1405_STAR_F_CH: out STD_LOGIC;
		MC_INPUT_OP_TO_1301_STAR_F_CH: out STD_LOGIC;
		MS_F_CH_INPUT_MODE: out STD_LOGIC;
		MC_OUTPUT_OP_TO_1405_STAR_F_CH: out STD_LOGIC;
		MC_OUTPUT_OP_TO_1301_STAR_F_CH: out STD_LOGIC;
		MS_F_CH_LOAD_MODE: out STD_LOGIC;
		PS_F_CH_INTERLOCK: out STD_LOGIC;
		MC_LOAD_MODE_TO_1301_STAR_F_CH: out STD_LOGIC;
		MC_LOAD_MODE_TO_1405_STAR_F_CH: out STD_LOGIC;
		PS_SET_F1_REG: out STD_LOGIC;
		PS_SET_F2_REG: out STD_LOGIC;
		TW_CPU_TO_F_CH_TAU_C_BIT: out STD_LOGIC;
		MS_MASTER_ERROR: out STD_LOGIC;
		MS_MASTER_ERROR_STAR_AUTS_STAR: out STD_LOGIC;
		PS_MASTER_ERROR: out STD_LOGIC;
		PS_INTERRUPT_REQ_STAR_AUTS_STAR: out STD_LOGIC;
		PS_Y_OP_DOT_TEST_RESET: out STD_LOGIC;
		PS_INTERRUPT_TEST_OP_CODE: out STD_LOGIC;
		MS_I_OP_DOT_I_CYCLE_DOT_C: out STD_LOGIC;
		PS_I_OP_DOT_I_CYCLE_DOT_E: out STD_LOGIC;
		MY_MEM_AR_NOT_TP0B_JRJ: out STD_LOGIC;
		MY_MEM_AR_NOT_TP1B_JRJ: out STD_LOGIC;
		MY_MEM_AR_NOT_TP2B_JRJ: out STD_LOGIC;
		MY_MEM_AR_NOT_TP8B_JRJ: out STD_LOGIC;
		MY_MEM_AR_NOT_TP4B_JRJ: out STD_LOGIC;
		MV_GATE_X_LSMS_YY00_09_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY00_09_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY10_19_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY10_19_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY20_29_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY20_29_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY30_39_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY30_39_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY40_49_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY40_49_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY50_59_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY50_59_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY60_60_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY60_69_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY70_79_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY70_79_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY80_89_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY80_89_B: out STD_LOGIC;
		MV_GATE_X_LSMS_YY90_99_A: out STD_LOGIC;
		MV_GATE_X_LSMS_YY90_99_B: out STD_LOGIC;
		MY_MEM_AR_NOT_HP8B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP4B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP2B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP1B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP0B_Z: out STD_LOGIC;
		MY_GATE_Y_LSMS_00_09XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_00_09XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_10_19XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_10_19XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_20_29XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_20_29XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_30_39XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_30_39XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_40_49XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_40_49XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_50_59XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_50_59XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_60_69XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_60_69XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_70_79XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_70_79XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_80_89XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_80_89XX_B: out STD_LOGIC;
		MY_GATE_Y_LSMS_90_99XX_A: out STD_LOGIC;
		MY_GATE_Y_LSMS_90_99XX_B: out STD_LOGIC;
		MY_X_RD_1: out STD_LOGIC;
		MY_B_DATA_REG_RESET: out STD_LOGIC;
		PY_START_READ: out STD_LOGIC;
		MY_X_WR_1: out STD_LOGIC;
		PY_START_WRITE: out STD_LOGIC;
		MY_LOAD_MEMORY_Z: out STD_LOGIC;
		MY_REGEN_MEMORY_Z: out STD_LOGIC;
		PY_1ST_CHECK_TEST_Z: out STD_LOGIC;
		PY_2ND_CHECK_TEST_Z: out STD_LOGIC;
		PY_COMPUTER_RESET: out STD_LOGIC;
		PS_DENSITY_SW_556_OR_200_CH_1: out STD_LOGIC;
		PS_DENSITY_SW_800_OR_556_CH_1: out STD_LOGIC;
		PS_DENSITY_SW_556_OR_200_CH_2: out STD_LOGIC;
		PS_DENSITY_SW_800_OR_556_CH_2: out STD_LOGIC;
		MC_DISK_WRITE_NORMAL_STAR_F_CH: out STD_LOGIC;
		MC_DISK_WRITE_NORMAL_STAR_E_CH: out STD_LOGIC;
		MS_CONSOLE_INHIBIT_AR_RO: out STD_LOGIC;
		PS_LOGIC_STEP_OR_IE_OR_STG_CY_STAR_AUTS_STAR: out STD_LOGIC;
		PS_CONS_CLOCK_1_POS: out STD_LOGIC;
		PS_CONS_CLOCK_3_POS_1: out STD_LOGIC;
		MS_CONSOLE_CHECK_STROBE: out STD_LOGIC;
		PW_UPPER_CASE_SHIFT_SOLENOID: out STD_LOGIC;
		PW_LOWER_CASE_SHIFT_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_R1_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_R2A_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_R2_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_R5_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_T1_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_T2_SOLENOID: out STD_LOGIC;
		PW_CONS_PRINTER_CHK_SOLENOID: out STD_LOGIC;
		PW_BACKSPACE_SOLENOID: out STD_LOGIC;
		PW_CARRIAGE_RETURN_SOLENOID: out STD_LOGIC;
		PW_SPACE_SOLENOID: out STD_LOGIC;
		MW_KEYBOARD_LOCK_SOLENOID: out STD_LOGIC;
		LAMP_15A1K24: out STD_LOGIC;
		LAMP_15A1A16: out STD_LOGIC;
		LAMP_15A1C16: out STD_LOGIC;
		LAMP_15A1E16: out STD_LOGIC;
		LAMP_15A1F16: out STD_LOGIC;
		LAMP_15A1K23: out STD_LOGIC;
		LAMP_15A1H14: out STD_LOGIC;
		LAMP_15A1K14: out STD_LOGIC;
		LAMP_15A1H16: out STD_LOGIC;
		LAMP_15A1K15: out STD_LOGIC;
		LAMP_15A1H15: out STD_LOGIC;
		LAMP_15A1E17: out STD_LOGIC;
		LAMP_15A1F17: out STD_LOGIC;
		LAMP_15A1A17: out STD_LOGIC;
		LAMP_15A1C17: out STD_LOGIC;
		LAMP_15A1H17: out STD_LOGIC;
		LAMP_15A1B14: out STD_LOGIC;
		LAMP_15A1K16: out STD_LOGIC;
		LAMP_15A1C15: out STD_LOGIC;
		LAMP_15A1K17: out STD_LOGIC;
		LAMP_15A1E21: out STD_LOGIC;
		LAMP_11C8K07: out STD_LOGIC;
		LAMP_11C8J07: out STD_LOGIC;
		LAMP_11C8H07: out STD_LOGIC;
		LAMP_11C8G07: out STD_LOGIC;
		LAMP_11C8F07: out STD_LOGIC;
		LAMP_11C8A02: out STD_LOGIC;
		LAMP_11C8B02: out STD_LOGIC;
		LAMP_11C8A01: out STD_LOGIC;
		LAMP_11C8B01: out STD_LOGIC;
		LAMP_15A1K20: out STD_LOGIC;
		LAMP_11C8C14: out STD_LOGIC;
		LAMP_11C8D14: out STD_LOGIC;
		LAMP_11C8E14: out STD_LOGIC;
		LAMP_11C8F14: out STD_LOGIC;
		LAMP_15A1E14: out STD_LOGIC;
		LAMP_15A1F14: out STD_LOGIC;
		LAMP_15A1A14: out STD_LOGIC;
		LAMP_15A1E15: out STD_LOGIC;
		LAMP_15A1F15: out STD_LOGIC;
		LAMP_15A1A15: out STD_LOGIC;
		LAMP_15A1C11: out STD_LOGIC;
		LAMP_15A1K12: out STD_LOGIC;
		LAMP_15A1F11: out STD_LOGIC;
		LAMP_15A1E11: out STD_LOGIC;
		LAMP_15A1A11: out STD_LOGIC;
		LAMP_15A1G08: out STD_LOGIC;
		LAMP_15A1H08: out STD_LOGIC;
		LAMP_15A1J08: out STD_LOGIC;
		LAMP_15A1K08: out STD_LOGIC;
		LAMP_15A1H12: out STD_LOGIC;
		LAMP_15A1F12: out STD_LOGIC;
		LAMP_15A1A12: out STD_LOGIC;
		LAMP_15A1E12: out STD_LOGIC;
		LAMP_15A1C12: out STD_LOGIC;
		LAMP_11C8A12: out STD_LOGIC;
		LAMP_15A1A19: out STD_LOGIC;
		LAMP_11C8A13: out STD_LOGIC;
		LAMP_15A1C19: out STD_LOGIC;
		LAMP_15A1B19: out STD_LOGIC;
		LAMP_11C8A10: out STD_LOGIC;
		LAMP_15A1H20: out STD_LOGIC;
		LAMP_15A1H19: out STD_LOGIC;
		LAMP_15A1F19: out STD_LOGIC;
		LAMP_11C8A07: out STD_LOGIC;
		LAMP_15A1E20: out STD_LOGIC;
		LAMP_15A1F20: out STD_LOGIC;
		LAMP_15A1C20: out STD_LOGIC;
		LAMP_15A1V01: out STD_LOGIC;
		LAMP_15A1B15: out STD_LOGIC;
		LAMP_15A1W01: out STD_LOGIC;
		LAMP_15A1W04: out STD_LOGIC;
		LAMP_15A2K03: out STD_LOGIC;
		LAMP_15A2K05: out STD_LOGIC;
		LAMP_15A1K22: out STD_LOGIC;
		LAMP_15A1K21: out STD_LOGIC;
		LAMP_11C8A04: out STD_LOGIC;
		LAMP_11C8B05: out STD_LOGIC;
		LAMP_11C8B04: out STD_LOGIC;
		LAMP_11C8A05: out STD_LOGIC;
		PS_I_RING_HDL_BUS: out STD_LOGIC_VECTOR (12 downTo 0);
		PS_OP_MOD_REG_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_OP_MOD_REG_NOT_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MY_MEM_AR_NOT_UP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_UP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_NOT_TP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_TP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_NOT_HP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_HP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_NOT_THP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_THP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_TTHP_BUS: out STD_LOGIC_VECTOR (4 downTo 0);
		PS_A_CH_NOT_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MY_ASSEMBLY_CH_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_E_CH_UNIT_STAR_1301_STAR_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_E_CH_U_SEL_REG_NOT_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_E_CH_U_SEL_REG_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_F_CH_UNIT_STAR_1301_STAR_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_F_CH_U_SEL_REG_NOT_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_F_CH_U_SEL_REG_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_E2_REG_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_E_CH_TAU_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_I_O_SYNC_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_E_CH_1301_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_E_CH_1405_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PS_F2_REG_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MS_F2_REG_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_F_CH_TAU_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_F_CH_1301_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MC_CPU_TO_F_CH_1405_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		PV_X_LSMS_DRV_IN_BUS: out STD_LOGIC_VECTOR (15 downTo 0);
		PV_Y_LSMS_DRV_IN_BUS: out STD_LOGIC_VECTOR (15 downTo 0);
		MV_INH_CHAR_0_D1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_0_B1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_1_D1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_1_B1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_2_D1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_2_B1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_3_D1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MV_INH_CHAR_3_B1_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		MY_ASSEMBLY_CH_Z_BUS: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_LOGIC_GATE_RING: out STD_LOGIC_VECTOR (10 downTo 1);
		LAMPS_IRING: out STD_LOGIC_VECTOR (12 downTo 0);
		LAMPS_CYCLE_CE: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_CYCLE_CONSOLE: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_SCAN: out STD_LOGIC_VECTOR (3 downTo 0);
		LAMPS_OPREG_CE: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_OPMOD_CE: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_MAR_UP: out STD_LOGIC_VECTOR (4 downTo 0);
		LAMPS_MAR_TP: out STD_LOGIC_VECTOR (4 downTo 0);
		LAMPS_MAR_HP: out STD_LOGIC_VECTOR (4 downTo 0);
		LAMPS_MAR_THP: out STD_LOGIC_VECTOR (4 downTo 0);
		LAMPS_MAR_TTHP: out STD_LOGIC_VECTOR (4 downTo 0);
		LAMPS_ARING: out STD_LOGIC_VECTOR (6 downTo 1);
		LAMPS_B_CH: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_A_CH: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_ASSM_CH_NOT: out STD_LOGIC_VECTOR (7 downTo 0);
		LAMPS_ASSM_CH: out STD_LOGIC_VECTOR (7 downTo 0));
	end component;

   component IBM1410Memory is
   Port (
      FPGA_CLK: in STD_LOGIC;
      MY_X_RD_1: in STD_LOGIC;
      MY_X_WR_1: in STD_LOGIC;
      MY_MEM_AR_NOT_UP_BUS: in STD_LOGIC_VECTOR(4 downto 0);
      MY_MEM_AR_NOT_TP_BUS: in STD_LOGIC_VECTOR(4 downto 0);
      MY_MEM_AR_NOT_HP_BUS: in STD_LOGIC_VECTOR(4 downto 0);
      MY_MEM_AR_NOT_THP_BUS: in STD_LOGIC_VECTOR(4 downto 0);
      MY_MEM_AR_NOT_TTHP_BUS: in STD_LOGIC_VECTOR(4 downto 0);
      MV_INH_CHAR_0_B1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_0_D1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_1_B1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_1_D1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_2_B1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_2_D1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_3_B1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      MV_INH_CHAR_3_D1_BUS: in STD_LOGIC_VECTOR(7 downto 0);
      PV_SENSE_CHAR_0_BUS: out STD_LOGIC_VECTOR(7 downto 0);
      PV_SENSE_CHAR_1_BUS: out STD_LOGIC_VECTOR(7 downto 0);
      PV_SENSE_CHAR_2_BUS: out STD_LOGIC_VECTOR(7 downto 0);
      PV_SENSE_CHAR_3_BUS: out STD_LOGIC_VECTOR(7 downto 0);
      
      IBM1410_DIRECT_MEMORY_ADDRESS:      in STD_LOGIC_VECTOR(13 downto 0);
      IBM1410_DIRECT_MEMORY_ENABLE:       in STD_LOGIC_VECTOR(3 downto 0);
      IBM1410_DIRECT_MEMORY_WRITE_ENABLE: in STD_LOGIC_VECTOR(3 downto 0);
      IBM1410_DIRECT_MEMORY_WRITE_DATA:   in STD_LOGIC_VECTOR(7 downto 0);
      IBM1410_DIRECT_MEMORY_READ_DATA_0:    out STD_LOGIC_VECTOR(7 downto 0);
      IBM1410_DIRECT_MEMORY_READ_DATA_1:    out STD_LOGIC_VECTOR(7 downto 0);
      IBM1410_DIRECT_MEMORY_READ_DATA_2:    out STD_LOGIC_VECTOR(7 downto 0);
      IBM1410_DIRECT_MEMORY_READ_DATA_3:    out STD_LOGIC_VECTOR(7 downto 0)
      );
   end component;

component IBM1410ConsoleTypewriter is
   -- GENERIC(MULTIPLIER: integer := 10000);
   PORT (
      FPGA_CLK: in STD_LOGIC;
      UART_RESET: in STD_LOGIC;
      SLOW_TYPING: in STD_LOGIC;

      PW_CONS_PRINTER_R1_SOLENOID: in STD_LOGIC;      
      PW_CONS_PRINTER_R2_SOLENOID: in STD_LOGIC;
      PW_CONS_PRINTER_R2A_SOLENOID: in STD_LOGIC;
      PW_CONS_PRINTER_R5_SOLENOID: in STD_LOGIC;
      PW_CONS_PRINTER_T1_SOLENOID: in STD_LOGIC;
      PW_CONS_PRINTER_T2_SOLENOID: in STD_LOGIC;

      PW_UPPER_CASE_SHIFT_SOLENOID: in STD_LOGIC;
      PW_LOWER_CASE_SHIFT_SOLENOID: in STD_LOGIC;
      PW_BACKSPACE_SOLENOID: in STD_LOGIC;
      PW_SPACE_SOLENOID: in STD_LOGIC;
      PW_CARRIAGE_RETURN_SOLENOID: in STD_LOGIC;      

      MW_KEYBOARD_LOCK_SOLENOID: in STD_LOGIC;
      PW_CONS_PRINTER_CHK_SOLENOID: in STD_LOGIC;
      
      MV_CONS_PRINTER_C1_CAM_NO: out STD_LOGIC;
      MV_CONS_PRINTER_C1_CAM_NC: out STD_LOGIC;
      MV_CONS_PRINTER_C2_CAM_NC: out STD_LOGIC;
      MV_CONS_PRINTER_C2_CAM_NO: out STD_LOGIC;
      MV_CONS_PRINTER_C3_OR_C4_NO: out STD_LOGIC;

      MV_CONS_PRINTER_SPACE_NO: out STD_LOGIC;
      
      MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC: out STD_LOGIC;
      MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO: out STD_LOGIC;
      MB_CONS_PRINTER_EVEN_BIT_CHECK: out STD_LOGIC;
      MV_CONS_PRINTER_ODD_BIT_CHECK: out STD_LOGIC; 
      MV_KEYBOARD_LOCK_MODE_STAR_NO: out STD_LOGIC;
      MV_KEYBOARD_UNLOCK_MODE: out STD_LOGIC;
      
      MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO: out STD_LOGIC;
      MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO: out STD_LOGIC;
      PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC: out STD_LOGIC;
      MV_CONS_PRINTER_LAST_COLUMN_SET: out STD_LOGIC;
      
      MV_CONS_PRTR_TO_CPU_BUS: out STD_LOGIC_VECTOR(5 downto 0);
      MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO: out STD_LOGIC;
      MV_CONSOLE_C_INPUT_STAR_CHK_OP: out STD_LOGIC;
      
      -- Console Output UART support
      
      IBM1410_CONSOLE_XMT_CHAR: out STD_LOGIC_VECTOR(7 downto 0);
      IBM1410_CONSOLE_XMT_STROBE: out STD_LOGIC;
      
       -- Console Input UART
       
      IBM1410_CONSOLE_INPUT_FIFO_WRITE_ENABLE: in STD_LOGIC;
      IBM1410_CONSOLE_INPUT_FIFO_WRITE_DATA: in STD_LOGIC_VECTOR(7 downto 0)
       );
      
end component;

component IBM1410TapeAdapterUnit is
  
   GENERIC(
       CHANNEL_STROBE_LENGTH: integer;
       CHANNEL_CYCLE_LENGTH: integer;
       TAU_OUTPUT_FIFO_SIZE: integer );
   PORT (
       FPGA_CLK: in STD_LOGIC;
        
       -- TAU Input Signals From CPU
       
       MC_CPU_TO_TAU_BUS: in STD_LOGIC_VECTOR(7 downto 0);       
       
       MC_COMP_RESET_TO_TAPE: in STD_LOGIC;
       MC_WRITE_TAPE_CALL: in STD_LOGIC;
       MC_WRITE_TAPE_MK_CALL: in STD_LOGIC;
       MC_ERASE_CALL: in STD_LOGIC;
       MC_REWIND_UNLOAD: in STD_LOGIC;
       MC_REWIND_CALL: in STD_LOGIC;
       MC_BACKSPACE_CALL: in STD_LOGIC;
       MC_TURN_OFF_TAPE_IND: in STD_LOGIC;
       MC_RESET_TAPE_SEL_REG: in STD_LOGIC;
       MC_SET_TAPE_SEL_REG: in STD_LOGIC;
       MC_DISCONNECT_CALL: in STD_LOGIC;
       MC_READ_TAPE_CALL: in STD_LOGIC;
       MC_ODD_PARITY_TO_TAPE: in STD_LOGIC;
       
       MC_UNIT_NU_0_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_1_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_2_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_3_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_4_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_5_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_6_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_7_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_8_TO_TAU: in STD_LOGIC;
       MC_UNIT_NU_9_TO_TAU: in STD_LOGIC;       
            
       -- TAU Output Signals to CPU
       
       MC_TAU_TO_CPU_BUS: out STD_LOGIC_VECTOR(7 downto 0);

       MC_WRITE_CONDITION: out STD_LOGIC;
       MC_SELECT_AND_REWIND: out STD_LOGIC;
       MC_SELECT_AT_LOAD_POINT: out STD_LOGIC;
       MC_SEL_OR_TAPE_IND_ON: out STD_LOGIC;
       
       MC_TAPE_READ_STROBE: out STD_LOGIC;
       MC_TAPE_BUSY: out STD_LOGIC;
       MC_TAPE_ERROR: out STD_LOGIC;
       MC_TAPE_READY: out STD_LOGIC;
       MC_TAPE_WRITE_STROBE: out STD_LOGIC;
       MC_TAPE_IN_PROCESS: out STD_LOGIC;
      
       -- TAU to PC Support System
       
       IBM1410_TAU_XMT_UART_DATA: out STD_LOGIC_VECTOR(7 downto 0);
       IBM1410_TAU_XMT_UART_REQUEST: out STD_LOGIC;
       IBM1410_TAU_XMT_UART_GRANT: in STD_LOGIC;       
              
       -- PC Support System to TAU 
       
       IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE: in STD_LOGIC;
       IBM1410_TAU_INPUT_FIFO_WRITE_DATA: in STD_LOGIC_VECTOR(7 downto 0)       
   );

end component;

	-- Inputs

	signal FPGA_CLK: STD_LOGIC := '0';
	signal PP_SPECIAL_OR_12V_POWER_FOR_OSC: STD_LOGIC := '0';
	signal MV_36_VOLTS: STD_LOGIC := '1';
	signal PS_INSTRUCTION_CHECK_GATE_STAR_1311: STD_LOGIC := '0';
	signal MS_FORMS_STACK_GO_F_CH_STAR_1414_STAR: STD_LOGIC := '1';
	signal PS_COMP_DISABLE_CYCLE_STAR_1412_19: STD_LOGIC := '0';
	signal PS_START_AUTO_STARTMODE_STAR_AUTS_STAR: STD_LOGIC := '0';
	signal PS_RESET_STOP_KEY_LATCH_STAR_AUTS_STAR: STD_LOGIC := '0';
	signal M36_VOLTS: STD_LOGIC := '1';
	signal PS_BRANCH_TO_A_COND_STAR_1412_19: STD_LOGIC := '0';
	signal PS_SET_NO_SCAN_CTRL_STAR_1412_19: STD_LOGIC := '0';
	signal PS_SET_B_CYCLE_CTRL_STAR_1412_19: STD_LOGIC := '0';
	signal PS_NO_BRANCH_COND_STAR_1412_19: STD_LOGIC := '0';
	signal PS_LAST_EXECUTE_CYCLE_STAR_1412_19: STD_LOGIC := '0';
	signal MC_BUFFER_INQ_REQUEST: STD_LOGIC := '1';
	signal MC_BUFFER_OUTQUIRY_PULSE: STD_LOGIC := '1';
	signal PS_SPEC_BRANCH_LATCH_STAR_1414_STAR: STD_LOGIC := '0';
	signal MC_PRINTER_CHANNEL_9: STD_LOGIC := '1';
	signal MC_PRINTER_CHANNEL_12: STD_LOGIC := '1';
	signal MC_FORMS_BUSY_STATUS_TO_CPU: STD_LOGIC := '1';
	signal MC_READ_COLUMN_BINARY: STD_LOGIC := '1';
	signal MC_1301_READY_E_CH: STD_LOGIC := '1';
	signal MC_1405_READY_E_CH: STD_LOGIC := '1';
	signal MC_BUFFER_READY: STD_LOGIC := '1';
	signal PS_E_CH_READY_BUS_STAR_SIF: STD_LOGIC := '0';
	signal PS_E_CH_READY_BUS_STAR_1412_19: STD_LOGIC := '0';
	signal MC_TAPE_READY: STD_LOGIC := '1';
	signal MC_TAPE_READY_F_CH_JRJ: STD_LOGIC := '1';
	signal MC_BUFFER_READY_JRJ: STD_LOGIC := '1';
	signal MC_SELECT_AND_REWIND_STAR_E_CH: STD_LOGIC := '1';
	signal MC_1301_BUSY_E_CH: STD_LOGIC := '1';
	signal PS_E_CH_BUSY_BUS_STAR_1412_19: STD_LOGIC := '0';
	signal MC_1405_BUSY_E_CH: STD_LOGIC := '1';
	signal MC_BUFFER_BUSY: STD_LOGIC := '1';
	signal MC_BUFFER_BUSY_JRJ: STD_LOGIC := '1';
	signal MC_TAPE_BUSY: STD_LOGIC := '1';
	signal MC_TAPE_BUSY_F_CH_JRJ: STD_LOGIC := '1';
	signal MC_1301_ERROR_E_CH: STD_LOGIC := '1';
	signal MC_1405_ERROR_E_CH: STD_LOGIC := '1';
	signal MC_BUFFER_ERROR: STD_LOGIC := '1';
	signal MC_BUFFER_ERROR_JRJ: STD_LOGIC := '1';
	signal PS_E_CH_CHECK_BUS_STAR_SIF: STD_LOGIC := '0';
	signal PS_E_CH_CHECK_BUS_STAR_1412_19: STD_LOGIC := '0';
	signal MC_TAPE_ERROR: STD_LOGIC := '1';
	signal MC_TAPE_ERROR_F_CH_JRJ: STD_LOGIC := '1';
	signal MC_1301_E_CH_CONDITION: STD_LOGIC := '1';
	signal MC_1405_CONDITION_E_CH: STD_LOGIC := '1';
	signal MC_BUFFER_CONDITION: STD_LOGIC := '1';
	signal MC_BUFFER_CONDITION_JRJ: STD_LOGIC := '1';
	signal MC_SEL_OR_TAPE_IND_ON_CH_1: STD_LOGIC := '1';
	signal MC_RBC_ERROR_1405_E_CH: STD_LOGIC := '1';
	signal PS_E_CH_COND_LATCH_STAR_SIF: STD_LOGIC := '0';
	signal MV_CONSOLE_PWR_SUPPLY_36_VOLTS: STD_LOGIC := '1';
	signal PS_OP_MOD_SYM_IO_STATUS_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF: STD_LOGIC := '0';
	signal PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF_JRJ: STD_LOGIC := '0';
	signal PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF: STD_LOGIC := '0';
	signal PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF_JRJ: STD_LOGIC := '0';
	signal MS_I_OR_O_OP_CODES_STAR_12_19: STD_LOGIC := '1';
	signal MS_E_CH_2_CHAR_OP_CODES_STAR_1414_STAR: STD_LOGIC := '1';
	signal PS_P_OR_Q_2_CHAR_OP_1412_19: STD_LOGIC := '0';
	signal MC_1301_END_ADDR_TRF_E_CH: STD_LOGIC := '1';
	signal MC_BUFFER_END_OF_TRANSFER: STD_LOGIC := '1';
	signal PS_E_CH_EXT_END_OF_TRF_STAR_1311: STD_LOGIC := '0';
	signal PS_E_CH_EXT_END_OF_TRF_STAR_SIF: STD_LOGIC := '0';
	signal PS_E_CH_EXT_END_OF_TRF_STAR_1412_19: STD_LOGIC := '0';
	signal MC_1405_END_OF_OP_STAR_E_CH: STD_LOGIC := '1';
	signal UNNAMED_26_DOT_00_DOT_01_DOT_0: STD_LOGIC := '0';
	signal MC_TAPE_IN_PROCESS: STD_LOGIC := '1';
	signal MC_TAPE_IN_PROCESS_F_CH_JRJ: STD_LOGIC := '1';
	signal MC_1301_END_OF_OP_STAR_E_CH: STD_LOGIC := '1';
	signal PS_GATE_OFF_E_CH_EXT_END_OF_TRF: STD_LOGIC := '0';
	signal MS_E_CH_SEL_ODD_PARITY_STAR_1412_19: STD_LOGIC := '1';
	signal PS_E_CH_SELECT_7_BIT_UNIT_STAR_SIF: STD_LOGIC := '0';
	signal PS_END_OF_RECORD_STAR_1311: STD_LOGIC := '0';
	signal PS_E_CH_SIF_SENSE_OR_CONTROL: STD_LOGIC := '0';
	signal PS_INT_END_OF_XFER_STAR_1311: STD_LOGIC := '0';
	signal PS_F_CH_RESET_STAR_1414: STD_LOGIC := '0';
	signal PS_F_CH_SELECT_ODD_PARITY_STAR_1414: STD_LOGIC := '0';
	signal PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_SIF: STD_LOGIC := '0';
	signal PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_2_9: STD_LOGIC := '0';
	signal PS_F_CH_SELECT_7_BIT_UNIT_STAR_SIF: STD_LOGIC := '0';
	signal PS_F_CH_SELECT_7_BIT_UNIT_STAR_1414: STD_LOGIC := '0';
	signal MC_FILE_INVALID_ADDRESS_1405: STD_LOGIC := '1';
	signal MS_E_CH_U_SEL_K_DOT_S_OP_MOD: STD_LOGIC := '1';
	signal MS_F_CH_U_SEL_K_DOT_S_OP_MOD: STD_LOGIC := '1';
	signal MS_RECOVER_LATCH_STAR_1311: STD_LOGIC := '1';
	signal PS_GT_OFF_E_CH_ST_SPL_DLY: STD_LOGIC := '0';
	signal PS_BLOCK_IO_LAST_EXECUTE: STD_LOGIC := '0';
	signal MS_F_CH_CON_LAT_SET_STAR_1414_STAR: STD_LOGIC := '1';
	signal MC_1301_ERROR_F_CH: STD_LOGIC := '1';
	signal MC_1405_ERROR_F_CH: STD_LOGIC := '1';
	signal PS_F_CH_CHECK_STAR_SIF: STD_LOGIC := '0';
	signal PS_F_CH_CHECK_BUS_STAR_1414_STAR: STD_LOGIC := '0';
	signal MC_RBC_ERROR_1405_F_CH: STD_LOGIC := '1';
	signal PS_F_CH_CHECK_STAR_1412_19: STD_LOGIC := '0';
	signal MS_F_CH_COND_LATCH_STAR_SIF: STD_LOGIC := '1';
	signal TW_RBC_ERROR_1405_F_CH: STD_LOGIC := '0';
	signal MC_1301_F_CH_CONDITION: STD_LOGIC := '1';
	signal MC_1405_CONDITION_F_CH: STD_LOGIC := '1';
	signal MC_SEL_OR_TI_ON_CH_2: STD_LOGIC := '1';
	signal PS_F_CH_COND_BUS_STAR_1414_STAR: STD_LOGIC := '0';
	signal MS_SET_F_CH_CON_LATCH_STAR_1414_STAR: STD_LOGIC := '1';
	signal PS_F_CH_SIF_SENSE_OR_CONTROL: STD_LOGIC := '0';
	signal MC_1301_READY_F_CH: STD_LOGIC := '1';
	signal MC_1405_READY_F_CH: STD_LOGIC := '1';
	signal PS_F_CH_READY_BUS_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_F_CH_READY_BUS_STAR_1412_19: STD_LOGIC := '0';
	signal PS_F_CH_READY_BUS_STAR_SIF: STD_LOGIC := '0';
	signal MC_SELECT_AND_REWIND_STAR_F_CH: STD_LOGIC := '1';
	signal PS_F_CH_BUSY_BUS_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_F_CH_BUSY_BUS_STAR_1412_19: STD_LOGIC := '0';
	signal MC_1301_BUSY_F_CH: STD_LOGIC := '1';
	signal MC_1405_BUSY_F_CH: STD_LOGIC := '1';
	signal PS_F_CH_CLR_LATCH_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_RESET_F_CH_CLR_LAT_STAR_1414_STAR: STD_LOGIC := '0';
	signal MC_SELECT_AT_LOAD_POINT_STAR_F_CH: STD_LOGIC := '1';
	signal MC_WRITE_CONDITION_STAR_F_CH: STD_LOGIC := '1';
	signal PS_ASSEMBLY_TO_F_CH_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_GATE_F_CH_ST_SAMPLE_A_STAR_1414_STAR: STD_LOGIC := '0';
	signal MC_1301_END_ADDR_TRF_F_CH: STD_LOGIC := '1';
	signal PS_SET_F_CH_EXT_END_TRF_STAR_SIF: STD_LOGIC := '0';
	signal PS_F_CH_EXT_END_OF_TRF_BUS_STAR_1414: STD_LOGIC := '0';
	signal PS_SET_F_CH_EXT_END_TRF_STAR_1412_19: STD_LOGIC := '0';
	signal MC_1301_END_OF_OP_STAR_F_CH: STD_LOGIC := '1';
	signal MC_1405_END_OF_OP_STAR_F_CH: STD_LOGIC := '1';
	signal MC_1403_PRINT_BUFFER_BUSY: STD_LOGIC := '1';
	signal MC_I_O_PRINTER_READY: STD_LOGIC := '1';
	signal MC_SELECT_AT_LOAD_POINT_STAR_E_CH: STD_LOGIC := '1';
	signal MC_WRITE_CONDITION_STAR_E_CH: STD_LOGIC := '1';
	signal PS_GATE_ON_E_CH_END_ADDR_TRF: STD_LOGIC := '0';
	signal PS_WR_INHIBIT_STAR_7631_STAR_E_CH: STD_LOGIC := '0';
	signal PS_SET_E_CH_NO_TRANS_LAT_STAR_SIF: STD_LOGIC := '0';
	signal PS_SET_E_CH_NO_TRANS_LAT_STAR_12_19: STD_LOGIC := '0';
	signal MC_BUFFER_NO_TRANS_COND: STD_LOGIC := '1';
	signal MC_BUFFER_NO_TRANS_COND_JRJ: STD_LOGIC := '1';
	signal MC_ADDR_COMP_TRUE_F_CH: STD_LOGIC := '1';
	signal MC_FAST_FILE_ON_LINE_F_CH: STD_LOGIC := '1';
	signal MS_1311_F_CH_END_ADDR_TRF: STD_LOGIC := '1';
	signal PS_WR_INHIBIT_STAR_7631_STAR_F_CH: STD_LOGIC := '0';
	signal PS_F_CH_NO_TRF_LATCH_STAR_SIF: STD_LOGIC := '0';
	signal PS_SET_F_CH_NO_TRANS_LAT_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_F_CH_NO_TRANS_LAT_STAR_12_19: STD_LOGIC := '0';
	signal MC_E_CH_FILE_DIGIT_RING_7: STD_LOGIC := '1';
	signal MC_F_CH_FILE_DIGIT_RING_7: STD_LOGIC := '1';
	signal MINUS_36_VOLTS: STD_LOGIC := '1';
	signal PS_OPTIONAL_SYNC_COND_STAR_CE: STD_LOGIC := '0';
	signal MS_OPTIONAL_SYNC_COND_A: STD_LOGIC := '1';
	signal MS_OPTIONAL_SYNC_COND_B: STD_LOGIC := '1';
	signal PS_BLOCK_ADDR_MOD_OR_1_STAR_1412_19: STD_LOGIC := '0';
	signal PS_ADDR_MOD_SET_TO_1_STAR_1412_19: STD_LOGIC := '0';
	signal PS_1311_SET_AAR: STD_LOGIC := '0';
	signal PS_1311_SET_DAR_STAR_1401: STD_LOGIC := '0';
	signal PS_1311_RESET_AAR: STD_LOGIC := '0';
	signal MS_1311_RESET_DAR_STAR_1401: STD_LOGIC := '1';
	signal MS_SCAN_RESTART_LATCH_STAR_1311: STD_LOGIC := '1';
	signal PS_BLOCK_BAR_RO_E_CH_STAR_1311: STD_LOGIC := '0';
	signal PS_BLOCK_BAR_RO_F_CH_STAR_1311: STD_LOGIC := '0';
	signal PS_1311_RO_DAR_STAR_1401: STD_LOGIC := '0';
	signal PS_E2_FULL_LATCH_STAR_SIF: STD_LOGIC := '0';
	signal MS_F_CH_OUTPUT_WM_CYCLE_STAR_1414_STAR: STD_LOGIC := '1';
	signal PS_OUTPUT_FIELD_CYCLE_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_ASM_CH_A_BIT_STAR_STERLING: STD_LOGIC := '0';
	signal MS_SET_F_U_SEL_REG_2_BIT_STAR_1414_STAR: STD_LOGIC := '1';
	signal MS_SET_F_U_SEL_REG_1_BIT_STAR_1414_STAR: STD_LOGIC := '1';
	signal MV_CONSOLE_C_INPUT_STAR_CHK_OP: STD_LOGIC := '1';
	signal MC_BUFFER_STROBE: STD_LOGIC := '1';
	signal MC_SET_ECH_STROB_TR_E_FR_FEATS: STD_LOGIC := '1';
	signal TW_SET_ECH_STROB_TR_E_FR_FEATS: STD_LOGIC := '0';
	signal MC_BUFFER_STROBE_JRJ: STD_LOGIC := '1';
	signal MC_TAPE_WRITE_STROBE: STD_LOGIC := '1';
	signal MC_TAPE_WRITE_STROBE_F_CH_JRJ: STD_LOGIC := '1';
	signal MC_1301_STROBE_E_CH: STD_LOGIC := '1';
	signal MC_1405_STROBE_E_CH: STD_LOGIC := '1';
	signal MC_TAPE_READ_STROBE: STD_LOGIC := '1';
	signal MC_TAPE_READ_STROBE_F_CH_JRJ: STD_LOGIC := '1';
	signal MS_F_CH_STK_SEL_OP_CODE_STAR_1414_STAR: STD_LOGIC := '1';
	signal PS_F_CH_WRITE_LATCH_STAR_1414_STAR: STD_LOGIC := '0';
	signal MS_F_SET_MOVE_MODE_LATCH_STAR_1414_STAR: STD_LOGIC := '1';
	signal MC_1301_STROBE_F_CH: STD_LOGIC := '1';
	signal MC_SET_FCH_STROB_TR_E_FR_FEATS: STD_LOGIC := '1';
	signal TW_SET_FCH_STROB_TR_E_FR_FEATS: STD_LOGIC := '0';
	signal MC_1405_STROBE_F_CH: STD_LOGIC := '1';
	signal PS_GATE_SET_F1_REG_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_GATE_RESET_F2_FULL_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_RGEN_EXTN_CTRL_STAR_STERLING: STD_LOGIC := '0';
	signal PS_PULL_OFF_CMP_HI_STAR_1311_SCAN: STD_LOGIC := '0';
	signal PS_PULL_OFF_CMP_LO_STAR_1311_SCAN: STD_LOGIC := '0';
	signal PS_SIMULATE_CMP_HI_STAR_1311_SCAN: STD_LOGIC := '0';
	signal PS_SIMULATE_CMP_EQ_STAR_1311_SCAN: STD_LOGIC := '0';
	signal PS_SIMULATE_CMP_LO_STAR_1311_SCAN: STD_LOGIC := '0';
	signal PS_CMP_MODE_B_CYCLE_STAR_1311: STD_LOGIC := '0';
	signal M36_VOLTS_ON_CONSOLE: STD_LOGIC := '1';
	signal PS_INTERLOCK_F_CH_STAR_1414_STAR: STD_LOGIC := '0';
	signal MC_READER_BUSY: STD_LOGIC := '1';
	signal MC_READER_BUSY_JRJ: STD_LOGIC := '1';
	signal MC_PUNCH_BUSY: STD_LOGIC := '1';
	signal MC_PUNCH_BUSY_JRJ: STD_LOGIC := '1';
	signal MC_PAPER_TAPE_READER_BUSY: STD_LOGIC := '1';
	signal MC_PAPER_TAPE_READY_BUSY_JRJ: STD_LOGIC := '1';
	signal MC_I_O_CLOCK_080_090_TIME: STD_LOGIC := '1';
	signal MC_I_O_CLOCK_080_090_TIME_JRJ: STD_LOGIC := '1';
	signal PS_INTERRUPT_REQUEST_STAR_SIF: STD_LOGIC := '0';
	signal PS_INTERRUPT_REQUEST_JRJ: STD_LOGIC := '0';
	signal PS_INTERRUPT_REQUEST_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_I_OP_DOT_I_CYCLE_DOT_E_STAR_AUTS_STAR: STD_LOGIC := '0';
	signal MC_ANY_SEEK_COMP_STAR_E_CH_1405: STD_LOGIC := '1';
	signal MC_ANY_SEEK_COMP_STAR_E_CH_1301: STD_LOGIC := '1';
	signal MC_ANY_SEEK_COMP_STAR_F_CH_1301: STD_LOGIC := '1';
	signal MC_ANY_SEEK_COMP_STAR_F_CH_1405: STD_LOGIC := '1';
	signal PS_2ND_CND_A_BRANCH_STAR_SIF: STD_LOGIC := '0';
	signal PS_2ND_CND_A_BRANCH_STAR_SIF_JRJ: STD_LOGIC := '0';
	signal PS_2ND_CND_A_BRANCH_STAR_1414_STAR: STD_LOGIC := '0';
	signal PS_NO_BRANCH_CND_INTER_STAR_SIF: STD_LOGIC := '0';
	signal PS_NO_BRANCH_CND_INTER_STAR_SIF_JRJ: STD_LOGIC := '0';
	signal PS_NO_BRANCH_CND_INTER_STAR_1414_STAR: STD_LOGIC := '0';
	signal M6_V: STD_LOGIC := '1';
	signal MY_CHAR_SEL_ERROR_CHK_1_STAR_2_STAR: STD_LOGIC := '1';
	signal MY_CHAR_SEL_ERROR_CHK_2_STAR_2_STAR: STD_LOGIC := '1';
	signal CONS_36V: STD_LOGIC := '0';
	signal MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO: STD_LOGIC := '1';
	signal PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC: STD_LOGIC := '0';
	signal MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_C2_CAM_NC: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_C2_CAM_NO: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_SPACE_NO: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_C1_CAM_NO: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_C1_CAM_NC: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_C3_OR_C4_NO: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO: STD_LOGIC := '1';
	signal MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO: STD_LOGIC := '1';
	signal MB_CONS_PRINTER_EVEN_BIT_CHECK: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_ODD_BIT_CHECK: STD_LOGIC := '1';
	signal MV_CONS_PRINTER_LAST_COLUMN_SET: STD_LOGIC := '1';
	signal MV_KEYBOARD_LOCK_MODE_STAR_NO: STD_LOGIC := '1';
	signal MV_KEYBOARD_UNLOCK_MODE: STD_LOGIC := '1';
	signal PS_E1_INPUT_STAR_SIF_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_E1_INPUT_STAR_1412_19_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal MC_E_CH_TAU_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal MC_I_O_SYNC_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal MC_E_CH_1301_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal MC_E_CH_1405_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal MV_CONS_PRTR_TO_CPU_BUS: STD_LOGIC_VECTOR (5 downTo 0) := "111111";
	signal PS_F1_INPUT_STAR_SIF_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_F1_INPUT_STAR_1414_STAR_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_F1_INPUT_STAR_1412_19_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal MC_F_CH_1301_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal MC_F_CH_1405_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal MC_F_CH_TAU_TO_CPU_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "11111111";
	signal PV_SENSE_CHAR_0_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_0_B2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_0_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_0_D2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_1_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_1_B2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_1_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_1_D2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_2_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_2_B2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_2_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_2_D2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_3_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_3_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_3_D2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PV_SENSE_CHAR_3_B2_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_B_DATA_REG_STAR_0_STAR_Z_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_B_DATA_REG_STAR_1_STAR_Z_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_B_DATA_REG_STAR_2_STAR_Z_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal PS_B_DATA_REG_STAR_3_STAR_Z_BUS: STD_LOGIC_VECTOR (7 downTo 0) := "00000000";
	signal SWITCH_ROT_STOR_SCAN_DK6: STD_LOGIC_VECTOR(5 downTo 0) := "000000";
	signal SWITCH_MOM_CONS_START: STD_LOGIC := '0';
	signal SWITCH_MOM_CE_START: STD_LOGIC := '0';
	signal SWITCH_MOM_CONS_STOP_PL1: STD_LOGIC := '0';
	signal SWITCH_MOM_CE_STOP_SW_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_I_O_CHK_ST_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_ADDR_STOP_PL1: STD_LOGIC := '0';
	signal SWITCH_REL_PWR_ON_RST: STD_LOGIC := '1';
	signal SWITCH_MOM_CO_CPR_RST: STD_LOGIC := '0';
	signal SWITCH_MOM_CE_CPR_RST: STD_LOGIC := '0';
	signal SWITCH_MOM_PROG_RESET: STD_LOGIC := '0';
	signal SWITCH_TOG_1401_MODE_PL1: STD_LOGIC := '0';
	signal SWITCH_ROT_CHECK_CTRL_DK2: STD_LOGIC_VECTOR(5 downTo 0) := "000000";
	signal SWITCH_MOM_IO_CHK_RST_PL1: STD_LOGIC := '0';
	signal SWITCH_ROT_M_RTC_023_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_M_RTC_578_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_MRTC_01234_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_MRTC_56789_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_HRTC_01234_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_HRTC_56789_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_HRTC_012_CC: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_REL_RTC_BUSY: STD_LOGIC := '0';
	signal SWITCH_ROT_TENS_SYNC_DK2: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_TENS_SYNC_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_UNITS_SYNC_DK2: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_UNITS_SYNC_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_SCAN_GATE_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_THOUS_SYNC_DK2: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_THOUS_SYNC_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_HUNDS_SYNC_DK2: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_HUNDS_SYNC_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_ADDR_ENTRY_DK3: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_ADDR_SEL_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_MOM_ADDR_DISP: STD_LOGIC := '0';
	signal SWITCH_ROT_STOR_SCAN_DK5: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_TOG_ASTERISK_PL2: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_1_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_2_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_4_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_8_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_A_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_B_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_C_PL1: STD_LOGIC := '0';
	signal SWITCH_TOG_SENSE_SW_W_PL1: STD_LOGIC := '0';
	signal SWITCH_MOM_1ST_TST_SW_PL1: STD_LOGIC := '0';
	signal SWITCH_MOM_2ND_TST_SW_PL1: STD_LOGIC := '0';
	signal SWITCH_MOM_3RD_TST_SW_PL1: STD_LOGIC := '0';
	signal SWITCH_ALT_PRIORITY_PL1: STD_LOGIC := '0';
	signal SWITCH_ALT_PRIORITY_PL2: STD_LOGIC := '0';
	signal SWITCH_ROT_I_O_UNIT_DK1: STD_LOGIC_VECTOR(5 downTo 0) := "000000";
	signal SWITCH_ROT_MODE_SW_DK: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_MODE_SW_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_TOG_CH_1: STD_LOGIC := '0';
	signal SWITCH_TOG_CH_2: STD_LOGIC := '0';
	signal SWITCH_TOG_AUTO_START_PL1: STD_LOGIC := '0';
	signal SWITCH_ROT_ADDR_ENTRY_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_TOG_WR_INHIBIT_PL1: STD_LOGIC := '0';
	signal SWITCH_ROT_STOR_SCAN_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_CYCLE_CTRL_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_ADDR_ENTRY_DKA: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_CHECK_CTRL_DK1: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_TOG_INHIBIT_PO_PL1: STD_LOGIC := '0';
	signal SWITCH_ROT_STOR_SCAN_DK4: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_TOG_ASTERISK_PL1: STD_LOGIC := '0';
	signal SWITCH_ROT_STOR_SCAN_DK3: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_ROT_ADDR_ENTRY_DK2: STD_LOGIC_VECTOR(12 downTo 0) := "0000000000000";
	signal SWITCH_TOG_INHIBIT_PO_PL2: STD_LOGIC := '0';
	signal SWITCH_MOM_STARTPRINT: STD_LOGIC := '0';
	signal SWITCH_ROT_CYCLE_CTRL_DK2: STD_LOGIC_VECTOR(5 downTo 0) := "000000";

	-- Outputs

	signal PS_1ST_CLOCK_PULSE_1: STD_LOGIC;
	signal PS_CLOCK_STOPPED_STAR_AUTS_STAR: STD_LOGIC;
	signal PS_CLOCK_STOPPED: STD_LOGIC;
	signal MS_CLOCK_STOPPED: STD_LOGIC;
	signal MS_LOGIC_GATE_B_1: STD_LOGIC;
	signal PS_LOGIC_GATE_C_1: STD_LOGIC;
	signal MS_LOGIC_GATE_D_1: STD_LOGIC;
	signal PS_LOGIC_GATE_D_1: STD_LOGIC;
	signal PS_LOGIC_GATE_E_1: STD_LOGIC;
	signal PS_LOGIC_GATE_B_OR_C: STD_LOGIC;
	signal PS_LOGIC_GATE_D_OR_E_OR_F: STD_LOGIC;
	signal PS_LOGIC_GATE_EARLY_B: STD_LOGIC;
	signal PS_LOGIC_GATE_EARLY_B_OR_S: STD_LOGIC;
	signal PS_I_CYCLE_1: STD_LOGIC;
	signal PS_I_CYCLE_DOT_NOT_CR_DISABLE: STD_LOGIC;
	signal MS_F_CYCLE_DOT_ANY_LAST_GATE: STD_LOGIC;
	signal PS_E_CYCLE_CTRL: STD_LOGIC;
	signal PS_E_CYCLE: STD_LOGIC;
	signal PS_E_CYCLE_CTRL_STAR_1311: STD_LOGIC;
	signal PS_F_CYCLE_CTRL: STD_LOGIC;
	signal PS_F_CYCLE: STD_LOGIC;
	signal PS_LAST_INSN_RO_CYCLE_2: STD_LOGIC;
	signal MS_START_KEY: STD_LOGIC;
	signal PS_RUN_OR_IE_MODE_STAR_AUTS_STAR: STD_LOGIC;
	signal PS_BRANCH_TO_A_CONDITIONS: STD_LOGIC;
	signal PS_E_CH_READY_BUS: STD_LOGIC;
	signal MS_E_CH_NOT_READY: STD_LOGIC;
	signal MS_COMPUTER_RESET_1: STD_LOGIC;
	signal MS_COMPUTER_RESET_2: STD_LOGIC;
	signal MC_COMP_RESET_TO_TAPE_STAR_E_CH: STD_LOGIC;
	signal MC_E_CH_COMP_RESET_TO_1301: STD_LOGIC;
	signal MC_E_CH_COMP_RESET_TO_1405: STD_LOGIC;
	signal MC_COMP_RESET_TO_TAPE_STAR_F_CH: STD_LOGIC;
	signal MC_F_CH_COMP_RESET_TO_1301: STD_LOGIC;
	signal MC_F_CH_COMP_RESET_TO_1405: STD_LOGIC;
	signal MC_COMP_RESET_TO_BUFFER: STD_LOGIC;
	signal MS_PROGRAM_RESET_6: STD_LOGIC;
	signal MS_PROGRAM_RESET_2: STD_LOGIC;
	signal PS_1401_MODE: STD_LOGIC;
	signal MS_1401_MODE: STD_LOGIC;
	signal MC_1401_MODE_TO_1405: STD_LOGIC;
	signal PS_OP_REG_ARS_C_BIT: STD_LOGIC;
	signal PS_OP_REG_ARS_NOT_C_BIT: STD_LOGIC;
	signal PS_OP_DCDR_NOT_B_DOT_NOT_A_DOT_NOT_8_B: STD_LOGIC;
	signal PS_OP_DCDR_B_DOT_A_DOT_8_B: STD_LOGIC;
	signal PS_OP_DCDR_B_DOT_NOT_A_DOT_NOT_8_B: STD_LOGIC;
	signal PS_OP_DCDR_B_DOT_NOT_A_DOT_8_B: STD_LOGIC;
	signal PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_NOT_1_B: STD_LOGIC;
	signal PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_1_B: STD_LOGIC;
	signal PS_OP_DCDR_NOT_4_DOT_2_DOT_NOT_1_B: STD_LOGIC;
	signal PS_OP_DCDR_4_DOT_2_DOT_NOT_1_B: STD_LOGIC;
	signal PS_OP_DCDR_4_DOT_NOT_2_DOT_NOT_1_B: STD_LOGIC;
	signal PS_OP_DCDR_4_DOT_2_DOT_1_B: STD_LOGIC;
	signal PS_NOT_B_DOT_NOT_A_DOT_8_OP_MOD: STD_LOGIC;
	signal PS_NOT_B_DOT_NOT_A_DOT_NOT_8_OP_MOD: STD_LOGIC;
	signal PS_NOT_4_DOT_NOT_2_DOT_NOT_1_OP_MOD: STD_LOGIC;
	signal PS_NOT_4_DOT_NOT_2_DOT_1_OP_MOD: STD_LOGIC;
	signal PS_NOT_4_DOT_2_DOT_1_OP_MOD: STD_LOGIC;
	signal PS_NOT_4_DOT_2_DOT_NOT_1_OP_MOD: STD_LOGIC;
	signal PS_4_DOT_2_DOT_NOT_1_OP_MOD: STD_LOGIC;
	signal PS_4_DOT_2_DOT_1_OP_MOD: STD_LOGIC;
	signal PS_4_DOT_NOT_2_DOT_1_OP_MOD: STD_LOGIC;
	signal PS_4_DOT_NOT_2_DOT_NOT_1_OP_MOD: STD_LOGIC;
	signal PS_S_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_B_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_E_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_F_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_LOZ_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_R_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_PERCENT_SIGN_OP_MODIFIER: STD_LOGIC;
	signal PS_A_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_RECORD_MARK_OP_MODIFIER: STD_LOGIC;
	signal PS_C_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_D_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_L_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_EXCLAM_MK_OP_MODIFIER: STD_LOGIC;
	signal PS_ONE_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_TWO_SYMBOL_OP_MODIFIER: STD_LOGIC;
	signal PS_ASTERISK_OP_MODIFIER: STD_LOGIC;
	signal MS_COND_TEST_BRANCH_OP_CODE: STD_LOGIC;
	signal MS_INTERRUPT_TEST_OP_CODE: STD_LOGIC;
	signal PS_M_OR_L_OP_CODES: STD_LOGIC;
	signal MC_CPU_READY_TO_TID: STD_LOGIC;
	signal PS_E_CH_DISCON_LATCH: STD_LOGIC;
	signal PS_E_CH_DISCON_LATCH_JRJ: STD_LOGIC;
	signal MC_E_CH_DISCON_TO_1301: STD_LOGIC;
	signal MC_E_CH_DISCON_TO_1405: STD_LOGIC;
	signal MS_E_CH_EXT_END_OF_TRANSFER: STD_LOGIC;
	signal PS_I_O_COML_AT_LATCH: STD_LOGIC;
	signal PS_LOZENGE_OR_ASTERISK: STD_LOGIC;
	signal PS_I_O_ASTERISK_LATCH: STD_LOGIC;
	signal MC_UNIT_1_SELECT_TO_I_O: STD_LOGIC;
	signal MC_UNIT_2_SELECT_TO_I_O: STD_LOGIC;
	signal MC_UNIT_4_SELECT_TO_I_O: STD_LOGIC;
	signal MC_UNIT_8_SEL_TO_I_O: STD_LOGIC;
	signal MC_SELECT_UNIT_P: STD_LOGIC;
	signal MC_SELECT_UNIT_D: STD_LOGIC;
	signal MS_E_CH_SELECT_UNIT_K: STD_LOGIC;
	signal MC_SELECT_UNIT_Q: STD_LOGIC;
	signal MC_E_CH_SELECT_UNIT_R: STD_LOGIC;
	signal MC_SELECT_UNIT_L: STD_LOGIC;
	signal MC_E_CH_SELECT_UNIT_M: STD_LOGIC;
	signal MC_SELECT_UNIT_N: STD_LOGIC;
	signal PS_E_CH_SELECT_UNIT_F: STD_LOGIC;
	signal MC_ODD_PARITY_TO_TAPE_STAR_E_CH: STD_LOGIC;
	signal MC_UNIT_SEL_F_STAR_E_CH_1301: STD_LOGIC;
	signal MC_UNIT_SEL_F_STAR_E_CH_1405: STD_LOGIC;
	signal PS_E_CH_UNOVLP_IN_PROCESS: STD_LOGIC;
	signal PS_E_CH_IN_PROCESS: STD_LOGIC;
	signal MS_LOAD_CYCLE: STD_LOGIC;
	signal PS_E_CH_INT_END_OF_TRANSFER: STD_LOGIC;
	signal MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_E_CH: STD_LOGIC;
	signal MS_F_CH_RESET: STD_LOGIC;
	signal MS_F_CH_RESET_1: STD_LOGIC;
	signal PS_F_CH_U_SEL_A_DOT_NOT_8_DOT_NOT_1: STD_LOGIC;
	signal MC_ODD_PARITY_TO_TAPE_STAR_F_CH: STD_LOGIC;
	signal PS_F_CH_SELECT_UNIT_F_LN_2: STD_LOGIC;
	signal MC_UNIT_SEL_F_F_CH_1301: STD_LOGIC;
	signal MC_UNIT_SELECT_F_STAR_F_CH_1405: STD_LOGIC;
	signal PS_F_CH_UNOVLP_IN_PROCESS: STD_LOGIC;
	signal PS_F_CH_IN_PROCESS: STD_LOGIC;
	signal PS_E_CH_STATUS_SAMPLE_B: STD_LOGIC;
	signal MS_E_CH_STATUS_SAMPLE_B_DELAY: STD_LOGIC;
	signal PS_E_CH_SECOND_SAMPLE_B: STD_LOGIC;
	signal MS_E_CH_STATUS_SAMPLE_B: STD_LOGIC;
	signal PS_E_CH_STATUS_SAMPLE_B_DELAY: STD_LOGIC;
	signal PS_E_CH_STATUS_SAMPLE_A: STD_LOGIC;
	signal PS_E_CH_STATUS_SAMPLE_A_DELAY: STD_LOGIC;
	signal PS_F_CH_CONDITION: STD_LOGIC;
	signal MS_F_CH_CHECK: STD_LOGIC;
	signal MS_F_CH_END_OF_RECORD_LATCH: STD_LOGIC;
	signal PS_F_CH_INT_END_OF_TRANSFER: STD_LOGIC;
	signal PS_F_CH_READY_BUS: STD_LOGIC;
	signal MS_F_CH_NOT_READY: STD_LOGIC;
	signal MS_F_CH_BUSY: STD_LOGIC;
	signal MS_F_CH_WRONG_LENGTH_RECORD: STD_LOGIC;
	signal MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_F_CH: STD_LOGIC;
	signal MC_READ_TAPE_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_WRITE_TAPE_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_WRITE_TAPE_MK_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_ERASE_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_REWIND_UNLOAD_STAR_F_CH: STD_LOGIC;
	signal MC_REWIND_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_BACKSPACE_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_DISCONNECT_CALL_STAR_F_CH: STD_LOGIC;
	signal MC_TURN_OFF_TI_STAR_F_CH: STD_LOGIC;
	signal MC_RESET_TAPE_SEL_REG_STAR_CH_F: STD_LOGIC;
	signal MC_SET_TAPE_SEL_REG_STAR_CH_F: STD_LOGIC;
	signal PS_F_CH_STATUS_SAMPLE_A_DELAY: STD_LOGIC;
	signal PS_F_CH_STATUS_SAMPLE_A: STD_LOGIC;
	signal PS_F_CH_STATUS_SAMPLE_B: STD_LOGIC;
	signal PS_F_CH_SECOND_SAMPLE_B: STD_LOGIC;
	signal PS_F_CH_STATUS_SAMPLE_B_1: STD_LOGIC;
	signal MS_F_CH_INT_END_OF_XFER_DELAYED: STD_LOGIC;
	signal PS_F_CH_STATUS_SAMPLE_B_DELAY: STD_LOGIC;
	signal PS_F_CH_DISCON_LATCH: STD_LOGIC;
	signal MC_F_CH_DISCON_TO_1301: STD_LOGIC;
	signal MC_F_CH_DISCON_TO_1405: STD_LOGIC;
	signal MS_F_CH_EXT_END_OF_TRANSFER: STD_LOGIC;
	signal MS_1401_I_O_END: STD_LOGIC;
	signal MC_CORRECT_TRANS_TO_BUFFER: STD_LOGIC;
	signal MC_RESET_SELECT_BUFFER_LATCHES: STD_LOGIC;
	signal MC_READY_TO_BUFFER: STD_LOGIC;
	signal MC_1401_MODE_TO_BUFFER: STD_LOGIC;
	signal MC_STACK_SELECT_TO_BUFFER: STD_LOGIC;
	signal MC_FORMS_CTRL_TO_BUFFER: STD_LOGIC;
	signal MC_FORMS_STACKER_GO: STD_LOGIC;
	signal MC_TURN_OFF_TAPE_IND_STAR_E_CH: STD_LOGIC;
	signal MC_RESET_TAPE_SEL_REG_STAR_E_CH: STD_LOGIC;
	signal MC_SET_TAPE_SEL_REG_STAR_E_CH: STD_LOGIC;
	signal MC_DISCONNECT_CALL_STAR_E_CH: STD_LOGIC;
	signal MC_READ_TAPE_CALL_STAR_E_CH: STD_LOGIC;
	signal MC_WRITE_TAPE_CALL_STAR_E_CH: STD_LOGIC;
	signal MC_WRITE_TAPE_MK_CALL_STAR_E_CH: STD_LOGIC;
	signal MC_ERASE_CALL_STAR_E_CH: STD_LOGIC;
	signal MC_REWIND_UNLOAD_STAR_E_CH: STD_LOGIC;
	signal MC_REWIND_CALL_STAR_E_CH: STD_LOGIC;
	signal MC_BACKSPACE_CALL_STAR_E_CH: STD_LOGIC;
	signal PS_E_CH_2ND_ADDR_TRF: STD_LOGIC;
	signal MS_E_CH_END_OF_2ND_ADDR_TRF: STD_LOGIC;
	signal MC_1405_START_GATE_STAR_E_CH: STD_LOGIC;
	signal MC_1301_START_GATE_STAR_E_CH: STD_LOGIC;
	signal MC_SEEK_TEST_OP_STAR_E_CH_TO_1405: STD_LOGIC;
	signal MC_SEEK_TEST_OP_STAR_E_CH_TO_1301: STD_LOGIC;
	signal MC_FILE_STROBE_1ST_ADDR_STAR_E_CH: STD_LOGIC;
	signal MC_FILE_STROBE_2ND_ADDR_STAR_E_CH: STD_LOGIC;
	signal MC_FILE_DIGIT_ADVANCE_STAR_E_CH: STD_LOGIC;
	signal MC_FILE_ADDR_TRF_GATE_STAR_E_CH: STD_LOGIC;
	signal MC_E_CH_RBCI_RESET_1405: STD_LOGIC;
	signal PS_E_CH_NO_STATUS_ON: STD_LOGIC;
	signal PS_F_CH_2ND_ADDR_TRF: STD_LOGIC;
	signal PS_F_CH_END_OF_2ND_ADDR_TRF: STD_LOGIC;
	signal MC_1301_START_GATE_STAR_F_CH: STD_LOGIC;
	signal MC_1405_START_GATE_STAR_F_CH: STD_LOGIC;
	signal MC_SEEK_TEST_OP_STAR_F_CH_TO_1405: STD_LOGIC;
	signal MC_FILE_STROBE_1ST_ADDR_STAR_F_CH: STD_LOGIC;
	signal MC_FILE_STROBE_2ND_ADDR_STAR_F_CH: STD_LOGIC;
	signal MC_FILE_DIGIT_ADVANCE_STAR_F_CH: STD_LOGIC;
	signal MC_FILE_ADDR_TRF_GATE_STAR_F_CH: STD_LOGIC;
	signal MC_SEEK_TEST_OP_STAR_F_CH_TO_1301: STD_LOGIC;
	signal MC_F_CH_RBCI_RESET_1405: STD_LOGIC;
	signal PS_F_CH_NO_TRANSFER_LATCH: STD_LOGIC;
	signal PS_F_CH_NO_STATUS_ON: STD_LOGIC;
	signal MS_F_CH_NO_TRANSFER_LATCH: STD_LOGIC;
	signal MY_MEM_AR_NOT_TTHP4B: STD_LOGIC;
	signal PS_ADDRESS_STOP: STD_LOGIC;
	signal PS_OPTIONAL_SYNC_COND_CE: STD_LOGIC;
	signal MC_UNIT_NU_0_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_SELECT_NO_0_TO_BUFFER: STD_LOGIC;
	signal MC_SEEK_STAR_E_CH_1405: STD_LOGIC;
	signal MC_UNIT_NU_1_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MS_E_CH_UNIT_NUMBER_1: STD_LOGIC;
	signal MC_SELECT_NO_1_TO_BUFFER: STD_LOGIC;
	signal MC_SINGLE_REC_STAR_E_CH_TO_1405: STD_LOGIC;
	signal MC_UNIT_NU_2_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_SELECT_NO_2_TO_BUFFER: STD_LOGIC;
	signal MC_FULL_TRACK_WITHOUT_IA_STAR_1405_E_CH: STD_LOGIC;
	signal MC_UNIT_NU_3_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_SELECT_NO_3_TO_BUFFER: STD_LOGIC;
	signal MC_WRITE_CHECK_STAR_E_CH_TO_1405: STD_LOGIC;
	signal MC_UNIT_NU_4_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_WRITE_ADDR_STAR_E_CH_TO_1405: STD_LOGIC;
	signal MC_UNIT_NU_5_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_UNIT_NU_6_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_UNIT_NU_7_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_UNIT_NU_8_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MC_UNIT_NU_9_TO_TAU_STAR_E_CH: STD_LOGIC;
	signal MS_F_CH_UNIT_NUMBER_0: STD_LOGIC;
	signal MC_UNIT_NU_0_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal PS_F_CH_UNIT_NUMBER_0: STD_LOGIC;
	signal MC_SEEK_STAR_F_CH_1405: STD_LOGIC;
	signal MC_UNIT_NU_1_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MS_F_CH_UNIT_NUMBER_1: STD_LOGIC;
	signal PS_F_CH_UNIT_NUMBER_1: STD_LOGIC;
	signal MC_SINGLE_REC_STAR_F_CH_TO_1405: STD_LOGIC;
	signal MC_UNIT_NU_2_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MS_F_CH_UNIT_NUMBER_2: STD_LOGIC;
	signal MC_FULL_TRACK_WITHOUT_IA_STAR_1405_F_CH: STD_LOGIC;
	signal MS_F_CH_UNIT_NUMBER_3: STD_LOGIC;
	signal MC_UNIT_NU_3_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MC_WRITE_CHECK_STAR_F_CH_TO_1405: STD_LOGIC;
	signal MC_UNIT_NU_4_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MC_WRITE_ADDR_STAR_F_CH_TO_1405: STD_LOGIC;
	signal MC_UNIT_NU_5_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MC_UNIT_NU_6_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MC_UNIT_NU_7_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MC_UNIT_NU_8_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal MC_UNIT_NU_9_TO_TAU_STAR_F_CH: STD_LOGIC;
	signal PS_E_CH_OUTPUT_MODE: STD_LOGIC;
	signal PS_E_CH_INPUT_MODE: STD_LOGIC;
	signal MC_OUTPUT_MODE_TO_BUFFER: STD_LOGIC;
	signal MC_INPUT_MODE_TO_BUFFER: STD_LOGIC;
	signal MC_OUTPUT_OP_TO_1301_STAR_E_CH: STD_LOGIC;
	signal MC_OUTPUT_OP_TO_1405_STAR_E_CH: STD_LOGIC;
	signal MC_INPUT_OP_TO_1405_STAR_E_CH: STD_LOGIC;
	signal MC_INPUT_OP_TO_1301_STAR_E_CH: STD_LOGIC;
	signal MS_E_CH_MOVE_MODE: STD_LOGIC;
	signal MS_E_CH_LOAD_MODE: STD_LOGIC;
	signal MS_E_CH_INTERLOCK: STD_LOGIC;
	signal MC_LOAD_MODE_TO_1301_STAR_E_CH: STD_LOGIC;
	signal MC_LOAD_MODE_TO_1405_STAR_E_CH: STD_LOGIC;
	signal PS_SET_E2_REG: STD_LOGIC;
	signal PS_SET_E1_REG: STD_LOGIC;
	signal PS_F_CH_OUTPUT_MODE: STD_LOGIC;
	signal PS_F_CH_INPUT_MODE: STD_LOGIC;
	signal MS_INPUT_MODE_F_CH: STD_LOGIC;
	signal MC_INPUT_OP_TO_1405_STAR_F_CH: STD_LOGIC;
	signal MC_INPUT_OP_TO_1301_STAR_F_CH: STD_LOGIC;
	signal MS_F_CH_INPUT_MODE: STD_LOGIC;
	signal MC_OUTPUT_OP_TO_1405_STAR_F_CH: STD_LOGIC;
	signal MC_OUTPUT_OP_TO_1301_STAR_F_CH: STD_LOGIC;
	signal MS_F_CH_LOAD_MODE: STD_LOGIC;
	signal PS_F_CH_INTERLOCK: STD_LOGIC;
	signal MC_LOAD_MODE_TO_1301_STAR_F_CH: STD_LOGIC;
	signal MC_LOAD_MODE_TO_1405_STAR_F_CH: STD_LOGIC;
	signal PS_SET_F1_REG: STD_LOGIC;
	signal PS_SET_F2_REG: STD_LOGIC;
	signal TW_CPU_TO_F_CH_TAU_C_BIT: STD_LOGIC;
	signal MS_MASTER_ERROR: STD_LOGIC;
	signal MS_MASTER_ERROR_STAR_AUTS_STAR: STD_LOGIC;
	signal PS_MASTER_ERROR: STD_LOGIC;
	signal PS_INTERRUPT_REQ_STAR_AUTS_STAR: STD_LOGIC;
	signal PS_Y_OP_DOT_TEST_RESET: STD_LOGIC;
	signal PS_INTERRUPT_TEST_OP_CODE: STD_LOGIC;
	signal MS_I_OP_DOT_I_CYCLE_DOT_C: STD_LOGIC;
	signal PS_I_OP_DOT_I_CYCLE_DOT_E: STD_LOGIC;
	signal MY_MEM_AR_NOT_TP0B_JRJ: STD_LOGIC;
	signal MY_MEM_AR_NOT_TP1B_JRJ: STD_LOGIC;
	signal MY_MEM_AR_NOT_TP2B_JRJ: STD_LOGIC;
	signal MY_MEM_AR_NOT_TP8B_JRJ: STD_LOGIC;
	signal MY_MEM_AR_NOT_TP4B_JRJ: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY00_09_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY00_09_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY10_19_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY10_19_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY20_29_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY20_29_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY30_39_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY30_39_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY40_49_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY40_49_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY50_59_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY50_59_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY60_60_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY60_69_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY70_79_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY70_79_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY80_89_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY80_89_B: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY90_99_A: STD_LOGIC;
	signal MV_GATE_X_LSMS_YY90_99_B: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP8B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP4B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP2B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP1B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP0B_Z: STD_LOGIC;
	signal MY_GATE_Y_LSMS_00_09XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_00_09XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_10_19XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_10_19XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_20_29XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_20_29XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_30_39XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_30_39XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_40_49XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_40_49XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_50_59XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_50_59XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_60_69XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_60_69XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_70_79XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_70_79XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_80_89XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_80_89XX_B: STD_LOGIC;
	signal MY_GATE_Y_LSMS_90_99XX_A: STD_LOGIC;
	signal MY_GATE_Y_LSMS_90_99XX_B: STD_LOGIC;
	signal MY_X_RD_1: STD_LOGIC;
	signal MY_B_DATA_REG_RESET: STD_LOGIC;
	signal PY_START_READ: STD_LOGIC;
	signal MY_X_WR_1: STD_LOGIC;
	signal PY_START_WRITE: STD_LOGIC;
	signal MY_LOAD_MEMORY_Z: STD_LOGIC;
	signal MY_REGEN_MEMORY_Z: STD_LOGIC;
	signal PY_1ST_CHECK_TEST_Z: STD_LOGIC;
	signal PY_2ND_CHECK_TEST_Z: STD_LOGIC;
	signal PY_COMPUTER_RESET: STD_LOGIC;
	signal PS_DENSITY_SW_556_OR_200_CH_1: STD_LOGIC;
	signal PS_DENSITY_SW_800_OR_556_CH_1: STD_LOGIC;
	signal PS_DENSITY_SW_556_OR_200_CH_2: STD_LOGIC;
	signal PS_DENSITY_SW_800_OR_556_CH_2: STD_LOGIC;
	signal MC_DISK_WRITE_NORMAL_STAR_F_CH: STD_LOGIC;
	signal MC_DISK_WRITE_NORMAL_STAR_E_CH: STD_LOGIC;
	signal MS_CONSOLE_INHIBIT_AR_RO: STD_LOGIC;
	signal PS_LOGIC_STEP_OR_IE_OR_STG_CY_STAR_AUTS_STAR: STD_LOGIC;
	signal PS_CONS_CLOCK_1_POS: STD_LOGIC;
	signal PS_CONS_CLOCK_3_POS_1: STD_LOGIC;
	signal MS_CONSOLE_CHECK_STROBE: STD_LOGIC;
	signal PW_UPPER_CASE_SHIFT_SOLENOID: STD_LOGIC;
	signal PW_LOWER_CASE_SHIFT_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_R1_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_R2A_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_R2_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_R5_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_T1_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_T2_SOLENOID: STD_LOGIC;
	signal PW_CONS_PRINTER_CHK_SOLENOID: STD_LOGIC;
	signal PW_BACKSPACE_SOLENOID: STD_LOGIC;
	signal PW_CARRIAGE_RETURN_SOLENOID: STD_LOGIC;
	signal PW_SPACE_SOLENOID: STD_LOGIC;
	signal MW_KEYBOARD_LOCK_SOLENOID: STD_LOGIC;
	signal LAMP_15A1K24: STD_LOGIC;
	signal LAMP_15A1A16: STD_LOGIC;
	signal LAMP_15A1C16: STD_LOGIC;
	signal LAMP_15A1E16: STD_LOGIC;
	signal LAMP_15A1F16: STD_LOGIC;
	signal LAMP_15A1K23: STD_LOGIC;
	signal LAMP_15A1H14: STD_LOGIC;
	signal LAMP_15A1K14: STD_LOGIC;
	signal LAMP_15A1H16: STD_LOGIC;
	signal LAMP_15A1K15: STD_LOGIC;
	signal LAMP_15A1H15: STD_LOGIC;
	signal LAMP_15A1E17: STD_LOGIC;
	signal LAMP_15A1F17: STD_LOGIC;
	signal LAMP_15A1A17: STD_LOGIC;
	signal LAMP_15A1C17: STD_LOGIC;
	signal LAMP_15A1H17: STD_LOGIC;
	signal LAMP_15A1B14: STD_LOGIC;
	signal LAMP_15A1K16: STD_LOGIC;
	signal LAMP_15A1C15: STD_LOGIC;
	signal LAMP_15A1K17: STD_LOGIC;
	signal LAMP_15A1E21: STD_LOGIC;
	signal LAMP_11C8K07: STD_LOGIC;
	signal LAMP_11C8J07: STD_LOGIC;
	signal LAMP_11C8H07: STD_LOGIC;
	signal LAMP_11C8G07: STD_LOGIC;
	signal LAMP_11C8F07: STD_LOGIC;
	signal LAMP_11C8A02: STD_LOGIC;
	signal LAMP_11C8B02: STD_LOGIC;
	signal LAMP_11C8A01: STD_LOGIC;
	signal LAMP_11C8B01: STD_LOGIC;
	signal LAMP_15A1K20: STD_LOGIC;
	signal LAMP_11C8C14: STD_LOGIC;
	signal LAMP_11C8D14: STD_LOGIC;
	signal LAMP_11C8E14: STD_LOGIC;
	signal LAMP_11C8F14: STD_LOGIC;
	signal LAMP_15A1E14: STD_LOGIC;
	signal LAMP_15A1F14: STD_LOGIC;
	signal LAMP_15A1A14: STD_LOGIC;
	signal LAMP_15A1E15: STD_LOGIC;
	signal LAMP_15A1F15: STD_LOGIC;
	signal LAMP_15A1A15: STD_LOGIC;
	signal LAMP_15A1C11: STD_LOGIC;
	signal LAMP_15A1K12: STD_LOGIC;
	signal LAMP_15A1F11: STD_LOGIC;
	signal LAMP_15A1E11: STD_LOGIC;
	signal LAMP_15A1A11: STD_LOGIC;
	signal LAMP_15A1G08: STD_LOGIC;
	signal LAMP_15A1H08: STD_LOGIC;
	signal LAMP_15A1J08: STD_LOGIC;
	signal LAMP_15A1K08: STD_LOGIC;
	signal LAMP_15A1H12: STD_LOGIC;
	signal LAMP_15A1F12: STD_LOGIC;
	signal LAMP_15A1A12: STD_LOGIC;
	signal LAMP_15A1E12: STD_LOGIC;
	signal LAMP_15A1C12: STD_LOGIC;
	signal LAMP_11C8A12: STD_LOGIC;
	signal LAMP_15A1A19: STD_LOGIC;
	signal LAMP_11C8A13: STD_LOGIC;
	signal LAMP_15A1C19: STD_LOGIC;
	signal LAMP_15A1B19: STD_LOGIC;
	signal LAMP_11C8A10: STD_LOGIC;
	signal LAMP_15A1H20: STD_LOGIC;
	signal LAMP_15A1H19: STD_LOGIC;
	signal LAMP_15A1F19: STD_LOGIC;
	signal LAMP_11C8A07: STD_LOGIC;
	signal LAMP_15A1E20: STD_LOGIC;
	signal LAMP_15A1F20: STD_LOGIC;
	signal LAMP_15A1C20: STD_LOGIC;
	signal LAMP_15A1V01: STD_LOGIC;
	signal LAMP_15A1B15: STD_LOGIC;
	signal LAMP_15A1W01: STD_LOGIC;
	signal LAMP_15A1W04: STD_LOGIC;
	signal LAMP_15A2K03: STD_LOGIC;
	signal LAMP_15A2K05: STD_LOGIC;
	signal LAMP_15A1K22: STD_LOGIC;
	signal LAMP_15A1K21: STD_LOGIC;
	signal LAMP_11C8A04: STD_LOGIC;
	signal LAMP_11C8B05: STD_LOGIC;
	signal LAMP_11C8B04: STD_LOGIC;
	signal LAMP_11C8A05: STD_LOGIC;
	signal PS_I_RING_HDL_BUS: STD_LOGIC_VECTOR (12 downTo 0);
	signal PS_OP_MOD_REG_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_OP_MOD_REG_NOT_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MY_MEM_AR_NOT_UP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_UP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_NOT_TP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_TP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_NOT_HP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_HP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_NOT_THP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_THP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal MY_MEM_AR_TTHP_BUS: STD_LOGIC_VECTOR (4 downTo 0);
	signal PS_A_CH_NOT_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MY_ASSEMBLY_CH_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_E_CH_UNIT_STAR_1301_STAR_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_E_CH_U_SEL_REG_NOT_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_E_CH_U_SEL_REG_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_F_CH_UNIT_STAR_1301_STAR_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_F_CH_U_SEL_REG_NOT_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_F_CH_U_SEL_REG_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_E2_REG_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_E_CH_TAU_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_I_O_SYNC_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_E_CH_1301_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_E_CH_1405_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PS_F2_REG_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MS_F2_REG_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_F_CH_TAU_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_F_CH_1301_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MC_CPU_TO_F_CH_1405_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal PV_X_LSMS_DRV_IN_BUS: STD_LOGIC_VECTOR (15 downTo 0);
	signal PV_Y_LSMS_DRV_IN_BUS: STD_LOGIC_VECTOR (15 downTo 0);
	signal MV_INH_CHAR_0_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_0_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_1_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_1_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_2_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_2_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_3_D1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal MV_INH_CHAR_3_B1_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	
	signal IBM1410_DIRECT_MEMORY_ADDRESS:      STD_LOGIC_VECTOR(13 downto 0);
   signal IBM1410_DIRECT_MEMORY_ENABLE:       STD_LOGIC_VECTOR(3 downto 0);
   signal IBM1410_DIRECT_MEMORY_WRITE_ENABLE: STD_LOGIC_VECTOR(3 downto 0);
   signal IBM1410_DIRECT_MEMORY_WRITE_DATA:   STD_LOGIC_VECTOR(7 downto 0);
   signal IBM1410_DIRECT_MEMORY_READ_DATA_0:  STD_LOGIC_VECTOR(7 downto 0);
   signal IBM1410_DIRECT_MEMORY_READ_DATA_1:  STD_LOGIC_VECTOR(7 downto 0);
   signal IBM1410_DIRECT_MEMORY_READ_DATA_2:  STD_LOGIC_VECTOR(7 downto 0);
   signal IBM1410_DIRECT_MEMORY_READ_DATA_3:  STD_LOGIC_VECTOR(7 downto 0);

	
	signal MY_ASSEMBLY_CH_Z_BUS: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_LOGIC_GATE_RING: STD_LOGIC_VECTOR (10 downTo 1);
	signal LAMPS_IRING: STD_LOGIC_VECTOR (12 downTo 0);
	signal LAMPS_CYCLE_CE: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_CYCLE_CONSOLE: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_SCAN: STD_LOGIC_VECTOR (3 downTo 0);
	signal LAMPS_OPREG_CE: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_OPMOD_CE: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_MAR_UP: STD_LOGIC_VECTOR (4 downTo 0);
	signal LAMPS_MAR_TP: STD_LOGIC_VECTOR (4 downTo 0);
	signal LAMPS_MAR_HP: STD_LOGIC_VECTOR (4 downTo 0);
	signal LAMPS_MAR_THP: STD_LOGIC_VECTOR (4 downTo 0);
	signal LAMPS_MAR_TTHP: STD_LOGIC_VECTOR (4 downTo 0);
	signal LAMPS_ARING: STD_LOGIC_VECTOR (6 downTo 1);
	signal LAMPS_B_CH: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_A_CH: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_ASSM_CH_NOT: STD_LOGIC_VECTOR (7 downTo 0);
	signal LAMPS_ASSM_CH: STD_LOGIC_VECTOR (7 downTo 0);

-- Console Typewriter signals

    signal IBM1410_CONSOLE_XMT_CHAR: STD_LOGIC_VECTOR(7 downto 0);
    signal IBM1410_CONSOLE_XMT_STROBE: STD_LOGIC;
    
    signal IBM1410_CONSOLE_XMT_ASCII: character;  -- test bench only
    signal SLOW_TYPING: STD_LOGIC := '0';  -- Fast typing for etst bench.
    signal UART_RESET: STD_LOGIC := '0';

    signal IBM1410_CONSOLE_INPUT_FIFO_WRITE_DATA: STD_LOGIC_VECTOR(7 downto 0) := "00000000";
    signal IBM1410_CONSOLE_INPUT_FIFO_WRITE_ENABLE: STD_LOGIC := '0';

-- Tape Adapter Unit Signals

       -- TAU to PC Support System
       
   signal IBM1410_TAU_XMT_UART_DATA: STD_LOGIC_VECTOR(7 downto 0) := "00000000";
   signal IBM1410_TAU_XMT_UART_REQUEST: STD_LOGIC := '0';
   signal IBM1410_TAU_XMT_UART_GRANT: STD_LOGIC := '0';
   
   signal IBM1410_TAU_XMT_UART_DATA_F_CH: STD_LOGIC_VECTOR(7 downto 0) := "00000000";
   signal IBM1410_TAU_XMT_UART_REQUEST_F_CH: STD_LOGIC := '0';
   signal IBM1410_TAU_XMT_UART_GRANT_F_CH: STD_LOGIC := '0';   
              
       -- PC Support System to TAU 
       
   signal IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE: STD_LOGIC  := '0';
   signal IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH: STD_LOGIC  := '0';
   signal IBM1410_TAU_INPUT_FIFO_WRITE_DATA: STD_LOGIC_VECTOR(7 downto 0) := "00000000";   
   signal IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH: STD_LOGIC_VECTOR(7 downto 0) := "00000000";
   

    
-- START USER TEST BENCH DECLARATIONS

-- The user test bench declarations, if any, must be
-- placed AFTER the line starts with the first line of text 
-- with -- START USER TEST BENCH DECLARATIONS and ends
-- with the line containing -- END (and the rest of the line) below.
-- This text is preserved when the IBM1410SMS applciation
-- regenerates a test bench

   constant HDL_C_BIT: integer := 7;
   constant HDL_WM_BIT: integer := 6;
   constant HDL_B_BIT: integer := 5;
   constant HDL_A_BIT: integer := 4;
   constant HDL_8_BIT: integer := 3;
   constant HDL_4_BIT: integer := 2;
   constant HDL_2_BIT: integer := 1;
   constant HDL_1_BIT: integer := 0;

   constant MX_X1A_POS: integer := 7;
   constant MX_X6A_POS: integer := 8;
   
   signal LOCAL_MY_MEM_AR_NOT_TTHP_BUS: STD_LOGIC_VECTOR(4 downto 0);

   -- Must match IBM1410TapeAdapterUnit

   constant TAPE_UNIT_READ_READY_BIT:  integer := 0;
   constant TAPE_UNIT_WRITE_READY_BIT: integer := 1;
   constant TAPE_UNIT_LOAD_POINT_BIT:  integer := 2;
   constant TAPE_UNIT_TAPE_IND_BIT:    integer := 3;
   constant TAPE_UNIT_TAPE_REWIND_BIT: integer := 4;

   -- Test bench local data

   signal LOCAL_ODD_PARITY_MASK: STD_LOGIC_VECTOR(7 downto 0) := "00000000";
   signal LOCAL_WS_FLAG: STD_LOGIC := '0';
   signal LOCAL_WS_CHAR: STD_LOGIC_VECTOR(7 downto 0) := "00000000";
   constant WORD_SEPARATOR_CHAR: STD_LOGIC_VECTOR(7 downto 0) := X"1D"; 
   signal LOCAL_WS_TEST: STD_LOGIC := '0';  -- '1' if we are testing load mode
   signal LOCAL_F_CH_TEST: STD_LOGIC := '0'; -- '1' if we are testing 2nd channel
   signal LOCAL_i: integer := 64;  -- copy of loop  variable
   signal LOCAL_TAU_XMT_CHAR: STD_LOGIC_VECTOR(7 downto 0) := "00000000";

--procedure check1(
--    checked: in STD_LOGIC;
--    val: in STD_LOGIC;
--    testname: in string;
--    test: in string) is
--    begin    
--    assert checked = val report testname & " (" & test & ") failed." severity failure;
--    end procedure;
      


--   -- Your test bench declarations go here

   signal MS_COMPUTER_RESET: std_logic := '1';
   signal MS_PROGRAM_RESET: std_logic := '1';
   signal unlatchedConsoleParity: std_logic := '0';
   
   -- Tape test data - as it is sent/received from PC Support program,
   -- So check bit is bit 7, not bit 7.
   
   type testDataType is array(0 to 100) of STD_LOGIC_VECTOR(7 downto 0);
   type testWMType is array(0 to 100) of STD_LOGIC;
   
   signal tapeTestDataEven: testDataType := (
     -- 0 => X"0F",  (TM) 
     0 => X"50", 1 => X"41", 2 => X"42", 3=> X"03",  -- 50 is C+A === BLANK  
     4 => X"44", 5 => X"05", 6 => X"06", 7 => X"47", 
     8 => X"48", 9 => X"09", 10 => X"0a", 11 =>  X"4b", 
     12 => X"0c", 13 =>  X"4d", 14 => X"4e", 15 => X"0f", 
     16 => X"50", 17 => X"11", 18 => X"12", 19 => X"53",
     20 => X"22",
     others => X"50");
     
   -- Word Marks to use during load mode testing.     
     
   signal tapeTestDataWM: testWMType := (
     8 => '1', others => '0');
   

---- END USER TEST BENCH DECLARATIONS

	begin

	-- Instantiate the Unit Under Test (UUT)

	UUT: IntegrationTest3 port map(
		FPGA_CLK => FPGA_CLK,
		PP_SPECIAL_OR_12V_POWER_FOR_OSC => PP_SPECIAL_OR_12V_POWER_FOR_OSC,
		MV_36_VOLTS => MV_36_VOLTS,
		PS_INSTRUCTION_CHECK_GATE_STAR_1311 => PS_INSTRUCTION_CHECK_GATE_STAR_1311,
		MS_FORMS_STACK_GO_F_CH_STAR_1414_STAR => MS_FORMS_STACK_GO_F_CH_STAR_1414_STAR,
		PS_COMP_DISABLE_CYCLE_STAR_1412_19 => PS_COMP_DISABLE_CYCLE_STAR_1412_19,
		PS_START_AUTO_STARTMODE_STAR_AUTS_STAR => PS_START_AUTO_STARTMODE_STAR_AUTS_STAR,
		PS_RESET_STOP_KEY_LATCH_STAR_AUTS_STAR => PS_RESET_STOP_KEY_LATCH_STAR_AUTS_STAR,
		M36_VOLTS => M36_VOLTS,
		PS_BRANCH_TO_A_COND_STAR_1412_19 => PS_BRANCH_TO_A_COND_STAR_1412_19,
		PS_SET_NO_SCAN_CTRL_STAR_1412_19 => PS_SET_NO_SCAN_CTRL_STAR_1412_19,
		PS_SET_B_CYCLE_CTRL_STAR_1412_19 => PS_SET_B_CYCLE_CTRL_STAR_1412_19,
		PS_NO_BRANCH_COND_STAR_1412_19 => PS_NO_BRANCH_COND_STAR_1412_19,
		PS_LAST_EXECUTE_CYCLE_STAR_1412_19 => PS_LAST_EXECUTE_CYCLE_STAR_1412_19,
		MC_BUFFER_INQ_REQUEST => MC_BUFFER_INQ_REQUEST,
		MC_BUFFER_OUTQUIRY_PULSE => MC_BUFFER_OUTQUIRY_PULSE,
		PS_SPEC_BRANCH_LATCH_STAR_1414_STAR => PS_SPEC_BRANCH_LATCH_STAR_1414_STAR,
		MC_PRINTER_CHANNEL_9 => MC_PRINTER_CHANNEL_9,
		MC_PRINTER_CHANNEL_12 => MC_PRINTER_CHANNEL_12,
		MC_FORMS_BUSY_STATUS_TO_CPU => MC_FORMS_BUSY_STATUS_TO_CPU,
		MC_READ_COLUMN_BINARY => MC_READ_COLUMN_BINARY,
		MC_1301_READY_E_CH => MC_1301_READY_E_CH,
		MC_1405_READY_E_CH => MC_1405_READY_E_CH,
		MC_BUFFER_READY => MC_BUFFER_READY,
		PS_E_CH_READY_BUS_STAR_SIF => PS_E_CH_READY_BUS_STAR_SIF,
		PS_E_CH_READY_BUS_STAR_1412_19 => PS_E_CH_READY_BUS_STAR_1412_19,
		MC_TAPE_READY => MC_TAPE_READY,
		MC_TAPE_READY_F_CH_JRJ => MC_TAPE_READY_F_CH_JRJ,
		MC_BUFFER_READY_JRJ => MC_BUFFER_READY_JRJ,
		MC_SELECT_AND_REWIND_STAR_E_CH => MC_SELECT_AND_REWIND_STAR_E_CH,
		MC_1301_BUSY_E_CH => MC_1301_BUSY_E_CH,
		PS_E_CH_BUSY_BUS_STAR_1412_19 => PS_E_CH_BUSY_BUS_STAR_1412_19,
		MC_1405_BUSY_E_CH => MC_1405_BUSY_E_CH,
		MC_BUFFER_BUSY => MC_BUFFER_BUSY,
		MC_BUFFER_BUSY_JRJ => MC_BUFFER_BUSY_JRJ,
		MC_TAPE_BUSY => MC_TAPE_BUSY,
		MC_TAPE_BUSY_F_CH_JRJ => MC_TAPE_BUSY_F_CH_JRJ,
		MC_1301_ERROR_E_CH => MC_1301_ERROR_E_CH,
		MC_1405_ERROR_E_CH => MC_1405_ERROR_E_CH,
		MC_BUFFER_ERROR => MC_BUFFER_ERROR,
		MC_BUFFER_ERROR_JRJ => MC_BUFFER_ERROR_JRJ,
		PS_E_CH_CHECK_BUS_STAR_SIF => PS_E_CH_CHECK_BUS_STAR_SIF,
		PS_E_CH_CHECK_BUS_STAR_1412_19 => PS_E_CH_CHECK_BUS_STAR_1412_19,
		MC_TAPE_ERROR => MC_TAPE_ERROR,
		MC_TAPE_ERROR_F_CH_JRJ => MC_TAPE_ERROR_F_CH_JRJ,
		MC_1301_E_CH_CONDITION => MC_1301_E_CH_CONDITION,
		MC_1405_CONDITION_E_CH => MC_1405_CONDITION_E_CH,
		MC_BUFFER_CONDITION => MC_BUFFER_CONDITION,
		MC_BUFFER_CONDITION_JRJ => MC_BUFFER_CONDITION_JRJ,
		MC_SEL_OR_TAPE_IND_ON_CH_1 => MC_SEL_OR_TAPE_IND_ON_CH_1,
		MC_RBC_ERROR_1405_E_CH => MC_RBC_ERROR_1405_E_CH,
		PS_E_CH_COND_LATCH_STAR_SIF => PS_E_CH_COND_LATCH_STAR_SIF,
		MV_CONSOLE_PWR_SUPPLY_36_VOLTS => MV_CONSOLE_PWR_SUPPLY_36_VOLTS,
		PS_OP_MOD_SYM_IO_STATUS_STAR_1414_STAR => PS_OP_MOD_SYM_IO_STATUS_STAR_1414_STAR,
		PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF => PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF,
		PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF_JRJ => PS_R_OR_DOLL_SGN_OP_MOD_STAR_SIF_JRJ,
		PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF => PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF,
		PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF_JRJ => PS_W_OR_X_SYMBOL_OP_MOD_STAR_SIF_JRJ,
		MS_I_OR_O_OP_CODES_STAR_12_19 => MS_I_OR_O_OP_CODES_STAR_12_19,
		MS_E_CH_2_CHAR_OP_CODES_STAR_1414_STAR => MS_E_CH_2_CHAR_OP_CODES_STAR_1414_STAR,
		PS_P_OR_Q_2_CHAR_OP_1412_19 => PS_P_OR_Q_2_CHAR_OP_1412_19,
		MC_1301_END_ADDR_TRF_E_CH => MC_1301_END_ADDR_TRF_E_CH,
		MC_BUFFER_END_OF_TRANSFER => MC_BUFFER_END_OF_TRANSFER,
		PS_E_CH_EXT_END_OF_TRF_STAR_1311 => PS_E_CH_EXT_END_OF_TRF_STAR_1311,
		PS_E_CH_EXT_END_OF_TRF_STAR_SIF => PS_E_CH_EXT_END_OF_TRF_STAR_SIF,
		PS_E_CH_EXT_END_OF_TRF_STAR_1412_19 => PS_E_CH_EXT_END_OF_TRF_STAR_1412_19,
		MC_1405_END_OF_OP_STAR_E_CH => MC_1405_END_OF_OP_STAR_E_CH,
		UNNAMED_26_DOT_00_DOT_01_DOT_0 => UNNAMED_26_DOT_00_DOT_01_DOT_0,
		MC_TAPE_IN_PROCESS => MC_TAPE_IN_PROCESS,
		MC_TAPE_IN_PROCESS_F_CH_JRJ => MC_TAPE_IN_PROCESS_F_CH_JRJ,
		MC_1301_END_OF_OP_STAR_E_CH => MC_1301_END_OF_OP_STAR_E_CH,
		PS_GATE_OFF_E_CH_EXT_END_OF_TRF => PS_GATE_OFF_E_CH_EXT_END_OF_TRF,
		MS_E_CH_SEL_ODD_PARITY_STAR_1412_19 => MS_E_CH_SEL_ODD_PARITY_STAR_1412_19,
		PS_E_CH_SELECT_7_BIT_UNIT_STAR_SIF => PS_E_CH_SELECT_7_BIT_UNIT_STAR_SIF,
		PS_END_OF_RECORD_STAR_1311 => PS_END_OF_RECORD_STAR_1311,
		PS_E_CH_SIF_SENSE_OR_CONTROL => PS_E_CH_SIF_SENSE_OR_CONTROL,
		PS_INT_END_OF_XFER_STAR_1311 => PS_INT_END_OF_XFER_STAR_1311,
		PS_F_CH_RESET_STAR_1414 => PS_F_CH_RESET_STAR_1414,
		PS_F_CH_SELECT_ODD_PARITY_STAR_1414 => PS_F_CH_SELECT_ODD_PARITY_STAR_1414,
		PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_SIF => PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_SIF,
		PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_2_9 => PS_F_CH_SEL_ODD_PARITY_UNIT_STAR_2_9,
		PS_F_CH_SELECT_7_BIT_UNIT_STAR_SIF => PS_F_CH_SELECT_7_BIT_UNIT_STAR_SIF,
		PS_F_CH_SELECT_7_BIT_UNIT_STAR_1414 => PS_F_CH_SELECT_7_BIT_UNIT_STAR_1414,
		MC_FILE_INVALID_ADDRESS_1405 => MC_FILE_INVALID_ADDRESS_1405,
		MS_E_CH_U_SEL_K_DOT_S_OP_MOD => MS_E_CH_U_SEL_K_DOT_S_OP_MOD,
		MS_F_CH_U_SEL_K_DOT_S_OP_MOD => MS_F_CH_U_SEL_K_DOT_S_OP_MOD,
		MS_RECOVER_LATCH_STAR_1311 => MS_RECOVER_LATCH_STAR_1311,
		PS_GT_OFF_E_CH_ST_SPL_DLY => PS_GT_OFF_E_CH_ST_SPL_DLY,
		PS_BLOCK_IO_LAST_EXECUTE => PS_BLOCK_IO_LAST_EXECUTE,
		MS_F_CH_CON_LAT_SET_STAR_1414_STAR => MS_F_CH_CON_LAT_SET_STAR_1414_STAR,
		MC_1301_ERROR_F_CH => MC_1301_ERROR_F_CH,
		MC_1405_ERROR_F_CH => MC_1405_ERROR_F_CH,
		PS_F_CH_CHECK_STAR_SIF => PS_F_CH_CHECK_STAR_SIF,
		PS_F_CH_CHECK_BUS_STAR_1414_STAR => PS_F_CH_CHECK_BUS_STAR_1414_STAR,
		MC_RBC_ERROR_1405_F_CH => MC_RBC_ERROR_1405_F_CH,
		PS_F_CH_CHECK_STAR_1412_19 => PS_F_CH_CHECK_STAR_1412_19,
		MS_F_CH_COND_LATCH_STAR_SIF => MS_F_CH_COND_LATCH_STAR_SIF,
		TW_RBC_ERROR_1405_F_CH => TW_RBC_ERROR_1405_F_CH,
		MC_1301_F_CH_CONDITION => MC_1301_F_CH_CONDITION,
		MC_1405_CONDITION_F_CH => MC_1405_CONDITION_F_CH,
		MC_SEL_OR_TI_ON_CH_2 => MC_SEL_OR_TI_ON_CH_2,
		PS_F_CH_COND_BUS_STAR_1414_STAR => PS_F_CH_COND_BUS_STAR_1414_STAR,
		MS_SET_F_CH_CON_LATCH_STAR_1414_STAR => MS_SET_F_CH_CON_LATCH_STAR_1414_STAR,
		PS_F_CH_SIF_SENSE_OR_CONTROL => PS_F_CH_SIF_SENSE_OR_CONTROL,
		MC_1301_READY_F_CH => MC_1301_READY_F_CH,
		MC_1405_READY_F_CH => MC_1405_READY_F_CH,
		PS_F_CH_READY_BUS_STAR_1414_STAR => PS_F_CH_READY_BUS_STAR_1414_STAR,
		PS_F_CH_READY_BUS_STAR_1412_19 => PS_F_CH_READY_BUS_STAR_1412_19,
		PS_F_CH_READY_BUS_STAR_SIF => PS_F_CH_READY_BUS_STAR_SIF,
		MC_SELECT_AND_REWIND_STAR_F_CH => MC_SELECT_AND_REWIND_STAR_F_CH,
		PS_F_CH_BUSY_BUS_STAR_1414_STAR => PS_F_CH_BUSY_BUS_STAR_1414_STAR,
		PS_F_CH_BUSY_BUS_STAR_1412_19 => PS_F_CH_BUSY_BUS_STAR_1412_19,
		MC_1301_BUSY_F_CH => MC_1301_BUSY_F_CH,
		MC_1405_BUSY_F_CH => MC_1405_BUSY_F_CH,
		PS_F_CH_CLR_LATCH_STAR_1414_STAR => PS_F_CH_CLR_LATCH_STAR_1414_STAR,
		PS_RESET_F_CH_CLR_LAT_STAR_1414_STAR => PS_RESET_F_CH_CLR_LAT_STAR_1414_STAR,
		MC_SELECT_AT_LOAD_POINT_STAR_F_CH => MC_SELECT_AT_LOAD_POINT_STAR_F_CH,
		MC_WRITE_CONDITION_STAR_F_CH => MC_WRITE_CONDITION_STAR_F_CH,
		PS_ASSEMBLY_TO_F_CH_STAR_1414_STAR => PS_ASSEMBLY_TO_F_CH_STAR_1414_STAR,
		PS_GATE_F_CH_ST_SAMPLE_A_STAR_1414_STAR => PS_GATE_F_CH_ST_SAMPLE_A_STAR_1414_STAR,
		MC_1301_END_ADDR_TRF_F_CH => MC_1301_END_ADDR_TRF_F_CH,
		PS_SET_F_CH_EXT_END_TRF_STAR_SIF => PS_SET_F_CH_EXT_END_TRF_STAR_SIF,
		PS_F_CH_EXT_END_OF_TRF_BUS_STAR_1414 => PS_F_CH_EXT_END_OF_TRF_BUS_STAR_1414,
		PS_SET_F_CH_EXT_END_TRF_STAR_1412_19 => PS_SET_F_CH_EXT_END_TRF_STAR_1412_19,
		MC_1301_END_OF_OP_STAR_F_CH => MC_1301_END_OF_OP_STAR_F_CH,
		MC_1405_END_OF_OP_STAR_F_CH => MC_1405_END_OF_OP_STAR_F_CH,
		MC_1403_PRINT_BUFFER_BUSY => MC_1403_PRINT_BUFFER_BUSY,
		MC_I_O_PRINTER_READY => MC_I_O_PRINTER_READY,
		MC_SELECT_AT_LOAD_POINT_STAR_E_CH => MC_SELECT_AT_LOAD_POINT_STAR_E_CH,
		MC_WRITE_CONDITION_STAR_E_CH => MC_WRITE_CONDITION_STAR_E_CH,
		PS_GATE_ON_E_CH_END_ADDR_TRF => PS_GATE_ON_E_CH_END_ADDR_TRF,
		PS_WR_INHIBIT_STAR_7631_STAR_E_CH => PS_WR_INHIBIT_STAR_7631_STAR_E_CH,
		PS_SET_E_CH_NO_TRANS_LAT_STAR_SIF => PS_SET_E_CH_NO_TRANS_LAT_STAR_SIF,
		PS_SET_E_CH_NO_TRANS_LAT_STAR_12_19 => PS_SET_E_CH_NO_TRANS_LAT_STAR_12_19,
		MC_BUFFER_NO_TRANS_COND => MC_BUFFER_NO_TRANS_COND,
		MC_BUFFER_NO_TRANS_COND_JRJ => MC_BUFFER_NO_TRANS_COND_JRJ,
		MC_ADDR_COMP_TRUE_F_CH => MC_ADDR_COMP_TRUE_F_CH,
		MC_FAST_FILE_ON_LINE_F_CH => MC_FAST_FILE_ON_LINE_F_CH,
		MS_1311_F_CH_END_ADDR_TRF => MS_1311_F_CH_END_ADDR_TRF,
		PS_WR_INHIBIT_STAR_7631_STAR_F_CH => PS_WR_INHIBIT_STAR_7631_STAR_F_CH,
		PS_F_CH_NO_TRF_LATCH_STAR_SIF => PS_F_CH_NO_TRF_LATCH_STAR_SIF,
		PS_SET_F_CH_NO_TRANS_LAT_STAR_1414_STAR => PS_SET_F_CH_NO_TRANS_LAT_STAR_1414_STAR,
		PS_F_CH_NO_TRANS_LAT_STAR_12_19 => PS_F_CH_NO_TRANS_LAT_STAR_12_19,
		MC_E_CH_FILE_DIGIT_RING_7 => MC_E_CH_FILE_DIGIT_RING_7,
		MC_F_CH_FILE_DIGIT_RING_7 => MC_F_CH_FILE_DIGIT_RING_7,
		MINUS_36_VOLTS => MINUS_36_VOLTS,
		PS_OPTIONAL_SYNC_COND_STAR_CE => PS_OPTIONAL_SYNC_COND_STAR_CE,
		MS_OPTIONAL_SYNC_COND_A => MS_OPTIONAL_SYNC_COND_A,
		MS_OPTIONAL_SYNC_COND_B => MS_OPTIONAL_SYNC_COND_B,
		PS_BLOCK_ADDR_MOD_OR_1_STAR_1412_19 => PS_BLOCK_ADDR_MOD_OR_1_STAR_1412_19,
		PS_ADDR_MOD_SET_TO_1_STAR_1412_19 => PS_ADDR_MOD_SET_TO_1_STAR_1412_19,
		PS_1311_SET_AAR => PS_1311_SET_AAR,
		PS_1311_SET_DAR_STAR_1401 => PS_1311_SET_DAR_STAR_1401,
		PS_1311_RESET_AAR => PS_1311_RESET_AAR,
		MS_1311_RESET_DAR_STAR_1401 => MS_1311_RESET_DAR_STAR_1401,
		MS_SCAN_RESTART_LATCH_STAR_1311 => MS_SCAN_RESTART_LATCH_STAR_1311,
		PS_BLOCK_BAR_RO_E_CH_STAR_1311 => PS_BLOCK_BAR_RO_E_CH_STAR_1311,
		PS_BLOCK_BAR_RO_F_CH_STAR_1311 => PS_BLOCK_BAR_RO_F_CH_STAR_1311,
		PS_1311_RO_DAR_STAR_1401 => PS_1311_RO_DAR_STAR_1401,
		PS_E2_FULL_LATCH_STAR_SIF => PS_E2_FULL_LATCH_STAR_SIF,
		MS_F_CH_OUTPUT_WM_CYCLE_STAR_1414_STAR => MS_F_CH_OUTPUT_WM_CYCLE_STAR_1414_STAR,
		PS_OUTPUT_FIELD_CYCLE_STAR_1414_STAR => PS_OUTPUT_FIELD_CYCLE_STAR_1414_STAR,
		PS_ASM_CH_A_BIT_STAR_STERLING => PS_ASM_CH_A_BIT_STAR_STERLING,
		MS_SET_F_U_SEL_REG_2_BIT_STAR_1414_STAR => MS_SET_F_U_SEL_REG_2_BIT_STAR_1414_STAR,
		MS_SET_F_U_SEL_REG_1_BIT_STAR_1414_STAR => MS_SET_F_U_SEL_REG_1_BIT_STAR_1414_STAR,
		MV_CONSOLE_C_INPUT_STAR_CHK_OP => MV_CONSOLE_C_INPUT_STAR_CHK_OP,
		MC_BUFFER_STROBE => MC_BUFFER_STROBE,
		MC_SET_ECH_STROB_TR_E_FR_FEATS => MC_SET_ECH_STROB_TR_E_FR_FEATS,
		TW_SET_ECH_STROB_TR_E_FR_FEATS => TW_SET_ECH_STROB_TR_E_FR_FEATS,
		MC_BUFFER_STROBE_JRJ => MC_BUFFER_STROBE_JRJ,
		MC_TAPE_WRITE_STROBE => MC_TAPE_WRITE_STROBE,
		MC_TAPE_WRITE_STROBE_F_CH_JRJ => MC_TAPE_WRITE_STROBE_F_CH_JRJ,
		MC_1301_STROBE_E_CH => MC_1301_STROBE_E_CH,
		MC_1405_STROBE_E_CH => MC_1405_STROBE_E_CH,
		MC_TAPE_READ_STROBE => MC_TAPE_READ_STROBE,
		MC_TAPE_READ_STROBE_F_CH_JRJ => MC_TAPE_READ_STROBE_F_CH_JRJ,
		MS_F_CH_STK_SEL_OP_CODE_STAR_1414_STAR => MS_F_CH_STK_SEL_OP_CODE_STAR_1414_STAR,
		PS_F_CH_WRITE_LATCH_STAR_1414_STAR => PS_F_CH_WRITE_LATCH_STAR_1414_STAR,
		MS_F_SET_MOVE_MODE_LATCH_STAR_1414_STAR => MS_F_SET_MOVE_MODE_LATCH_STAR_1414_STAR,
		MC_1301_STROBE_F_CH => MC_1301_STROBE_F_CH,
		MC_SET_FCH_STROB_TR_E_FR_FEATS => MC_SET_FCH_STROB_TR_E_FR_FEATS,
		TW_SET_FCH_STROB_TR_E_FR_FEATS => TW_SET_FCH_STROB_TR_E_FR_FEATS,
		MC_1405_STROBE_F_CH => MC_1405_STROBE_F_CH,
		PS_GATE_SET_F1_REG_STAR_1414_STAR => PS_GATE_SET_F1_REG_STAR_1414_STAR,
		PS_GATE_RESET_F2_FULL_STAR_1414_STAR => PS_GATE_RESET_F2_FULL_STAR_1414_STAR,
		PS_RGEN_EXTN_CTRL_STAR_STERLING => PS_RGEN_EXTN_CTRL_STAR_STERLING,
		PS_PULL_OFF_CMP_HI_STAR_1311_SCAN => PS_PULL_OFF_CMP_HI_STAR_1311_SCAN,
		PS_PULL_OFF_CMP_LO_STAR_1311_SCAN => PS_PULL_OFF_CMP_LO_STAR_1311_SCAN,
		PS_SIMULATE_CMP_HI_STAR_1311_SCAN => PS_SIMULATE_CMP_HI_STAR_1311_SCAN,
		PS_SIMULATE_CMP_EQ_STAR_1311_SCAN => PS_SIMULATE_CMP_EQ_STAR_1311_SCAN,
		PS_SIMULATE_CMP_LO_STAR_1311_SCAN => PS_SIMULATE_CMP_LO_STAR_1311_SCAN,
		PS_CMP_MODE_B_CYCLE_STAR_1311 => PS_CMP_MODE_B_CYCLE_STAR_1311,
		M36_VOLTS_ON_CONSOLE => M36_VOLTS_ON_CONSOLE,
		PS_INTERLOCK_F_CH_STAR_1414_STAR => PS_INTERLOCK_F_CH_STAR_1414_STAR,
		MC_READER_BUSY => MC_READER_BUSY,
		MC_READER_BUSY_JRJ => MC_READER_BUSY_JRJ,
		MC_PUNCH_BUSY => MC_PUNCH_BUSY,
		MC_PUNCH_BUSY_JRJ => MC_PUNCH_BUSY_JRJ,
		MC_PAPER_TAPE_READER_BUSY => MC_PAPER_TAPE_READER_BUSY,
		MC_PAPER_TAPE_READY_BUSY_JRJ => MC_PAPER_TAPE_READY_BUSY_JRJ,
		MC_I_O_CLOCK_080_090_TIME => MC_I_O_CLOCK_080_090_TIME,
		MC_I_O_CLOCK_080_090_TIME_JRJ => MC_I_O_CLOCK_080_090_TIME_JRJ,
		PS_INTERRUPT_REQUEST_STAR_SIF => PS_INTERRUPT_REQUEST_STAR_SIF,
		PS_INTERRUPT_REQUEST_JRJ => PS_INTERRUPT_REQUEST_JRJ,
		PS_INTERRUPT_REQUEST_STAR_1414_STAR => PS_INTERRUPT_REQUEST_STAR_1414_STAR,
		PS_I_OP_DOT_I_CYCLE_DOT_E_STAR_AUTS_STAR => PS_I_OP_DOT_I_CYCLE_DOT_E_STAR_AUTS_STAR,
		MC_ANY_SEEK_COMP_STAR_E_CH_1405 => MC_ANY_SEEK_COMP_STAR_E_CH_1405,
		MC_ANY_SEEK_COMP_STAR_E_CH_1301 => MC_ANY_SEEK_COMP_STAR_E_CH_1301,
		MC_ANY_SEEK_COMP_STAR_F_CH_1301 => MC_ANY_SEEK_COMP_STAR_F_CH_1301,
		MC_ANY_SEEK_COMP_STAR_F_CH_1405 => MC_ANY_SEEK_COMP_STAR_F_CH_1405,
		PS_2ND_CND_A_BRANCH_STAR_SIF => PS_2ND_CND_A_BRANCH_STAR_SIF,
		PS_2ND_CND_A_BRANCH_STAR_SIF_JRJ => PS_2ND_CND_A_BRANCH_STAR_SIF_JRJ,
		PS_2ND_CND_A_BRANCH_STAR_1414_STAR => PS_2ND_CND_A_BRANCH_STAR_1414_STAR,
		PS_NO_BRANCH_CND_INTER_STAR_SIF => PS_NO_BRANCH_CND_INTER_STAR_SIF,
		PS_NO_BRANCH_CND_INTER_STAR_SIF_JRJ => PS_NO_BRANCH_CND_INTER_STAR_SIF_JRJ,
		PS_NO_BRANCH_CND_INTER_STAR_1414_STAR => PS_NO_BRANCH_CND_INTER_STAR_1414_STAR,
		M6_V => M6_V,
		MY_CHAR_SEL_ERROR_CHK_1_STAR_2_STAR => MY_CHAR_SEL_ERROR_CHK_1_STAR_2_STAR,
		MY_CHAR_SEL_ERROR_CHK_2_STAR_2_STAR => MY_CHAR_SEL_ERROR_CHK_2_STAR_2_STAR,
		CONS_36V => CONS_36V,
		MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO => MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO,
		PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC => PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC,
		MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO => MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO,
		MV_CONS_PRINTER_C2_CAM_NC => MV_CONS_PRINTER_C2_CAM_NC,
		MV_CONS_PRINTER_C2_CAM_NO => MV_CONS_PRINTER_C2_CAM_NO,
		MV_CONS_PRINTER_SPACE_NO => MV_CONS_PRINTER_SPACE_NO,
		MV_CONS_PRINTER_C1_CAM_NO => MV_CONS_PRINTER_C1_CAM_NO,
		MV_CONS_PRINTER_C1_CAM_NC => MV_CONS_PRINTER_C1_CAM_NC,
		MV_CONS_PRINTER_C3_OR_C4_NO => MV_CONS_PRINTER_C3_OR_C4_NO,
		MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC => MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC,
		MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO => MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO,
		MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO => MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO,
		MB_CONS_PRINTER_EVEN_BIT_CHECK => MB_CONS_PRINTER_EVEN_BIT_CHECK,
		MV_CONS_PRINTER_ODD_BIT_CHECK => MV_CONS_PRINTER_ODD_BIT_CHECK,
		MV_CONS_PRINTER_LAST_COLUMN_SET => MV_CONS_PRINTER_LAST_COLUMN_SET,
		MV_KEYBOARD_LOCK_MODE_STAR_NO => MV_KEYBOARD_LOCK_MODE_STAR_NO,
		MV_KEYBOARD_UNLOCK_MODE => MV_KEYBOARD_UNLOCK_MODE,
		PS_E1_INPUT_STAR_SIF_BUS => PS_E1_INPUT_STAR_SIF_BUS,
		PS_E1_INPUT_STAR_1412_19_BUS => PS_E1_INPUT_STAR_1412_19_BUS,
		MC_E_CH_TAU_TO_CPU_BUS => MC_E_CH_TAU_TO_CPU_BUS,
		MC_I_O_SYNC_TO_CPU_BUS => MC_I_O_SYNC_TO_CPU_BUS,
		MC_E_CH_1301_TO_CPU_BUS => MC_E_CH_1301_TO_CPU_BUS,
		MC_E_CH_1405_TO_CPU_BUS => MC_E_CH_1405_TO_CPU_BUS,
		MV_CONS_PRTR_TO_CPU_BUS => MV_CONS_PRTR_TO_CPU_BUS,
		PS_F1_INPUT_STAR_SIF_BUS => PS_F1_INPUT_STAR_SIF_BUS,
		PS_F1_INPUT_STAR_1414_STAR_BUS => PS_F1_INPUT_STAR_1414_STAR_BUS,
		PS_F1_INPUT_STAR_1412_19_BUS => PS_F1_INPUT_STAR_1412_19_BUS,
		MC_F_CH_1301_TO_CPU_BUS => MC_F_CH_1301_TO_CPU_BUS,
		MC_F_CH_1405_TO_CPU_BUS => MC_F_CH_1405_TO_CPU_BUS,
		MC_F_CH_TAU_TO_CPU_BUS => MC_F_CH_TAU_TO_CPU_BUS,
		PV_SENSE_CHAR_0_B1_BUS => PV_SENSE_CHAR_0_B1_BUS,
		PV_SENSE_CHAR_0_B2_BUS => PV_SENSE_CHAR_0_B2_BUS,
		PV_SENSE_CHAR_0_D1_BUS => PV_SENSE_CHAR_0_D1_BUS,
		PV_SENSE_CHAR_0_D2_BUS => PV_SENSE_CHAR_0_D2_BUS,
		PV_SENSE_CHAR_1_B1_BUS => PV_SENSE_CHAR_1_B1_BUS,
		PV_SENSE_CHAR_1_B2_BUS => PV_SENSE_CHAR_1_B2_BUS,
		PV_SENSE_CHAR_1_D1_BUS => PV_SENSE_CHAR_1_D1_BUS,
		PV_SENSE_CHAR_1_D2_BUS => PV_SENSE_CHAR_1_D2_BUS,
		PV_SENSE_CHAR_2_B1_BUS => PV_SENSE_CHAR_2_B1_BUS,
		PV_SENSE_CHAR_2_B2_BUS => PV_SENSE_CHAR_2_B2_BUS,
		PV_SENSE_CHAR_2_D1_BUS => PV_SENSE_CHAR_2_D1_BUS,
		PV_SENSE_CHAR_2_D2_BUS => PV_SENSE_CHAR_2_D2_BUS,
		PV_SENSE_CHAR_3_B1_BUS => PV_SENSE_CHAR_3_B1_BUS,
		PV_SENSE_CHAR_3_D1_BUS => PV_SENSE_CHAR_3_D1_BUS,
		PV_SENSE_CHAR_3_D2_BUS => PV_SENSE_CHAR_3_D2_BUS,
		PV_SENSE_CHAR_3_B2_BUS => PV_SENSE_CHAR_3_B2_BUS,
		PS_B_DATA_REG_STAR_0_STAR_Z_BUS => PS_B_DATA_REG_STAR_0_STAR_Z_BUS,
		PS_B_DATA_REG_STAR_1_STAR_Z_BUS => PS_B_DATA_REG_STAR_1_STAR_Z_BUS,
		PS_B_DATA_REG_STAR_2_STAR_Z_BUS => PS_B_DATA_REG_STAR_2_STAR_Z_BUS,
		PS_B_DATA_REG_STAR_3_STAR_Z_BUS => PS_B_DATA_REG_STAR_3_STAR_Z_BUS,
		SWITCH_ROT_STOR_SCAN_DK6 => SWITCH_ROT_STOR_SCAN_DK6,
		SWITCH_MOM_CONS_START => SWITCH_MOM_CONS_START,
		SWITCH_MOM_CE_START => SWITCH_MOM_CE_START,
		SWITCH_MOM_CONS_STOP_PL1 => SWITCH_MOM_CONS_STOP_PL1,
		SWITCH_MOM_CE_STOP_SW_PL1 => SWITCH_MOM_CE_STOP_SW_PL1,
		SWITCH_TOG_I_O_CHK_ST_PL1 => SWITCH_TOG_I_O_CHK_ST_PL1,
		SWITCH_TOG_ADDR_STOP_PL1 => SWITCH_TOG_ADDR_STOP_PL1,
		SWITCH_REL_PWR_ON_RST => SWITCH_REL_PWR_ON_RST,
		SWITCH_MOM_CO_CPR_RST => SWITCH_MOM_CO_CPR_RST,
		SWITCH_MOM_CE_CPR_RST => SWITCH_MOM_CE_CPR_RST,
		SWITCH_MOM_PROG_RESET => SWITCH_MOM_PROG_RESET,
		SWITCH_TOG_1401_MODE_PL1 => SWITCH_TOG_1401_MODE_PL1,
		SWITCH_ROT_CHECK_CTRL_DK2 => SWITCH_ROT_CHECK_CTRL_DK2,
		SWITCH_MOM_IO_CHK_RST_PL1 => SWITCH_MOM_IO_CHK_RST_PL1,
		SWITCH_ROT_M_RTC_023_CC => SWITCH_ROT_M_RTC_023_CC,
		SWITCH_ROT_M_RTC_578_CC => SWITCH_ROT_M_RTC_578_CC,
		SWITCH_ROT_MRTC_01234_CC => SWITCH_ROT_MRTC_01234_CC,
		SWITCH_ROT_MRTC_56789_CC => SWITCH_ROT_MRTC_56789_CC,
		SWITCH_ROT_HRTC_01234_CC => SWITCH_ROT_HRTC_01234_CC,
		SWITCH_ROT_HRTC_56789_CC => SWITCH_ROT_HRTC_56789_CC,
		SWITCH_ROT_HRTC_012_CC => SWITCH_ROT_HRTC_012_CC,
		SWITCH_REL_RTC_BUSY => SWITCH_REL_RTC_BUSY,
		SWITCH_ROT_TENS_SYNC_DK2 => SWITCH_ROT_TENS_SYNC_DK2,
		SWITCH_ROT_TENS_SYNC_DK1 => SWITCH_ROT_TENS_SYNC_DK1,
		SWITCH_ROT_UNITS_SYNC_DK2 => SWITCH_ROT_UNITS_SYNC_DK2,
		SWITCH_ROT_UNITS_SYNC_DK1 => SWITCH_ROT_UNITS_SYNC_DK1,
		SWITCH_ROT_SCAN_GATE_DK1 => SWITCH_ROT_SCAN_GATE_DK1,
		SWITCH_ROT_THOUS_SYNC_DK2 => SWITCH_ROT_THOUS_SYNC_DK2,
		SWITCH_ROT_THOUS_SYNC_DK1 => SWITCH_ROT_THOUS_SYNC_DK1,
		SWITCH_ROT_HUNDS_SYNC_DK2 => SWITCH_ROT_HUNDS_SYNC_DK2,
		SWITCH_ROT_HUNDS_SYNC_DK1 => SWITCH_ROT_HUNDS_SYNC_DK1,
		SWITCH_ROT_ADDR_ENTRY_DK3 => SWITCH_ROT_ADDR_ENTRY_DK3,
		SWITCH_ROT_ADDR_SEL_DK1 => SWITCH_ROT_ADDR_SEL_DK1,
		SWITCH_MOM_ADDR_DISP => SWITCH_MOM_ADDR_DISP,
		SWITCH_ROT_STOR_SCAN_DK5 => SWITCH_ROT_STOR_SCAN_DK5,
		SWITCH_TOG_ASTERISK_PL2 => SWITCH_TOG_ASTERISK_PL2,
		SWITCH_TOG_SENSE_SW_1_PL1 => SWITCH_TOG_SENSE_SW_1_PL1,
		SWITCH_TOG_SENSE_SW_2_PL1 => SWITCH_TOG_SENSE_SW_2_PL1,
		SWITCH_TOG_SENSE_SW_4_PL1 => SWITCH_TOG_SENSE_SW_4_PL1,
		SWITCH_TOG_SENSE_SW_8_PL1 => SWITCH_TOG_SENSE_SW_8_PL1,
		SWITCH_TOG_SENSE_SW_A_PL1 => SWITCH_TOG_SENSE_SW_A_PL1,
		SWITCH_TOG_SENSE_SW_B_PL1 => SWITCH_TOG_SENSE_SW_B_PL1,
		SWITCH_TOG_SENSE_SW_C_PL1 => SWITCH_TOG_SENSE_SW_C_PL1,
		SWITCH_TOG_SENSE_SW_W_PL1 => SWITCH_TOG_SENSE_SW_W_PL1,
		SWITCH_MOM_1ST_TST_SW_PL1 => SWITCH_MOM_1ST_TST_SW_PL1,
		SWITCH_MOM_2ND_TST_SW_PL1 => SWITCH_MOM_2ND_TST_SW_PL1,
		SWITCH_MOM_3RD_TST_SW_PL1 => SWITCH_MOM_3RD_TST_SW_PL1,
		SWITCH_ALT_PRIORITY_PL1 => SWITCH_ALT_PRIORITY_PL1,
		SWITCH_ALT_PRIORITY_PL2 => SWITCH_ALT_PRIORITY_PL2,
		SWITCH_ROT_I_O_UNIT_DK1 => SWITCH_ROT_I_O_UNIT_DK1,
		SWITCH_ROT_MODE_SW_DK => SWITCH_ROT_MODE_SW_DK,
		SWITCH_ROT_MODE_SW_DK1 => SWITCH_ROT_MODE_SW_DK1,
		SWITCH_TOG_CH_1 => SWITCH_TOG_CH_1,
		SWITCH_TOG_CH_2 => SWITCH_TOG_CH_2,
		SWITCH_TOG_AUTO_START_PL1 => SWITCH_TOG_AUTO_START_PL1,
		SWITCH_ROT_ADDR_ENTRY_DK1 => SWITCH_ROT_ADDR_ENTRY_DK1,
		SWITCH_TOG_WR_INHIBIT_PL1 => SWITCH_TOG_WR_INHIBIT_PL1,
		SWITCH_ROT_STOR_SCAN_DK1 => SWITCH_ROT_STOR_SCAN_DK1,
		SWITCH_ROT_CYCLE_CTRL_DK1 => SWITCH_ROT_CYCLE_CTRL_DK1,
		SWITCH_ROT_ADDR_ENTRY_DKA => SWITCH_ROT_ADDR_ENTRY_DKA,
		SWITCH_ROT_CHECK_CTRL_DK1 => SWITCH_ROT_CHECK_CTRL_DK1,
		SWITCH_TOG_INHIBIT_PO_PL1 => SWITCH_TOG_INHIBIT_PO_PL1,
		SWITCH_ROT_STOR_SCAN_DK4 => SWITCH_ROT_STOR_SCAN_DK4,
		SWITCH_TOG_ASTERISK_PL1 => SWITCH_TOG_ASTERISK_PL1,
		SWITCH_ROT_STOR_SCAN_DK3 => SWITCH_ROT_STOR_SCAN_DK3,
		SWITCH_ROT_ADDR_ENTRY_DK2 => SWITCH_ROT_ADDR_ENTRY_DK2,
		SWITCH_TOG_INHIBIT_PO_PL2 => SWITCH_TOG_INHIBIT_PO_PL2,
		SWITCH_MOM_STARTPRINT => SWITCH_MOM_STARTPRINT,
		SWITCH_ROT_CYCLE_CTRL_DK2 => SWITCH_ROT_CYCLE_CTRL_DK2,
		PS_1ST_CLOCK_PULSE_1 => PS_1ST_CLOCK_PULSE_1,
		PS_CLOCK_STOPPED_STAR_AUTS_STAR => PS_CLOCK_STOPPED_STAR_AUTS_STAR,
		PS_CLOCK_STOPPED => PS_CLOCK_STOPPED,
		MS_CLOCK_STOPPED => MS_CLOCK_STOPPED,
		MS_LOGIC_GATE_B_1 => MS_LOGIC_GATE_B_1,
		PS_LOGIC_GATE_C_1 => PS_LOGIC_GATE_C_1,
		MS_LOGIC_GATE_D_1 => MS_LOGIC_GATE_D_1,
		PS_LOGIC_GATE_D_1 => PS_LOGIC_GATE_D_1,
		PS_LOGIC_GATE_E_1 => PS_LOGIC_GATE_E_1,
		PS_LOGIC_GATE_B_OR_C => PS_LOGIC_GATE_B_OR_C,
		PS_LOGIC_GATE_D_OR_E_OR_F => PS_LOGIC_GATE_D_OR_E_OR_F,
		PS_LOGIC_GATE_EARLY_B => PS_LOGIC_GATE_EARLY_B,
		PS_LOGIC_GATE_EARLY_B_OR_S => PS_LOGIC_GATE_EARLY_B_OR_S,
		PS_I_CYCLE_1 => PS_I_CYCLE_1,
		PS_I_CYCLE_DOT_NOT_CR_DISABLE => PS_I_CYCLE_DOT_NOT_CR_DISABLE,
		MS_F_CYCLE_DOT_ANY_LAST_GATE => MS_F_CYCLE_DOT_ANY_LAST_GATE,
		PS_E_CYCLE_CTRL => PS_E_CYCLE_CTRL,
		PS_E_CYCLE => PS_E_CYCLE,
		PS_E_CYCLE_CTRL_STAR_1311 => PS_E_CYCLE_CTRL_STAR_1311,
		PS_F_CYCLE_CTRL => PS_F_CYCLE_CTRL,
		PS_F_CYCLE => PS_F_CYCLE,
		PS_LAST_INSN_RO_CYCLE_2 => PS_LAST_INSN_RO_CYCLE_2,
		MS_START_KEY => MS_START_KEY,
		PS_RUN_OR_IE_MODE_STAR_AUTS_STAR => PS_RUN_OR_IE_MODE_STAR_AUTS_STAR,
		PS_BRANCH_TO_A_CONDITIONS => PS_BRANCH_TO_A_CONDITIONS,
		PS_E_CH_READY_BUS => PS_E_CH_READY_BUS,
		MS_E_CH_NOT_READY => MS_E_CH_NOT_READY,
		MS_COMPUTER_RESET_1 => MS_COMPUTER_RESET_1,
		MS_COMPUTER_RESET_2 => MS_COMPUTER_RESET_2,
		MC_COMP_RESET_TO_TAPE_STAR_E_CH => MC_COMP_RESET_TO_TAPE_STAR_E_CH,
		MC_E_CH_COMP_RESET_TO_1301 => MC_E_CH_COMP_RESET_TO_1301,
		MC_E_CH_COMP_RESET_TO_1405 => MC_E_CH_COMP_RESET_TO_1405,
		MC_COMP_RESET_TO_TAPE_STAR_F_CH => MC_COMP_RESET_TO_TAPE_STAR_F_CH,
		MC_F_CH_COMP_RESET_TO_1301 => MC_F_CH_COMP_RESET_TO_1301,
		MC_F_CH_COMP_RESET_TO_1405 => MC_F_CH_COMP_RESET_TO_1405,
		MC_COMP_RESET_TO_BUFFER => MC_COMP_RESET_TO_BUFFER,
		MS_PROGRAM_RESET_6 => MS_PROGRAM_RESET_6,
		MS_PROGRAM_RESET_2 => MS_PROGRAM_RESET_2,
		PS_1401_MODE => PS_1401_MODE,
		MS_1401_MODE => MS_1401_MODE,
		MC_1401_MODE_TO_1405 => MC_1401_MODE_TO_1405,
		PS_OP_REG_ARS_C_BIT => PS_OP_REG_ARS_C_BIT,
		PS_OP_REG_ARS_NOT_C_BIT => PS_OP_REG_ARS_NOT_C_BIT,
		PS_OP_DCDR_NOT_B_DOT_NOT_A_DOT_NOT_8_B => PS_OP_DCDR_NOT_B_DOT_NOT_A_DOT_NOT_8_B,
		PS_OP_DCDR_B_DOT_A_DOT_8_B => PS_OP_DCDR_B_DOT_A_DOT_8_B,
		PS_OP_DCDR_B_DOT_NOT_A_DOT_NOT_8_B => PS_OP_DCDR_B_DOT_NOT_A_DOT_NOT_8_B,
		PS_OP_DCDR_B_DOT_NOT_A_DOT_8_B => PS_OP_DCDR_B_DOT_NOT_A_DOT_8_B,
		PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_NOT_1_B => PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_NOT_1_B,
		PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_1_B => PS_OP_DCDR_NOT_4_DOT_NOT_2_DOT_1_B,
		PS_OP_DCDR_NOT_4_DOT_2_DOT_NOT_1_B => PS_OP_DCDR_NOT_4_DOT_2_DOT_NOT_1_B,
		PS_OP_DCDR_4_DOT_2_DOT_NOT_1_B => PS_OP_DCDR_4_DOT_2_DOT_NOT_1_B,
		PS_OP_DCDR_4_DOT_NOT_2_DOT_NOT_1_B => PS_OP_DCDR_4_DOT_NOT_2_DOT_NOT_1_B,
		PS_OP_DCDR_4_DOT_2_DOT_1_B => PS_OP_DCDR_4_DOT_2_DOT_1_B,
		PS_NOT_B_DOT_NOT_A_DOT_8_OP_MOD => PS_NOT_B_DOT_NOT_A_DOT_8_OP_MOD,
		PS_NOT_B_DOT_NOT_A_DOT_NOT_8_OP_MOD => PS_NOT_B_DOT_NOT_A_DOT_NOT_8_OP_MOD,
		PS_NOT_4_DOT_NOT_2_DOT_NOT_1_OP_MOD => PS_NOT_4_DOT_NOT_2_DOT_NOT_1_OP_MOD,
		PS_NOT_4_DOT_NOT_2_DOT_1_OP_MOD => PS_NOT_4_DOT_NOT_2_DOT_1_OP_MOD,
		PS_NOT_4_DOT_2_DOT_1_OP_MOD => PS_NOT_4_DOT_2_DOT_1_OP_MOD,
		PS_NOT_4_DOT_2_DOT_NOT_1_OP_MOD => PS_NOT_4_DOT_2_DOT_NOT_1_OP_MOD,
		PS_4_DOT_2_DOT_NOT_1_OP_MOD => PS_4_DOT_2_DOT_NOT_1_OP_MOD,
		PS_4_DOT_2_DOT_1_OP_MOD => PS_4_DOT_2_DOT_1_OP_MOD,
		PS_4_DOT_NOT_2_DOT_1_OP_MOD => PS_4_DOT_NOT_2_DOT_1_OP_MOD,
		PS_4_DOT_NOT_2_DOT_NOT_1_OP_MOD => PS_4_DOT_NOT_2_DOT_NOT_1_OP_MOD,
		PS_S_SYMBOL_OP_MODIFIER => PS_S_SYMBOL_OP_MODIFIER,
		PS_B_SYMBOL_OP_MODIFIER => PS_B_SYMBOL_OP_MODIFIER,
		PS_E_SYMBOL_OP_MODIFIER => PS_E_SYMBOL_OP_MODIFIER,
		PS_F_SYMBOL_OP_MODIFIER => PS_F_SYMBOL_OP_MODIFIER,
		PS_LOZ_SYMBOL_OP_MODIFIER => PS_LOZ_SYMBOL_OP_MODIFIER,
		PS_R_SYMBOL_OP_MODIFIER => PS_R_SYMBOL_OP_MODIFIER,
		PS_PERCENT_SIGN_OP_MODIFIER => PS_PERCENT_SIGN_OP_MODIFIER,
		PS_A_SYMBOL_OP_MODIFIER => PS_A_SYMBOL_OP_MODIFIER,
		PS_RECORD_MARK_OP_MODIFIER => PS_RECORD_MARK_OP_MODIFIER,
		PS_C_SYMBOL_OP_MODIFIER => PS_C_SYMBOL_OP_MODIFIER,
		PS_D_SYMBOL_OP_MODIFIER => PS_D_SYMBOL_OP_MODIFIER,
		PS_L_SYMBOL_OP_MODIFIER => PS_L_SYMBOL_OP_MODIFIER,
		PS_EXCLAM_MK_OP_MODIFIER => PS_EXCLAM_MK_OP_MODIFIER,
		PS_ONE_SYMBOL_OP_MODIFIER => PS_ONE_SYMBOL_OP_MODIFIER,
		PS_TWO_SYMBOL_OP_MODIFIER => PS_TWO_SYMBOL_OP_MODIFIER,
		PS_ASTERISK_OP_MODIFIER => PS_ASTERISK_OP_MODIFIER,
		MS_COND_TEST_BRANCH_OP_CODE => MS_COND_TEST_BRANCH_OP_CODE,
		MS_INTERRUPT_TEST_OP_CODE => MS_INTERRUPT_TEST_OP_CODE,
		PS_M_OR_L_OP_CODES => PS_M_OR_L_OP_CODES,
		MC_CPU_READY_TO_TID => MC_CPU_READY_TO_TID,
		PS_E_CH_DISCON_LATCH => PS_E_CH_DISCON_LATCH,
		PS_E_CH_DISCON_LATCH_JRJ => PS_E_CH_DISCON_LATCH_JRJ,
		MC_E_CH_DISCON_TO_1301 => MC_E_CH_DISCON_TO_1301,
		MC_E_CH_DISCON_TO_1405 => MC_E_CH_DISCON_TO_1405,
		MS_E_CH_EXT_END_OF_TRANSFER => MS_E_CH_EXT_END_OF_TRANSFER,
		PS_I_O_COML_AT_LATCH => PS_I_O_COML_AT_LATCH,
		PS_LOZENGE_OR_ASTERISK => PS_LOZENGE_OR_ASTERISK,
		PS_I_O_ASTERISK_LATCH => PS_I_O_ASTERISK_LATCH,
		MC_UNIT_1_SELECT_TO_I_O => MC_UNIT_1_SELECT_TO_I_O,
		MC_UNIT_2_SELECT_TO_I_O => MC_UNIT_2_SELECT_TO_I_O,
		MC_UNIT_4_SELECT_TO_I_O => MC_UNIT_4_SELECT_TO_I_O,
		MC_UNIT_8_SEL_TO_I_O => MC_UNIT_8_SEL_TO_I_O,
		MC_SELECT_UNIT_P => MC_SELECT_UNIT_P,
		MC_SELECT_UNIT_D => MC_SELECT_UNIT_D,
		MS_E_CH_SELECT_UNIT_K => MS_E_CH_SELECT_UNIT_K,
		MC_SELECT_UNIT_Q => MC_SELECT_UNIT_Q,
		MC_E_CH_SELECT_UNIT_R => MC_E_CH_SELECT_UNIT_R,
		MC_SELECT_UNIT_L => MC_SELECT_UNIT_L,
		MC_E_CH_SELECT_UNIT_M => MC_E_CH_SELECT_UNIT_M,
		MC_SELECT_UNIT_N => MC_SELECT_UNIT_N,
		PS_E_CH_SELECT_UNIT_F => PS_E_CH_SELECT_UNIT_F,
		MC_ODD_PARITY_TO_TAPE_STAR_E_CH => MC_ODD_PARITY_TO_TAPE_STAR_E_CH,
		MC_UNIT_SEL_F_STAR_E_CH_1301 => MC_UNIT_SEL_F_STAR_E_CH_1301,
		MC_UNIT_SEL_F_STAR_E_CH_1405 => MC_UNIT_SEL_F_STAR_E_CH_1405,
		PS_E_CH_UNOVLP_IN_PROCESS => PS_E_CH_UNOVLP_IN_PROCESS,
		PS_E_CH_IN_PROCESS => PS_E_CH_IN_PROCESS,
		MS_LOAD_CYCLE => MS_LOAD_CYCLE,
		PS_E_CH_INT_END_OF_TRANSFER => PS_E_CH_INT_END_OF_TRANSFER,
		MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_E_CH => MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_E_CH,
		MS_F_CH_RESET => MS_F_CH_RESET,
		MS_F_CH_RESET_1 => MS_F_CH_RESET_1,
		PS_F_CH_U_SEL_A_DOT_NOT_8_DOT_NOT_1 => PS_F_CH_U_SEL_A_DOT_NOT_8_DOT_NOT_1,
		MC_ODD_PARITY_TO_TAPE_STAR_F_CH => MC_ODD_PARITY_TO_TAPE_STAR_F_CH,
		PS_F_CH_SELECT_UNIT_F_LN_2 => PS_F_CH_SELECT_UNIT_F_LN_2,
		MC_UNIT_SEL_F_F_CH_1301 => MC_UNIT_SEL_F_F_CH_1301,
		MC_UNIT_SELECT_F_STAR_F_CH_1405 => MC_UNIT_SELECT_F_STAR_F_CH_1405,
		PS_F_CH_UNOVLP_IN_PROCESS => PS_F_CH_UNOVLP_IN_PROCESS,
		PS_F_CH_IN_PROCESS => PS_F_CH_IN_PROCESS,
		PS_E_CH_STATUS_SAMPLE_B => PS_E_CH_STATUS_SAMPLE_B,
		MS_E_CH_STATUS_SAMPLE_B_DELAY => MS_E_CH_STATUS_SAMPLE_B_DELAY,
		PS_E_CH_SECOND_SAMPLE_B => PS_E_CH_SECOND_SAMPLE_B,
		MS_E_CH_STATUS_SAMPLE_B => MS_E_CH_STATUS_SAMPLE_B,
		PS_E_CH_STATUS_SAMPLE_B_DELAY => PS_E_CH_STATUS_SAMPLE_B_DELAY,
		PS_E_CH_STATUS_SAMPLE_A => PS_E_CH_STATUS_SAMPLE_A,
		PS_E_CH_STATUS_SAMPLE_A_DELAY => PS_E_CH_STATUS_SAMPLE_A_DELAY,
		PS_F_CH_CONDITION => PS_F_CH_CONDITION,
		MS_F_CH_CHECK => MS_F_CH_CHECK,
		MS_F_CH_END_OF_RECORD_LATCH => MS_F_CH_END_OF_RECORD_LATCH,
		PS_F_CH_INT_END_OF_TRANSFER => PS_F_CH_INT_END_OF_TRANSFER,
		PS_F_CH_READY_BUS => PS_F_CH_READY_BUS,
		MS_F_CH_NOT_READY => MS_F_CH_NOT_READY,
		MS_F_CH_BUSY => MS_F_CH_BUSY,
		MS_F_CH_WRONG_LENGTH_RECORD => MS_F_CH_WRONG_LENGTH_RECORD,
		MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_F_CH => MC_W_DOT_L_DOT_R_DOT_TO_FILE_STAR_F_CH,
		MC_READ_TAPE_CALL_STAR_F_CH => MC_READ_TAPE_CALL_STAR_F_CH,
		MC_WRITE_TAPE_CALL_STAR_F_CH => MC_WRITE_TAPE_CALL_STAR_F_CH,
		MC_WRITE_TAPE_MK_CALL_STAR_F_CH => MC_WRITE_TAPE_MK_CALL_STAR_F_CH,
		MC_ERASE_CALL_STAR_F_CH => MC_ERASE_CALL_STAR_F_CH,
		MC_REWIND_UNLOAD_STAR_F_CH => MC_REWIND_UNLOAD_STAR_F_CH,
		MC_REWIND_CALL_STAR_F_CH => MC_REWIND_CALL_STAR_F_CH,
		MC_BACKSPACE_CALL_STAR_F_CH => MC_BACKSPACE_CALL_STAR_F_CH,
		MC_DISCONNECT_CALL_STAR_F_CH => MC_DISCONNECT_CALL_STAR_F_CH,
		MC_TURN_OFF_TI_STAR_F_CH => MC_TURN_OFF_TI_STAR_F_CH,
		MC_RESET_TAPE_SEL_REG_STAR_CH_F => MC_RESET_TAPE_SEL_REG_STAR_CH_F,
		MC_SET_TAPE_SEL_REG_STAR_CH_F => MC_SET_TAPE_SEL_REG_STAR_CH_F,
		PS_F_CH_STATUS_SAMPLE_A_DELAY => PS_F_CH_STATUS_SAMPLE_A_DELAY,
		PS_F_CH_STATUS_SAMPLE_A => PS_F_CH_STATUS_SAMPLE_A,
		PS_F_CH_STATUS_SAMPLE_B => PS_F_CH_STATUS_SAMPLE_B,
		PS_F_CH_SECOND_SAMPLE_B => PS_F_CH_SECOND_SAMPLE_B,
		PS_F_CH_STATUS_SAMPLE_B_1 => PS_F_CH_STATUS_SAMPLE_B_1,
		MS_F_CH_INT_END_OF_XFER_DELAYED => MS_F_CH_INT_END_OF_XFER_DELAYED,
		PS_F_CH_STATUS_SAMPLE_B_DELAY => PS_F_CH_STATUS_SAMPLE_B_DELAY,
		PS_F_CH_DISCON_LATCH => PS_F_CH_DISCON_LATCH,
		MC_F_CH_DISCON_TO_1301 => MC_F_CH_DISCON_TO_1301,
		MC_F_CH_DISCON_TO_1405 => MC_F_CH_DISCON_TO_1405,
		MS_F_CH_EXT_END_OF_TRANSFER => MS_F_CH_EXT_END_OF_TRANSFER,
		MS_1401_I_O_END => MS_1401_I_O_END,
		MC_CORRECT_TRANS_TO_BUFFER => MC_CORRECT_TRANS_TO_BUFFER,
		MC_RESET_SELECT_BUFFER_LATCHES => MC_RESET_SELECT_BUFFER_LATCHES,
		MC_READY_TO_BUFFER => MC_READY_TO_BUFFER,
		MC_1401_MODE_TO_BUFFER => MC_1401_MODE_TO_BUFFER,
		MC_STACK_SELECT_TO_BUFFER => MC_STACK_SELECT_TO_BUFFER,
		MC_FORMS_CTRL_TO_BUFFER => MC_FORMS_CTRL_TO_BUFFER,
		MC_FORMS_STACKER_GO => MC_FORMS_STACKER_GO,
		MC_TURN_OFF_TAPE_IND_STAR_E_CH => MC_TURN_OFF_TAPE_IND_STAR_E_CH,
		MC_RESET_TAPE_SEL_REG_STAR_E_CH => MC_RESET_TAPE_SEL_REG_STAR_E_CH,
		MC_SET_TAPE_SEL_REG_STAR_E_CH => MC_SET_TAPE_SEL_REG_STAR_E_CH,
		MC_DISCONNECT_CALL_STAR_E_CH => MC_DISCONNECT_CALL_STAR_E_CH,
		MC_READ_TAPE_CALL_STAR_E_CH => MC_READ_TAPE_CALL_STAR_E_CH,
		MC_WRITE_TAPE_CALL_STAR_E_CH => MC_WRITE_TAPE_CALL_STAR_E_CH,
		MC_WRITE_TAPE_MK_CALL_STAR_E_CH => MC_WRITE_TAPE_MK_CALL_STAR_E_CH,
		MC_ERASE_CALL_STAR_E_CH => MC_ERASE_CALL_STAR_E_CH,
		MC_REWIND_UNLOAD_STAR_E_CH => MC_REWIND_UNLOAD_STAR_E_CH,
		MC_REWIND_CALL_STAR_E_CH => MC_REWIND_CALL_STAR_E_CH,
		MC_BACKSPACE_CALL_STAR_E_CH => MC_BACKSPACE_CALL_STAR_E_CH,
		PS_E_CH_2ND_ADDR_TRF => PS_E_CH_2ND_ADDR_TRF,
		MS_E_CH_END_OF_2ND_ADDR_TRF => MS_E_CH_END_OF_2ND_ADDR_TRF,
		MC_1405_START_GATE_STAR_E_CH => MC_1405_START_GATE_STAR_E_CH,
		MC_1301_START_GATE_STAR_E_CH => MC_1301_START_GATE_STAR_E_CH,
		MC_SEEK_TEST_OP_STAR_E_CH_TO_1405 => MC_SEEK_TEST_OP_STAR_E_CH_TO_1405,
		MC_SEEK_TEST_OP_STAR_E_CH_TO_1301 => MC_SEEK_TEST_OP_STAR_E_CH_TO_1301,
		MC_FILE_STROBE_1ST_ADDR_STAR_E_CH => MC_FILE_STROBE_1ST_ADDR_STAR_E_CH,
		MC_FILE_STROBE_2ND_ADDR_STAR_E_CH => MC_FILE_STROBE_2ND_ADDR_STAR_E_CH,
		MC_FILE_DIGIT_ADVANCE_STAR_E_CH => MC_FILE_DIGIT_ADVANCE_STAR_E_CH,
		MC_FILE_ADDR_TRF_GATE_STAR_E_CH => MC_FILE_ADDR_TRF_GATE_STAR_E_CH,
		MC_E_CH_RBCI_RESET_1405 => MC_E_CH_RBCI_RESET_1405,
		PS_E_CH_NO_STATUS_ON => PS_E_CH_NO_STATUS_ON,
		PS_F_CH_2ND_ADDR_TRF => PS_F_CH_2ND_ADDR_TRF,
		PS_F_CH_END_OF_2ND_ADDR_TRF => PS_F_CH_END_OF_2ND_ADDR_TRF,
		MC_1301_START_GATE_STAR_F_CH => MC_1301_START_GATE_STAR_F_CH,
		MC_1405_START_GATE_STAR_F_CH => MC_1405_START_GATE_STAR_F_CH,
		MC_SEEK_TEST_OP_STAR_F_CH_TO_1405 => MC_SEEK_TEST_OP_STAR_F_CH_TO_1405,
		MC_FILE_STROBE_1ST_ADDR_STAR_F_CH => MC_FILE_STROBE_1ST_ADDR_STAR_F_CH,
		MC_FILE_STROBE_2ND_ADDR_STAR_F_CH => MC_FILE_STROBE_2ND_ADDR_STAR_F_CH,
		MC_FILE_DIGIT_ADVANCE_STAR_F_CH => MC_FILE_DIGIT_ADVANCE_STAR_F_CH,
		MC_FILE_ADDR_TRF_GATE_STAR_F_CH => MC_FILE_ADDR_TRF_GATE_STAR_F_CH,
		MC_SEEK_TEST_OP_STAR_F_CH_TO_1301 => MC_SEEK_TEST_OP_STAR_F_CH_TO_1301,
		MC_F_CH_RBCI_RESET_1405 => MC_F_CH_RBCI_RESET_1405,
		PS_F_CH_NO_TRANSFER_LATCH => PS_F_CH_NO_TRANSFER_LATCH,
		PS_F_CH_NO_STATUS_ON => PS_F_CH_NO_STATUS_ON,
		MS_F_CH_NO_TRANSFER_LATCH => MS_F_CH_NO_TRANSFER_LATCH,
		MY_MEM_AR_NOT_TTHP4B => MY_MEM_AR_NOT_TTHP4B,
		PS_ADDRESS_STOP => PS_ADDRESS_STOP,
		PS_OPTIONAL_SYNC_COND_CE => PS_OPTIONAL_SYNC_COND_CE,
		MC_UNIT_NU_0_TO_TAU_STAR_E_CH => MC_UNIT_NU_0_TO_TAU_STAR_E_CH,
		MC_SELECT_NO_0_TO_BUFFER => MC_SELECT_NO_0_TO_BUFFER,
		MC_SEEK_STAR_E_CH_1405 => MC_SEEK_STAR_E_CH_1405,
		MC_UNIT_NU_1_TO_TAU_STAR_E_CH => MC_UNIT_NU_1_TO_TAU_STAR_E_CH,
		MS_E_CH_UNIT_NUMBER_1 => MS_E_CH_UNIT_NUMBER_1,
		MC_SELECT_NO_1_TO_BUFFER => MC_SELECT_NO_1_TO_BUFFER,
		MC_SINGLE_REC_STAR_E_CH_TO_1405 => MC_SINGLE_REC_STAR_E_CH_TO_1405,
		MC_UNIT_NU_2_TO_TAU_STAR_E_CH => MC_UNIT_NU_2_TO_TAU_STAR_E_CH,
		MC_SELECT_NO_2_TO_BUFFER => MC_SELECT_NO_2_TO_BUFFER,
		MC_FULL_TRACK_WITHOUT_IA_STAR_1405_E_CH => MC_FULL_TRACK_WITHOUT_IA_STAR_1405_E_CH,
		MC_UNIT_NU_3_TO_TAU_STAR_E_CH => MC_UNIT_NU_3_TO_TAU_STAR_E_CH,
		MC_SELECT_NO_3_TO_BUFFER => MC_SELECT_NO_3_TO_BUFFER,
		MC_WRITE_CHECK_STAR_E_CH_TO_1405 => MC_WRITE_CHECK_STAR_E_CH_TO_1405,
		MC_UNIT_NU_4_TO_TAU_STAR_E_CH => MC_UNIT_NU_4_TO_TAU_STAR_E_CH,
		MC_WRITE_ADDR_STAR_E_CH_TO_1405 => MC_WRITE_ADDR_STAR_E_CH_TO_1405,
		MC_UNIT_NU_5_TO_TAU_STAR_E_CH => MC_UNIT_NU_5_TO_TAU_STAR_E_CH,
		MC_UNIT_NU_6_TO_TAU_STAR_E_CH => MC_UNIT_NU_6_TO_TAU_STAR_E_CH,
		MC_UNIT_NU_7_TO_TAU_STAR_E_CH => MC_UNIT_NU_7_TO_TAU_STAR_E_CH,
		MC_UNIT_NU_8_TO_TAU_STAR_E_CH => MC_UNIT_NU_8_TO_TAU_STAR_E_CH,
		MC_UNIT_NU_9_TO_TAU_STAR_E_CH => MC_UNIT_NU_9_TO_TAU_STAR_E_CH,
		MS_F_CH_UNIT_NUMBER_0 => MS_F_CH_UNIT_NUMBER_0,
		MC_UNIT_NU_0_TO_TAU_STAR_F_CH => MC_UNIT_NU_0_TO_TAU_STAR_F_CH,
		PS_F_CH_UNIT_NUMBER_0 => PS_F_CH_UNIT_NUMBER_0,
		MC_SEEK_STAR_F_CH_1405 => MC_SEEK_STAR_F_CH_1405,
		MC_UNIT_NU_1_TO_TAU_STAR_F_CH => MC_UNIT_NU_1_TO_TAU_STAR_F_CH,
		MS_F_CH_UNIT_NUMBER_1 => MS_F_CH_UNIT_NUMBER_1,
		PS_F_CH_UNIT_NUMBER_1 => PS_F_CH_UNIT_NUMBER_1,
		MC_SINGLE_REC_STAR_F_CH_TO_1405 => MC_SINGLE_REC_STAR_F_CH_TO_1405,
		MC_UNIT_NU_2_TO_TAU_STAR_F_CH => MC_UNIT_NU_2_TO_TAU_STAR_F_CH,
		MS_F_CH_UNIT_NUMBER_2 => MS_F_CH_UNIT_NUMBER_2,
		MC_FULL_TRACK_WITHOUT_IA_STAR_1405_F_CH => MC_FULL_TRACK_WITHOUT_IA_STAR_1405_F_CH,
		MS_F_CH_UNIT_NUMBER_3 => MS_F_CH_UNIT_NUMBER_3,
		MC_UNIT_NU_3_TO_TAU_STAR_F_CH => MC_UNIT_NU_3_TO_TAU_STAR_F_CH,
		MC_WRITE_CHECK_STAR_F_CH_TO_1405 => MC_WRITE_CHECK_STAR_F_CH_TO_1405,
		MC_UNIT_NU_4_TO_TAU_STAR_F_CH => MC_UNIT_NU_4_TO_TAU_STAR_F_CH,
		MC_WRITE_ADDR_STAR_F_CH_TO_1405 => MC_WRITE_ADDR_STAR_F_CH_TO_1405,
		MC_UNIT_NU_5_TO_TAU_STAR_F_CH => MC_UNIT_NU_5_TO_TAU_STAR_F_CH,
		MC_UNIT_NU_6_TO_TAU_STAR_F_CH => MC_UNIT_NU_6_TO_TAU_STAR_F_CH,
		MC_UNIT_NU_7_TO_TAU_STAR_F_CH => MC_UNIT_NU_7_TO_TAU_STAR_F_CH,
		MC_UNIT_NU_8_TO_TAU_STAR_F_CH => MC_UNIT_NU_8_TO_TAU_STAR_F_CH,
		MC_UNIT_NU_9_TO_TAU_STAR_F_CH => MC_UNIT_NU_9_TO_TAU_STAR_F_CH,
		PS_E_CH_OUTPUT_MODE => PS_E_CH_OUTPUT_MODE,
		PS_E_CH_INPUT_MODE => PS_E_CH_INPUT_MODE,
		MC_OUTPUT_MODE_TO_BUFFER => MC_OUTPUT_MODE_TO_BUFFER,
		MC_INPUT_MODE_TO_BUFFER => MC_INPUT_MODE_TO_BUFFER,
		MC_OUTPUT_OP_TO_1301_STAR_E_CH => MC_OUTPUT_OP_TO_1301_STAR_E_CH,
		MC_OUTPUT_OP_TO_1405_STAR_E_CH => MC_OUTPUT_OP_TO_1405_STAR_E_CH,
		MC_INPUT_OP_TO_1405_STAR_E_CH => MC_INPUT_OP_TO_1405_STAR_E_CH,
		MC_INPUT_OP_TO_1301_STAR_E_CH => MC_INPUT_OP_TO_1301_STAR_E_CH,
		MS_E_CH_MOVE_MODE => MS_E_CH_MOVE_MODE,
		MS_E_CH_LOAD_MODE => MS_E_CH_LOAD_MODE,
		MS_E_CH_INTERLOCK => MS_E_CH_INTERLOCK,
		MC_LOAD_MODE_TO_1301_STAR_E_CH => MC_LOAD_MODE_TO_1301_STAR_E_CH,
		MC_LOAD_MODE_TO_1405_STAR_E_CH => MC_LOAD_MODE_TO_1405_STAR_E_CH,
		PS_SET_E2_REG => PS_SET_E2_REG,
		PS_SET_E1_REG => PS_SET_E1_REG,
		PS_F_CH_OUTPUT_MODE => PS_F_CH_OUTPUT_MODE,
		PS_F_CH_INPUT_MODE => PS_F_CH_INPUT_MODE,
		MS_INPUT_MODE_F_CH => MS_INPUT_MODE_F_CH,
		MC_INPUT_OP_TO_1405_STAR_F_CH => MC_INPUT_OP_TO_1405_STAR_F_CH,
		MC_INPUT_OP_TO_1301_STAR_F_CH => MC_INPUT_OP_TO_1301_STAR_F_CH,
		MS_F_CH_INPUT_MODE => MS_F_CH_INPUT_MODE,
		MC_OUTPUT_OP_TO_1405_STAR_F_CH => MC_OUTPUT_OP_TO_1405_STAR_F_CH,
		MC_OUTPUT_OP_TO_1301_STAR_F_CH => MC_OUTPUT_OP_TO_1301_STAR_F_CH,
		MS_F_CH_LOAD_MODE => MS_F_CH_LOAD_MODE,
		PS_F_CH_INTERLOCK => PS_F_CH_INTERLOCK,
		MC_LOAD_MODE_TO_1301_STAR_F_CH => MC_LOAD_MODE_TO_1301_STAR_F_CH,
		MC_LOAD_MODE_TO_1405_STAR_F_CH => MC_LOAD_MODE_TO_1405_STAR_F_CH,
		PS_SET_F1_REG => PS_SET_F1_REG,
		PS_SET_F2_REG => PS_SET_F2_REG,
		TW_CPU_TO_F_CH_TAU_C_BIT => TW_CPU_TO_F_CH_TAU_C_BIT,
		MS_MASTER_ERROR => MS_MASTER_ERROR,
		MS_MASTER_ERROR_STAR_AUTS_STAR => MS_MASTER_ERROR_STAR_AUTS_STAR,
		PS_MASTER_ERROR => PS_MASTER_ERROR,
		PS_INTERRUPT_REQ_STAR_AUTS_STAR => PS_INTERRUPT_REQ_STAR_AUTS_STAR,
		PS_Y_OP_DOT_TEST_RESET => PS_Y_OP_DOT_TEST_RESET,
		PS_INTERRUPT_TEST_OP_CODE => PS_INTERRUPT_TEST_OP_CODE,
		MS_I_OP_DOT_I_CYCLE_DOT_C => MS_I_OP_DOT_I_CYCLE_DOT_C,
		PS_I_OP_DOT_I_CYCLE_DOT_E => PS_I_OP_DOT_I_CYCLE_DOT_E,
		MY_MEM_AR_NOT_TP0B_JRJ => MY_MEM_AR_NOT_TP0B_JRJ,
		MY_MEM_AR_NOT_TP1B_JRJ => MY_MEM_AR_NOT_TP1B_JRJ,
		MY_MEM_AR_NOT_TP2B_JRJ => MY_MEM_AR_NOT_TP2B_JRJ,
		MY_MEM_AR_NOT_TP8B_JRJ => MY_MEM_AR_NOT_TP8B_JRJ,
		MY_MEM_AR_NOT_TP4B_JRJ => MY_MEM_AR_NOT_TP4B_JRJ,
		MV_GATE_X_LSMS_YY00_09_A => MV_GATE_X_LSMS_YY00_09_A,
		MV_GATE_X_LSMS_YY00_09_B => MV_GATE_X_LSMS_YY00_09_B,
		MV_GATE_X_LSMS_YY10_19_A => MV_GATE_X_LSMS_YY10_19_A,
		MV_GATE_X_LSMS_YY10_19_B => MV_GATE_X_LSMS_YY10_19_B,
		MV_GATE_X_LSMS_YY20_29_A => MV_GATE_X_LSMS_YY20_29_A,
		MV_GATE_X_LSMS_YY20_29_B => MV_GATE_X_LSMS_YY20_29_B,
		MV_GATE_X_LSMS_YY30_39_A => MV_GATE_X_LSMS_YY30_39_A,
		MV_GATE_X_LSMS_YY30_39_B => MV_GATE_X_LSMS_YY30_39_B,
		MV_GATE_X_LSMS_YY40_49_A => MV_GATE_X_LSMS_YY40_49_A,
		MV_GATE_X_LSMS_YY40_49_B => MV_GATE_X_LSMS_YY40_49_B,
		MV_GATE_X_LSMS_YY50_59_A => MV_GATE_X_LSMS_YY50_59_A,
		MV_GATE_X_LSMS_YY50_59_B => MV_GATE_X_LSMS_YY50_59_B,
		MV_GATE_X_LSMS_YY60_60_A => MV_GATE_X_LSMS_YY60_60_A,
		MV_GATE_X_LSMS_YY60_69_B => MV_GATE_X_LSMS_YY60_69_B,
		MV_GATE_X_LSMS_YY70_79_A => MV_GATE_X_LSMS_YY70_79_A,
		MV_GATE_X_LSMS_YY70_79_B => MV_GATE_X_LSMS_YY70_79_B,
		MV_GATE_X_LSMS_YY80_89_A => MV_GATE_X_LSMS_YY80_89_A,
		MV_GATE_X_LSMS_YY80_89_B => MV_GATE_X_LSMS_YY80_89_B,
		MV_GATE_X_LSMS_YY90_99_A => MV_GATE_X_LSMS_YY90_99_A,
		MV_GATE_X_LSMS_YY90_99_B => MV_GATE_X_LSMS_YY90_99_B,
		MY_MEM_AR_NOT_HP8B_Z => MY_MEM_AR_NOT_HP8B_Z,
		MY_MEM_AR_NOT_HP4B_Z => MY_MEM_AR_NOT_HP4B_Z,
		MY_MEM_AR_NOT_HP2B_Z => MY_MEM_AR_NOT_HP2B_Z,
		MY_MEM_AR_NOT_HP1B_Z => MY_MEM_AR_NOT_HP1B_Z,
		MY_MEM_AR_NOT_HP0B_Z => MY_MEM_AR_NOT_HP0B_Z,
		MY_GATE_Y_LSMS_00_09XX_A => MY_GATE_Y_LSMS_00_09XX_A,
		MY_GATE_Y_LSMS_00_09XX_B => MY_GATE_Y_LSMS_00_09XX_B,
		MY_GATE_Y_LSMS_10_19XX_A => MY_GATE_Y_LSMS_10_19XX_A,
		MY_GATE_Y_LSMS_10_19XX_B => MY_GATE_Y_LSMS_10_19XX_B,
		MY_GATE_Y_LSMS_20_29XX_A => MY_GATE_Y_LSMS_20_29XX_A,
		MY_GATE_Y_LSMS_20_29XX_B => MY_GATE_Y_LSMS_20_29XX_B,
		MY_GATE_Y_LSMS_30_39XX_A => MY_GATE_Y_LSMS_30_39XX_A,
		MY_GATE_Y_LSMS_30_39XX_B => MY_GATE_Y_LSMS_30_39XX_B,
		MY_GATE_Y_LSMS_40_49XX_A => MY_GATE_Y_LSMS_40_49XX_A,
		MY_GATE_Y_LSMS_40_49XX_B => MY_GATE_Y_LSMS_40_49XX_B,
		MY_GATE_Y_LSMS_50_59XX_A => MY_GATE_Y_LSMS_50_59XX_A,
		MY_GATE_Y_LSMS_50_59XX_B => MY_GATE_Y_LSMS_50_59XX_B,
		MY_GATE_Y_LSMS_60_69XX_A => MY_GATE_Y_LSMS_60_69XX_A,
		MY_GATE_Y_LSMS_60_69XX_B => MY_GATE_Y_LSMS_60_69XX_B,
		MY_GATE_Y_LSMS_70_79XX_A => MY_GATE_Y_LSMS_70_79XX_A,
		MY_GATE_Y_LSMS_70_79XX_B => MY_GATE_Y_LSMS_70_79XX_B,
		MY_GATE_Y_LSMS_80_89XX_A => MY_GATE_Y_LSMS_80_89XX_A,
		MY_GATE_Y_LSMS_80_89XX_B => MY_GATE_Y_LSMS_80_89XX_B,
		MY_GATE_Y_LSMS_90_99XX_A => MY_GATE_Y_LSMS_90_99XX_A,
		MY_GATE_Y_LSMS_90_99XX_B => MY_GATE_Y_LSMS_90_99XX_B,
		MY_X_RD_1 => MY_X_RD_1,
		MY_B_DATA_REG_RESET => MY_B_DATA_REG_RESET,
		PY_START_READ => PY_START_READ,
		MY_X_WR_1 => MY_X_WR_1,
		PY_START_WRITE => PY_START_WRITE,
		MY_LOAD_MEMORY_Z => MY_LOAD_MEMORY_Z,
		MY_REGEN_MEMORY_Z => MY_REGEN_MEMORY_Z,
		PY_1ST_CHECK_TEST_Z => PY_1ST_CHECK_TEST_Z,
		PY_2ND_CHECK_TEST_Z => PY_2ND_CHECK_TEST_Z,
		PY_COMPUTER_RESET => PY_COMPUTER_RESET,
		PS_DENSITY_SW_556_OR_200_CH_1 => PS_DENSITY_SW_556_OR_200_CH_1,
		PS_DENSITY_SW_800_OR_556_CH_1 => PS_DENSITY_SW_800_OR_556_CH_1,
		PS_DENSITY_SW_556_OR_200_CH_2 => PS_DENSITY_SW_556_OR_200_CH_2,
		PS_DENSITY_SW_800_OR_556_CH_2 => PS_DENSITY_SW_800_OR_556_CH_2,
		MC_DISK_WRITE_NORMAL_STAR_F_CH => MC_DISK_WRITE_NORMAL_STAR_F_CH,
		MC_DISK_WRITE_NORMAL_STAR_E_CH => MC_DISK_WRITE_NORMAL_STAR_E_CH,
		MS_CONSOLE_INHIBIT_AR_RO => MS_CONSOLE_INHIBIT_AR_RO,
		PS_LOGIC_STEP_OR_IE_OR_STG_CY_STAR_AUTS_STAR => PS_LOGIC_STEP_OR_IE_OR_STG_CY_STAR_AUTS_STAR,
		PS_CONS_CLOCK_1_POS => PS_CONS_CLOCK_1_POS,
		PS_CONS_CLOCK_3_POS_1 => PS_CONS_CLOCK_3_POS_1,
		MS_CONSOLE_CHECK_STROBE => MS_CONSOLE_CHECK_STROBE,
		PW_UPPER_CASE_SHIFT_SOLENOID => PW_UPPER_CASE_SHIFT_SOLENOID,
		PW_LOWER_CASE_SHIFT_SOLENOID => PW_LOWER_CASE_SHIFT_SOLENOID,
		PW_CONS_PRINTER_R1_SOLENOID => PW_CONS_PRINTER_R1_SOLENOID,
		PW_CONS_PRINTER_R2A_SOLENOID => PW_CONS_PRINTER_R2A_SOLENOID,
		PW_CONS_PRINTER_R2_SOLENOID => PW_CONS_PRINTER_R2_SOLENOID,
		PW_CONS_PRINTER_R5_SOLENOID => PW_CONS_PRINTER_R5_SOLENOID,
		PW_CONS_PRINTER_T1_SOLENOID => PW_CONS_PRINTER_T1_SOLENOID,
		PW_CONS_PRINTER_T2_SOLENOID => PW_CONS_PRINTER_T2_SOLENOID,
		PW_CONS_PRINTER_CHK_SOLENOID => PW_CONS_PRINTER_CHK_SOLENOID,
		PW_BACKSPACE_SOLENOID => PW_BACKSPACE_SOLENOID,
		PW_CARRIAGE_RETURN_SOLENOID => PW_CARRIAGE_RETURN_SOLENOID,
		PW_SPACE_SOLENOID => PW_SPACE_SOLENOID,
		MW_KEYBOARD_LOCK_SOLENOID => MW_KEYBOARD_LOCK_SOLENOID,
		LAMP_15A1K24 => LAMP_15A1K24,
		LAMP_15A1A16 => LAMP_15A1A16,
		LAMP_15A1C16 => LAMP_15A1C16,
		LAMP_15A1E16 => LAMP_15A1E16,
		LAMP_15A1F16 => LAMP_15A1F16,
		LAMP_15A1K23 => LAMP_15A1K23,
		LAMP_15A1H14 => LAMP_15A1H14,
		LAMP_15A1K14 => LAMP_15A1K14,
		LAMP_15A1H16 => LAMP_15A1H16,
		LAMP_15A1K15 => LAMP_15A1K15,
		LAMP_15A1H15 => LAMP_15A1H15,
		LAMP_15A1E17 => LAMP_15A1E17,
		LAMP_15A1F17 => LAMP_15A1F17,
		LAMP_15A1A17 => LAMP_15A1A17,
		LAMP_15A1C17 => LAMP_15A1C17,
		LAMP_15A1H17 => LAMP_15A1H17,
		LAMP_15A1B14 => LAMP_15A1B14,
		LAMP_15A1K16 => LAMP_15A1K16,
		LAMP_15A1C15 => LAMP_15A1C15,
		LAMP_15A1K17 => LAMP_15A1K17,
		LAMP_15A1E21 => LAMP_15A1E21,
		LAMP_11C8K07 => LAMP_11C8K07,
		LAMP_11C8J07 => LAMP_11C8J07,
		LAMP_11C8H07 => LAMP_11C8H07,
		LAMP_11C8G07 => LAMP_11C8G07,
		LAMP_11C8F07 => LAMP_11C8F07,
		LAMP_11C8A02 => LAMP_11C8A02,
		LAMP_11C8B02 => LAMP_11C8B02,
		LAMP_11C8A01 => LAMP_11C8A01,
		LAMP_11C8B01 => LAMP_11C8B01,
		LAMP_15A1K20 => LAMP_15A1K20,
		LAMP_11C8C14 => LAMP_11C8C14,
		LAMP_11C8D14 => LAMP_11C8D14,
		LAMP_11C8E14 => LAMP_11C8E14,
		LAMP_11C8F14 => LAMP_11C8F14,
		LAMP_15A1E14 => LAMP_15A1E14,
		LAMP_15A1F14 => LAMP_15A1F14,
		LAMP_15A1A14 => LAMP_15A1A14,
		LAMP_15A1E15 => LAMP_15A1E15,
		LAMP_15A1F15 => LAMP_15A1F15,
		LAMP_15A1A15 => LAMP_15A1A15,
		LAMP_15A1C11 => LAMP_15A1C11,
		LAMP_15A1K12 => LAMP_15A1K12,
		LAMP_15A1F11 => LAMP_15A1F11,
		LAMP_15A1E11 => LAMP_15A1E11,
		LAMP_15A1A11 => LAMP_15A1A11,
		LAMP_15A1G08 => LAMP_15A1G08,
		LAMP_15A1H08 => LAMP_15A1H08,
		LAMP_15A1J08 => LAMP_15A1J08,
		LAMP_15A1K08 => LAMP_15A1K08,
		LAMP_15A1H12 => LAMP_15A1H12,
		LAMP_15A1F12 => LAMP_15A1F12,
		LAMP_15A1A12 => LAMP_15A1A12,
		LAMP_15A1E12 => LAMP_15A1E12,
		LAMP_15A1C12 => LAMP_15A1C12,
		LAMP_11C8A12 => LAMP_11C8A12,
		LAMP_15A1A19 => LAMP_15A1A19,
		LAMP_11C8A13 => LAMP_11C8A13,
		LAMP_15A1C19 => LAMP_15A1C19,
		LAMP_15A1B19 => LAMP_15A1B19,
		LAMP_11C8A10 => LAMP_11C8A10,
		LAMP_15A1H20 => LAMP_15A1H20,
		LAMP_15A1H19 => LAMP_15A1H19,
		LAMP_15A1F19 => LAMP_15A1F19,
		LAMP_11C8A07 => LAMP_11C8A07,
		LAMP_15A1E20 => LAMP_15A1E20,
		LAMP_15A1F20 => LAMP_15A1F20,
		LAMP_15A1C20 => LAMP_15A1C20,
		LAMP_15A1V01 => LAMP_15A1V01,
		LAMP_15A1B15 => LAMP_15A1B15,
		LAMP_15A1W01 => LAMP_15A1W01,
		LAMP_15A1W04 => LAMP_15A1W04,
		LAMP_15A2K03 => LAMP_15A2K03,
		LAMP_15A2K05 => LAMP_15A2K05,
		LAMP_15A1K22 => LAMP_15A1K22,
		LAMP_15A1K21 => LAMP_15A1K21,
		LAMP_11C8A04 => LAMP_11C8A04,
		LAMP_11C8B05 => LAMP_11C8B05,
		LAMP_11C8B04 => LAMP_11C8B04,
		LAMP_11C8A05 => LAMP_11C8A05,
		PS_I_RING_HDL_BUS => PS_I_RING_HDL_BUS,
		PS_OP_MOD_REG_BUS => PS_OP_MOD_REG_BUS,
		PS_OP_MOD_REG_NOT_BUS => PS_OP_MOD_REG_NOT_BUS,
		MY_MEM_AR_NOT_UP_BUS => MY_MEM_AR_NOT_UP_BUS,
		MY_MEM_AR_UP_BUS => MY_MEM_AR_UP_BUS,
		MY_MEM_AR_NOT_TP_BUS => MY_MEM_AR_NOT_TP_BUS,
		MY_MEM_AR_TP_BUS => MY_MEM_AR_TP_BUS,
		MY_MEM_AR_NOT_HP_BUS => MY_MEM_AR_NOT_HP_BUS,
		MY_MEM_AR_HP_BUS => MY_MEM_AR_HP_BUS,
		MY_MEM_AR_NOT_THP_BUS => MY_MEM_AR_NOT_THP_BUS,
		MY_MEM_AR_THP_BUS => MY_MEM_AR_THP_BUS,
		MY_MEM_AR_TTHP_BUS => MY_MEM_AR_TTHP_BUS,
		PS_A_CH_NOT_BUS => PS_A_CH_NOT_BUS,
		MY_ASSEMBLY_CH_BUS => MY_ASSEMBLY_CH_BUS,
		MC_E_CH_UNIT_STAR_1301_STAR_BUS => MC_E_CH_UNIT_STAR_1301_STAR_BUS,
		PS_E_CH_U_SEL_REG_NOT_BUS => PS_E_CH_U_SEL_REG_NOT_BUS,
		PS_E_CH_U_SEL_REG_BUS => PS_E_CH_U_SEL_REG_BUS,
		MC_F_CH_UNIT_STAR_1301_STAR_BUS => MC_F_CH_UNIT_STAR_1301_STAR_BUS,
		PS_F_CH_U_SEL_REG_NOT_BUS => PS_F_CH_U_SEL_REG_NOT_BUS,
		PS_F_CH_U_SEL_REG_BUS => PS_F_CH_U_SEL_REG_BUS,
		PS_E2_REG_BUS => PS_E2_REG_BUS,
		MC_CPU_TO_E_CH_TAU_BUS => MC_CPU_TO_E_CH_TAU_BUS,
		MC_CPU_TO_I_O_SYNC_BUS => MC_CPU_TO_I_O_SYNC_BUS,
		MC_CPU_TO_E_CH_1301_BUS => MC_CPU_TO_E_CH_1301_BUS,
		MC_CPU_TO_E_CH_1405_BUS => MC_CPU_TO_E_CH_1405_BUS,
		PS_F2_REG_BUS => PS_F2_REG_BUS,
		MS_F2_REG_BUS => MS_F2_REG_BUS,
		MC_CPU_TO_F_CH_TAU_BUS => MC_CPU_TO_F_CH_TAU_BUS,
		MC_CPU_TO_F_CH_1301_BUS => MC_CPU_TO_F_CH_1301_BUS,
		MC_CPU_TO_F_CH_1405_BUS => MC_CPU_TO_F_CH_1405_BUS,
		PV_X_LSMS_DRV_IN_BUS => PV_X_LSMS_DRV_IN_BUS,
		PV_Y_LSMS_DRV_IN_BUS => PV_Y_LSMS_DRV_IN_BUS,
		MV_INH_CHAR_0_D1_BUS => MV_INH_CHAR_0_D1_BUS,
		MV_INH_CHAR_0_B1_BUS => MV_INH_CHAR_0_B1_BUS,
		MV_INH_CHAR_1_D1_BUS => MV_INH_CHAR_1_D1_BUS,
		MV_INH_CHAR_1_B1_BUS => MV_INH_CHAR_1_B1_BUS,
		MV_INH_CHAR_2_D1_BUS => MV_INH_CHAR_2_D1_BUS,
		MV_INH_CHAR_2_B1_BUS => MV_INH_CHAR_2_B1_BUS,
		MV_INH_CHAR_3_D1_BUS => MV_INH_CHAR_3_D1_BUS,
		MV_INH_CHAR_3_B1_BUS => MV_INH_CHAR_3_B1_BUS,
		MY_ASSEMBLY_CH_Z_BUS => MY_ASSEMBLY_CH_Z_BUS,
		LAMPS_LOGIC_GATE_RING => LAMPS_LOGIC_GATE_RING,
		LAMPS_IRING => LAMPS_IRING,
		LAMPS_CYCLE_CE => LAMPS_CYCLE_CE,
		LAMPS_CYCLE_CONSOLE => LAMPS_CYCLE_CONSOLE,
		LAMPS_SCAN => LAMPS_SCAN,
		LAMPS_OPREG_CE => LAMPS_OPREG_CE,
		LAMPS_OPMOD_CE => LAMPS_OPMOD_CE,
		LAMPS_MAR_UP => LAMPS_MAR_UP,
		LAMPS_MAR_TP => LAMPS_MAR_TP,
		LAMPS_MAR_HP => LAMPS_MAR_HP,
		LAMPS_MAR_THP => LAMPS_MAR_THP,
		LAMPS_MAR_TTHP => LAMPS_MAR_TTHP,
		LAMPS_ARING => LAMPS_ARING,
		LAMPS_B_CH => LAMPS_B_CH,
		LAMPS_A_CH => LAMPS_A_CH,
		LAMPS_ASSM_CH_NOT => LAMPS_ASSM_CH_NOT,
		LAMPS_ASSM_CH => LAMPS_ASSM_CH);

-- START USER TEST BENCH PROCESS

-- The user test bench code MUST be placed between the
-- line that starts with the first line of text that
-- begins with "-- START USERS TEST BENCH PROCESS" 
-- and ends with "-- END"
-- This text is preserved when the IBM1410SMS applciation
-- regenerates a test bench

-- Instantiate Memory

memory: IBM1410Memory 
   Port map(
      FPGA_CLK => FPGA_CLK,
      MY_X_RD_1 => MY_X_RD_1,
      MY_X_WR_1 => MY_X_WR_1, 
      -- MY_X_WR_1 => '1',  -- disable writes for now
      MY_MEM_AR_NOT_UP_BUS => MY_MEM_AR_NOT_UP_BUS,
      MY_MEM_AR_NOT_TP_BUS => MY_MEM_AR_NOT_TP_BUS,
      MY_MEM_AR_NOT_HP_BUS => MY_MEM_AR_NOT_HP_BUS,
      MY_MEM_AR_NOT_THP_BUS => MY_MEM_AR_NOT_THP_BUS,
      MY_MEM_AR_NOT_TTHP_BUS => LOCAL_MY_MEM_AR_NOT_TTHP_BUS,
      MV_INH_CHAR_0_B1_BUS => MV_INH_CHAR_0_B1_BUS,
      MV_INH_CHAR_0_D1_BUS => MV_INH_CHAR_0_D1_BUS,
      MV_INH_CHAR_1_B1_BUS => MV_INH_CHAR_1_B1_BUS,
      MV_INH_CHAR_1_D1_BUS => MV_INH_CHAR_1_D1_BUS,
      MV_INH_CHAR_2_B1_BUS => MV_INH_CHAR_2_B1_BUS,
      MV_INH_CHAR_2_D1_BUS => MV_INH_CHAR_2_D1_BUS,
      MV_INH_CHAR_3_B1_BUS => MV_INH_CHAR_3_B1_BUS,
      MV_INH_CHAR_3_D1_BUS => MV_INH_CHAR_3_D1_BUS,
      PV_SENSE_CHAR_0_BUS => PV_SENSE_CHAR_0_B1_BUS,
      PV_SENSE_CHAR_1_BUS => PV_SENSE_CHAR_1_B1_BUS,
      PV_SENSE_CHAR_2_BUS => PV_SENSE_CHAR_2_B1_BUS,
      PV_SENSE_CHAR_3_BUS => PV_SENSE_CHAR_3_B1_BUS,

      IBM1410_DIRECT_MEMORY_ADDRESS => IBM1410_DIRECT_MEMORY_ADDRESS,
      IBM1410_DIRECT_MEMORY_ENABLE => IBM1410_DIRECT_MEMORY_ENABLE,
      IBM1410_DIRECT_MEMORY_WRITE_ENABLE => IBM1410_DIRECT_MEMORY_WRITE_ENABLE,
      IBM1410_DIRECT_MEMORY_WRITE_DATA => IBM1410_DIRECT_MEMORY_WRITE_DATA,
      IBM1410_DIRECT_MEMORY_READ_DATA_0 => IBM1410_DIRECT_MEMORY_READ_DATA_0,
      IBM1410_DIRECT_MEMORY_READ_DATA_1 => IBM1410_DIRECT_MEMORY_READ_DATA_1,
      IBM1410_DIRECT_MEMORY_READ_DATA_2 => IBM1410_DIRECT_MEMORY_READ_DATA_2,
      IBM1410_DIRECT_MEMORY_READ_DATA_3 => IBM1410_DIRECT_MEMORY_READ_DATA_3
       );

-- Instantiate the console typewriter

   ConsoleTypewriter: IBM1410ConsoleTypewriter
   -- generic map(MULTIPLIER => 100) -- 100x speed, so 10us == 1ms
   port map(
      FPGA_CLK => FPGA_CLK,
      UART_RESET => UART_RESET,
      SLOW_TYPING => SLOW_TYPING,
      
      PW_CONS_PRINTER_R1_SOLENOID => PW_CONS_PRINTER_R1_SOLENOID,      
      PW_CONS_PRINTER_R2_SOLENOID => PW_CONS_PRINTER_R2_SOLENOID,
      PW_CONS_PRINTER_R2A_SOLENOID => PW_CONS_PRINTER_R2A_SOLENOID,
      PW_CONS_PRINTER_R5_SOLENOID => PW_CONS_PRINTER_R5_SOLENOID,
      PW_CONS_PRINTER_T1_SOLENOID => PW_CONS_PRINTER_T1_SOLENOID,
      PW_CONS_PRINTER_T2_SOLENOID => PW_CONS_PRINTER_T2_SOLENOID,

      PW_UPPER_CASE_SHIFT_SOLENOID => PW_UPPER_CASE_SHIFT_SOLENOID,
      PW_LOWER_CASE_SHIFT_SOLENOID => PW_LOWER_CASE_SHIFT_SOLENOID,
      PW_BACKSPACE_SOLENOID => PW_BACKSPACE_SOLENOID,
      PW_SPACE_SOLENOID => PW_SPACE_SOLENOID,
      PW_CARRIAGE_RETURN_SOLENOID => PW_CARRIAGE_RETURN_SOLENOID,      

      MW_KEYBOARD_LOCK_SOLENOID => MW_KEYBOARD_LOCK_SOLENOID,
      PW_CONS_PRINTER_CHK_SOLENOID => PW_CONS_PRINTER_CHK_SOLENOID,
      
      MV_CONS_PRINTER_C1_CAM_NO => MV_CONS_PRINTER_C1_CAM_NO,
      MV_CONS_PRINTER_C1_CAM_NC => MV_CONS_PRINTER_C1_CAM_NC,
      MV_CONS_PRINTER_C2_CAM_NC => MV_CONS_PRINTER_C2_CAM_NC,
      MV_CONS_PRINTER_C2_CAM_NO => MV_CONS_PRINTER_C2_CAM_NO,
      MV_CONS_PRINTER_C3_OR_C4_NO => MV_CONS_PRINTER_C3_OR_C4_NO,

      MV_CONS_PRINTER_SPACE_NO => MV_CONS_PRINTER_SPACE_NO,
      
      MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC => MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC,
      MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO => MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO,
      MB_CONS_PRINTER_EVEN_BIT_CHECK => MB_CONS_PRINTER_EVEN_BIT_CHECK,
      MV_CONS_PRINTER_ODD_BIT_CHECK => MV_CONS_PRINTER_ODD_BIT_CHECK, 
      MV_KEYBOARD_LOCK_MODE_STAR_NO => MV_KEYBOARD_LOCK_MODE_STAR_NO, 
      MV_KEYBOARD_UNLOCK_MODE => MV_KEYBOARD_UNLOCK_MODE,
      
      MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO => MV_CONS_INQUIRY_REQUEST_KEY_STAR_NO,
      MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO => MV_CONS_INQUIRY_RELEASE_KEY_STAR_NO,
      PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC => PV_CONS_INQUIRY_CANCEL_KEY_STAR_NC,
      MV_CONS_PRINTER_LAST_COLUMN_SET => MV_CONS_PRINTER_LAST_COLUMN_SET,
      
      MV_CONS_PRTR_TO_CPU_BUS => MV_CONS_PRTR_TO_CPU_BUS,
      MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO => MB_CONS_PRTR_WM_INPUT_STAR_WM_T_NO,
      MV_CONSOLE_C_INPUT_STAR_CHK_OP => MV_CONSOLE_C_INPUT_STAR_CHK_OP,
      IBM1410_CONSOLE_XMT_CHAR => IBM1410_CONSOLE_XMT_CHAR,
      IBM1410_CONSOLE_XMT_STROBE => IBM1410_CONSOLE_XMT_STROBE,
      IBM1410_CONSOLE_INPUT_FIFO_WRITE_ENABLE => IBM1410_CONSOLE_INPUT_FIFO_WRITE_ENABLE,
      IBM1410_CONSOLE_INPUT_FIFO_WRITE_DATA => IBM1410_CONSOLE_INPUT_FIFO_WRITE_DATA
);

-- Instantiate the Channel 1 TAU Adapter - try shorter time for cycle length....

   TAU_CHANNEL_1: IBM1410TapeAdapterUnit
   generic map (
       CHANNEL_STROBE_LENGTH => 25,   -- Reduced from default of 100 (1us => 250ns)  
       CHANNEL_CYCLE_LENGTH => 1120,
       TAU_OUTPUT_FIFO_SIZE => 2)     -- Test with a really small internal FIFO
   port map (
       FPGA_CLK => FPGA_CLK,
       MC_COMP_RESET_TO_TAPE => MC_COMP_RESET_TO_TAPE_STAR_E_CH,
        
       -- TAU Input Signals From CPU
       
       MC_CPU_TO_TAU_BUS => MC_CPU_TO_E_CH_TAU_BUS,       
       
       MC_WRITE_TAPE_CALL => MC_WRITE_TAPE_CALL_STAR_E_CH,
       MC_WRITE_TAPE_MK_CALL => MC_WRITE_TAPE_MK_CALL_STAR_E_CH,
       MC_ERASE_CALL => MC_ERASE_CALL_STAR_E_CH,
       MC_REWIND_UNLOAD => MC_REWIND_UNLOAD_STAR_E_CH,
       MC_REWIND_CALL => MC_REWIND_CALL_STAR_E_CH,
       MC_BACKSPACE_CALL => MC_BACKSPACE_CALL_STAR_E_CH,
       MC_TURN_OFF_TAPE_IND => MC_TURN_OFF_TAPE_IND_STAR_E_CH,
       MC_RESET_TAPE_SEL_REG => MC_RESET_TAPE_SEL_REG_STAR_E_CH,
       MC_SET_TAPE_SEL_REG => MC_SET_TAPE_SEL_REG_STAR_E_CH,
       MC_DISCONNECT_CALL => MC_DISCONNECT_CALL_STAR_E_CH,
       MC_READ_TAPE_CALL => MC_READ_TAPE_CALL_STAR_E_CH,
       MC_ODD_PARITY_TO_TAPE => MC_ODD_PARITY_TO_TAPE_STAR_E_CH,
       
       MC_UNIT_NU_0_TO_TAU => MC_UNIT_NU_0_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_1_TO_TAU => MC_UNIT_NU_1_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_2_TO_TAU => MC_UNIT_NU_2_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_3_TO_TAU => MC_UNIT_NU_3_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_4_TO_TAU => MC_UNIT_NU_4_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_5_TO_TAU => MC_UNIT_NU_5_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_6_TO_TAU => MC_UNIT_NU_6_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_7_TO_TAU => MC_UNIT_NU_7_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_8_TO_TAU => MC_UNIT_NU_8_TO_TAU_STAR_E_CH, 
       MC_UNIT_NU_9_TO_TAU => MC_UNIT_NU_9_TO_TAU_STAR_E_CH, 
            
       -- TAU Output Signals to CPU
       
       MC_TAU_TO_CPU_BUS => MC_E_CH_TAU_TO_CPU_BUS,

       MC_WRITE_CONDITION => MC_WRITE_CONDITION_STAR_E_CH,
       MC_SELECT_AND_REWIND => MC_SELECT_AND_REWIND_STAR_E_CH,
       MC_SELECT_AT_LOAD_POINT => MC_SELECT_AT_LOAD_POINT_STAR_E_CH,
       MC_SEL_OR_TAPE_IND_ON => MC_SEL_OR_TAPE_IND_ON_CH_1,
       
       MC_TAPE_READ_STROBE => MC_TAPE_READ_STROBE,
       MC_TAPE_BUSY => MC_TAPE_BUSY,
       MC_TAPE_ERROR => MC_TAPE_ERROR, 
       MC_TAPE_READY => MC_TAPE_READY,
       MC_TAPE_WRITE_STROBE => MC_TAPE_WRITE_STROBE,
       MC_TAPE_IN_PROCESS => MC_TAPE_IN_PROCESS,
      
       -- TAU to PC Support System
       
       IBM1410_TAU_XMT_UART_DATA => IBM1410_TAU_XMT_UART_DATA,
       IBM1410_TAU_XMT_UART_REQUEST => IBM1410_TAU_XMT_UART_REQUEST,
       IBM1410_TAU_XMT_UART_GRANT => IBM1410_TAU_XMT_UART_GRANT,
              
       -- PC Support System to TAU 
       
       IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE => IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE,
       IBM1410_TAU_INPUT_FIFO_WRITE_DATA => IBM1410_TAU_INPUT_FIFO_WRITE_DATA
   );

-- Instantiate the Channel 2 TAU Adapter - try shorter time for cycle length....

   TAU_CHANNEL_2: IBM1410TapeAdapterUnit
   generic map (
       CHANNEL_STROBE_LENGTH => 25,  -- Reduced from default of 100 (1us => 250ns)  
       CHANNEL_CYCLE_LENGTH => 1120, -- Reduced from default of 11.5 us
       TAU_OUTPUT_FIFO_SIZE => 2)     -- Test with a really small internal FIFO       
   port map (
       FPGA_CLK => FPGA_CLK,
       MC_COMP_RESET_TO_TAPE => MC_COMP_RESET_TO_TAPE_STAR_F_CH,
        
       -- TAU Input Signals From CPU
       
       MC_CPU_TO_TAU_BUS => MC_CPU_TO_F_CH_TAU_BUS,       
       
       MC_WRITE_TAPE_CALL => MC_WRITE_TAPE_CALL_STAR_F_CH,
       MC_WRITE_TAPE_MK_CALL => MC_WRITE_TAPE_MK_CALL_STAR_F_CH,
       MC_ERASE_CALL => MC_ERASE_CALL_STAR_F_CH,
       MC_REWIND_UNLOAD => MC_REWIND_UNLOAD_STAR_F_CH,
       MC_REWIND_CALL => MC_REWIND_CALL_STAR_F_CH,
       MC_BACKSPACE_CALL => MC_BACKSPACE_CALL_STAR_F_CH,
       MC_TURN_OFF_TAPE_IND => MC_TURN_OFF_TI_STAR_F_CH,
       MC_RESET_TAPE_SEL_REG => MC_RESET_TAPE_SEL_REG_STAR_CH_F,
       MC_SET_TAPE_SEL_REG => MC_SET_TAPE_SEL_REG_STAR_CH_F,
       MC_DISCONNECT_CALL => MC_DISCONNECT_CALL_STAR_F_CH,
       MC_READ_TAPE_CALL => MC_READ_TAPE_CALL_STAR_F_CH,
       MC_ODD_PARITY_TO_TAPE => MC_ODD_PARITY_TO_TAPE_STAR_F_CH,
       
       MC_UNIT_NU_0_TO_TAU => MC_UNIT_NU_0_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_1_TO_TAU => MC_UNIT_NU_1_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_2_TO_TAU => MC_UNIT_NU_2_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_3_TO_TAU => MC_UNIT_NU_3_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_4_TO_TAU => MC_UNIT_NU_4_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_5_TO_TAU => MC_UNIT_NU_5_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_6_TO_TAU => MC_UNIT_NU_6_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_7_TO_TAU => MC_UNIT_NU_7_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_8_TO_TAU => MC_UNIT_NU_8_TO_TAU_STAR_F_CH, 
       MC_UNIT_NU_9_TO_TAU => MC_UNIT_NU_9_TO_TAU_STAR_F_CH, 
            
       -- TAU Output Signals to CPU
       
       MC_TAU_TO_CPU_BUS => MC_F_CH_TAU_TO_CPU_BUS,

       MC_WRITE_CONDITION => MC_WRITE_CONDITION_STAR_F_CH,
       MC_SELECT_AND_REWIND => MC_SELECT_AND_REWIND_STAR_F_CH,
       MC_SELECT_AT_LOAD_POINT => MC_SELECT_AT_LOAD_POINT_STAR_F_CH,
       MC_SEL_OR_TAPE_IND_ON => MC_SEL_OR_TI_ON_CH_2,
       
       MC_TAPE_READ_STROBE => MC_TAPE_READ_STROBE_F_CH_JRJ,
       MC_TAPE_BUSY => MC_TAPE_BUSY_F_CH_JRJ,
       MC_TAPE_ERROR => MC_TAPE_ERROR_F_CH_JRJ, 
       MC_TAPE_READY => MC_TAPE_READY_F_CH_JRJ,
       MC_TAPE_WRITE_STROBE => MC_TAPE_WRITE_STROBE_F_CH_JRJ,
       MC_TAPE_IN_PROCESS => MC_TAPE_IN_PROCESS_F_CH_JRJ,
      
       -- TAU to PC Support System
       
       IBM1410_TAU_XMT_UART_DATA => IBM1410_TAU_XMT_UART_DATA_F_CH,
       IBM1410_TAU_XMT_UART_REQUEST => IBM1410_TAU_XMT_UART_REQUEST_F_CH, 
       IBM1410_TAU_XMT_UART_GRANT => IBM1410_TAU_XMT_UART_GRANT_F_CH,       
              
       -- PC Support System to TAU 
       
       IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE => IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH,
       IBM1410_TAU_INPUT_FIFO_WRITE_DATA => IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH
   );


-- 
-- TestBenchFPGAClock.vhdl
--
-- Process to simulate the FPGA clock for a VHDL test bench
--

fpga_clk_process: process

   constant clk_period : time := 10 ns;

   begin
      fpga_clk <= '0';
      wait for clk_period / 2;
      fpga_clk <= '1';
      wait for clk_period / 2;
   end process;

--
---- End of TestBenchFPGAClock.vhdl

   -- Ten Thousands Position of Memory address
   
   LOCAL_MY_MEM_AR_NOT_TTHP_BUS <= not MY_MEM_AR_TTHP_BUS;

   -- FPGA_CLK <= CLK;
   
   LED(9 downto 0) <= LAMPS_LOGIC_GATE_RING;
   
   LED(15) <= LAMP_15A1K24; -- Stop
   
   -- A channel Validity, B Channel Validity, Assembly Channel Validity
   -- Address Channel validity, Address Exit Channel validity
   
   LED(14) <= LAMP_15A1A19 or LAMP_15A1C19 or LAMP_15A1B19 or 
      LAMP_15A1F19 or LAMP_15A1H19;
   
   -- Register Set checks
   
   LED(13) <= LAMP_15A1V01 or LAMP_15A1C20 or LAMP_15A1E20 or LAMP_15A1F20;
   
   -- Character Select Checks
   
   LED(12) <= LAMP_15A1H20 or LAMP_15A1K20;
   
   LED(11) <= LAMP_15A1W04; -- Instruction Check
   LED(10) <= LAMP_15A1B15; -- Address Check   
   
-- Signal "copies"

   PV_SENSE_CHAR_0_B2_BUS <= PV_SENSE_CHAR_0_B1_BUS;
   PV_SENSE_CHAR_0_D1_BUS <= PV_SENSE_CHAR_0_B1_BUS;
   PV_SENSE_CHAR_0_D2_BUS <= PV_SENSE_CHAR_0_B1_BUS;

   PV_SENSE_CHAR_1_B2_BUS <= PV_SENSE_CHAR_1_B1_BUS;
   PV_SENSE_CHAR_1_D1_BUS <= PV_SENSE_CHAR_1_B1_BUS;
   PV_SENSE_CHAR_1_D2_BUS <= PV_SENSE_CHAR_1_B1_BUS;

   PV_SENSE_CHAR_2_B2_BUS <= PV_SENSE_CHAR_2_B1_BUS;
   PV_SENSE_CHAR_2_D1_BUS <= PV_SENSE_CHAR_2_B1_BUS;
   PV_SENSE_CHAR_2_D2_BUS <= PV_SENSE_CHAR_2_B1_BUS;

   PV_SENSE_CHAR_3_B2_BUS <= PV_SENSE_CHAR_3_B1_BUS;
   PV_SENSE_CHAR_3_D1_BUS <= PV_SENSE_CHAR_3_B1_BUS;
   PV_SENSE_CHAR_3_D2_BUS <= PV_SENSE_CHAR_3_B1_BUS;
   
   SWITCH_ROT_STOR_SCAN_DK3 <= SWITCH_ROT_STOR_SCAN_DK1;
   SWITCH_ROT_STOR_SCAN_DK4 <= SWITCH_ROT_STOR_SCAN_DK1;
   SWITCH_ROT_STOR_SCAN_DK5 <= SWITCH_ROT_STOR_SCAN_DK1;
   SWITCH_ROT_STOR_SCAN_DK6 <= SWITCH_ROT_STOR_SCAN_DK1(5 downto 0); -- Need to fix switch
   
   SWITCH_ROT_CYCLE_CTRL_DK2 <= SWITCH_ROT_CYCLE_CTRL_DK1(5 downto 0); -- Need to fix switch

   SWITCH_ROT_CHECK_CTRL_DK2 <= SWITCH_ROT_CHECK_CTRL_DK1(5 downto 0);

   SWITCH_ROT_MODE_SW_DK1 <= SWITCH_ROT_MODE_SW_DK;
   
   -- MV_CONS_PRINTER_C2_CAM_NO <= not MV_CONS_PRINTER_C2_CAM_NC;
   -- MV_CONS_PRINTER_C1_CAM_NO <= not MV_CONS_PRINTER_C1_CAM_NC;
   
   -- Parity should be odd.  These signals are active LOW
   -- Valid any time solenoids are active (or not).
   
   unlatchedConsoleParity <=
      PW_CONS_PRINTER_R1_SOLENOID xor
      PW_CONS_PRINTER_R2_SOLENOID xor
      PW_CONS_PRINTER_R2A_SOLENOID xor
      PW_CONS_PRINTER_R5_SOLENOID xor
      PW_CONS_PRINTER_T1_SOLENOID xor
      PW_CONS_PRINTER_T2_SOLENOID xor
      PW_CONS_PRINTER_CHK_SOLENOID;
      
   -- The following is to make test bench console output more apparent.   
   
   IBM1410_CONSOLE_XMT_ASCII <= character'VAL(to_integer(unsigned(IBM1410_CONSOLE_XMT_CHAR)));   


--  UART Resets

   UART_RESET <= SWITCH_REL_PWR_ON_RST or SWITCH_MOM_CO_CPR_RST or SWITCH_MOM_CE_CPR_RST;
            
----   

---- Place your test bench code in the uut_process

uut_process: process

   variable testName: string(1 to 18);
   variable subtest: integer;
   
   variable grantWait: time := 100 ns;

   begin
   
   -- This signal is also connected to the relay drivers, so must be '1'
   -- ("OR" is really a "+" as in "12V")
   
   PP_SPECIAL_OR_12V_POWER_FOR_OSC <= '1';
   
   -- Make sure the console shows as idle
   
   -- MV_CONS_PRINTER_C2_CAM_NC <= '0';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '1';
   -- MV_CONS_PRINTER_C1_CAM_NC <= '0';
   -- MV_CONS_PRINTER_C1_CAM_NO <= '1';
   
   -- Make sure console shows as being in lower case
   -- As with lock/unlock below, the NC/NO part seems to be misleading...   
   
   -- MV_CONS_PRINTER_UPPER_CASE_STAR_S1NC <= '1';
   -- MV_CONS_PRINTER_LOWER_CASE_STAR_S1NO <= '0';
   
   -- These signals are most easily understood by ignoring the
   -- NO notation, and just looking at the names.  Thus 
   -- MV_KEYBOARD_UNLOCK_MODE is 0 when the keyboard is unlocked and
   -- MV_KEYBOARD_LOCK_MODE_STAR_NO is 1 when the keyboard is locked
   
   -- MV_KEYBOARD_UNLOCK_MODE <= '1';  -- Normally closed (locked)
   -- MV_KEYBOARD_LOCK_MODE_STAR_NO <= '0';  -- Normally open (locked)
   
   -- Console check output reflects inputs
      
   -- Test BenchVHDL for IBM SMS ALD group IntegrationTest3

   
   SWITCH_MOM_STARTPRINT <= '1';  -- This switch is "backwards"
      
   SWITCH_ROT_STOR_SCAN_DK1 <= "0000000001000";  -- Storage Scan Off
   
   SWITCH_ROT_CYCLE_CTRL_DK1 <= "0000000000100"; -- Cycle Control Off
   
   SWITCH_ROT_CHECK_CTRL_DK1 <= "0000000000100"; -- Check Control Stop Normal
   
   SWITCH_ROT_MODE_SW_DK <= "0000010000000"; -- Run Mode
   
   SWITCH_TOG_ASTERISK_PL2 <= '1';  -- Asterisk Insert ON
   
   -- PV_SENSE_CHAR_0_B1_BUS <= "11111011";  -- CWBA8-21  (WM + period)
   
   -- Initialize RAM
        
   -- wait for 30 ns;  -- Otherwise the power on reset doesn't work right.
   -- SWITCH_REL_PWR_ON_RST <= '0';
   -- wait for 1 ms;
   -- SWITCH_REL_PWR_ON_RST <= '1';
   wait for 500 us;   
   SWITCH_REL_PWR_ON_RST <= '0';
   wait for 21 ms;
   
--   SWITCH_MOM_CO_CPR_RST <= '1';
--   wait for 500 us;
--   SWITCH_MOM_CO_CPR_RST <= '0';           
--   wait for 30 ms;   
      
-- ===============================================================================================

-- Set whether or not we are testing load mode, and which channel to tset.
   
   LOCAL_WS_TEST <= '1';
   LOCAL_F_CH_TEST <= '1';  -- 0 means E Channel
   wait for 10 ns;

if LOCAL_F_CH_TEST = '0' then     
      
   -- Set Tape unit 0 not at load point, and ready   
   
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= "00000000";  -- Indicate we will provide status for Unit 0
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
   wait for 100 ns;

   IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= "00000000";     
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA(TAPE_UNIT_READ_READY_BIT) <= '1';  -- Set Status to READY
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA(TAPE_UNIT_WRITE_READY_BIT) <= '1';  -- Set Status to READY   
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
   wait for 100 ns;

   -- At this point, the CPU has not selected a tape drive.

   assert MC_TAPE_READY = '1' report "Test 1, Ready w/no unit asserted" severity failure;
   assert MC_SELECT_AT_LOAD_POINT_STAR_E_CH = '1' report "Test 1, Load Point asserted" severity failure;
   assert MC_SEL_OR_TAPE_IND_ON_CH_1 = '1' report "Test 1, Tape IND asserted" severity failure;
   assert MC_SELECT_AND_REWIND_STAR_E_CH = '1' report "Test 1, Rewind asserted" severity failure;  
      
   SWITCH_MOM_CONS_START <= '1';
   report "Pressed Start";
   wait for 5 us;  -- Normally we'd wait longer
   SWITCH_MOM_CONS_START <= '0';
   wait for 5 us; -- Normally this would take longer
   report "Start released";      
   
   -- Wait for the rewind request from the CPU
   
   wait until MC_REWIND_CALL_STAR_E_CH = '0';
   wait for 20 ns;
   
   assert MC_TAPE_READY = '0' report "Rewind Test, Ready Unit 0 NOT asserted" severity failure;
   assert MC_SELECT_AT_LOAD_POINT_STAR_E_CH = '1' report "Rewind Test, Load Point asserted" severity failure;
   assert MC_SEL_OR_TAPE_IND_ON_CH_1 = '1' report "Rewind Test, Tape IND asserted" severity failure;
   assert MC_SELECT_AND_REWIND_STAR_E_CH = '1' report "Rewind test, Rewind NOT asserted" severity failure;  

   -- Wait for the TAU to send something to the PC... the unit number
   
   wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "UC Test 3, No unit char transmitted" severity failure;
   wait for 10 ns; -- grant delay
         
   -- Save the character and grant the request
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';
   wait for 10 ns;  -- grant delay
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Rewind Test, Unit NOT 0" severity failure;
   
   -- Wait again for the TAU to send something to the PC... a rewind request.
   
   wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "Rewind Test, No request char transmitted" severity failure;
   wait for 10 ns; -- grant delay
   
   -- Save the character and grant the request
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "01000000" report "Rewind Test, Request not Rewind" severity failure;

   -- At this point, Unit 9 should be not ready, and rewinding because PC can't react as fast as a real drive.
            
   -- A short pretend rewind period.
   
   wait for 1 ms;
   
   -- Tell the CPU that the rewind has completed.
   
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= "00000000";  -- Indicate we will provide status for Unit 0
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
   wait for 100 ns;

   IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= "00000000";     
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA(TAPE_UNIT_READ_READY_BIT) <= '1';  -- Set Status to READY
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA(TAPE_UNIT_WRITE_READY_BIT) <= '1';  -- Set Status to READY
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA(TAPE_UNIT_LOAD_POINT_BIT) <= '1';  -- Set Status to load pt.   
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
   wait for 100 ns;
 
   -- It turns out that the channel resets the selected drive during the rewind.  Also, at this point,
   -- the test 1410 code is trying to do a READ (and getting busy from the rewind)

   -- assert MC_TAPE_READY = '0' report "Rewind Test, Ready Unit 0 NOT asserted" severity failure;
   -- assert MC_SELECT_AT_LOAD_POINT_STAR_E_CH = '0' report "Rewind Test, Load Point NOT asserted" severity failure;
   -- assert MC_SEL_OR_TAPE_IND_ON_CH_1 = '1' report "Rewind Test, Tape IND asserted" severity failure;
   -- assert MC_SELECT_AND_REWIND_STAR_E_CH = '1' report "Rewind Test, Rewind STILL asserted" severity failure;  
   
   ----------------------------------------------------------------------------------------------
   -- Wait for a read request
   
   
   if MC_READ_TAPE_CALL_STAR_E_CH = '1' then
      wait until MC_READ_TAPE_CALL_STAR_E_CH = '0' for 25 ms;
   end if;
   
   assert MC_READ_TAPE_CALL_STAR_E_CH = '0' 
     report "Read Test 1, No Read Call" severity failure;
     
   -- Set our odd parity mask to flip the TEST DATA parity bit.
   
  if MC_ODD_PARITY_TO_TAPE_STAR_E_CH = '0' then
     LOCAL_ODD_PARITY_MASK <= "01000000";
  else
     LOCAL_ODD_PARITY_MASK <= "00000000";
  end if;
   
   -- next, the TAU should issue a UART strobe to send the unit number
   
   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "Read Test 1, No unit char transmitted" severity failure;
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Read Test 1, Unit NOT 0" severity failure;
   
   -- Wait again for the TAU to send something to the PC... a Read request.
   
   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
     report "Read Test 1, No request char transmitted" severity failure;   
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "00000001" report "Read Test 1, Request not Read" severity failure;   
   
   -- Now we get to play PC Support program...  Send Unit 0 with the X'40' bit set...
   
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= "01000000";  -- Read data for Unit 0
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
   wait for 100 ns;
   
   -- Now send a 20 byte record 
   
   for i in 0 to 19 loop
   
      -- See if this char has a word separator
      
      LOCAL_WS_FLAG <= '1';  -- Have to go thru loop at least once.
      if TapeTestDataWM(i) = '1' and LOCAL_WS_TEST = '1' then
         LOCAL_WS_CHAR <= WORD_SEPARATOR_CHAR;
      else
         LOCAL_WS_CHAR <= "00000000";
      end if;
      wait for 10 ns;  -- Make the above take effect.

      -- If WM in test data, send WS first
                  
      while LOCAL_WS_FLAG = '1' loop
         if LOCAL_WS_CHAR /= "00000000" then
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= WORD_SEPARATOR_CHAR xor LOCAL_ODD_PARITY_MASK;
         else
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= tapeTestDataEven(i) xor LOCAL_ODD_PARITY_MASK;
         end if;
      
         wait for 10 ns;
         IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
         wait for 10 ns;
         IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
         
         -- Wait for the channel strobe...         
         if MC_TAPE_READ_STROBE /= '0' then
            wait until MC_TAPE_READ_STROBE = '0' for 100 us;
         end if;
         assert MC_TAPE_READ_STROBE = '0' report "Read Test 1, no Read Strobe" severity failure;
         wait for 10 ns;
      
         -- Check the data.   It should match what we told the TAU about.
         -- (Word separators are handled in the CPU, not the TAU)
         -- Have to swap location of check bit....
         
         assert MC_E_CH_TAU_TO_CPU_BUS = not (
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA(6) & '0' &
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA(5 downto 0))
            report "Read Test 1 Data to Channel mismatch" severity failure;
         -- wait for strobe to go away
         if MC_TAPE_READ_STROBE /= '1' then
            wait until MC_TAPE_READ_STROBE = '1' for 25 us;
         end if;
         assert MC_TAPE_READ_STROBE = '1' report "Read Test 1, Read Strobe Stayed active"
            severity failure;
 
         -- Need to wait as a test - normally our serial port will be slower than the channel
         wait for 1 us;
                     
         assert MC_TAPE_BUSY = '0' report "Read Test 1, TAU did not stay busy" severity failure;  
         assert MC_TAPE_IN_PROCESS = '0' report "Read Test 1, TAU did not stay In Process" 
           severity failure;  
        
         -- IF we just wrote a word separator while testing word marks, then 
         -- leave the LOCAL_WS_FLAG set, otherwise clear it.
         -- Clear the remembered WS Character regardless.
        
         if LOCAL_WS_CHAR /= "00000000" then
            LOCAL_WS_FLAG <= '1';
         else
            LOCAL_WS_FLAG <= '0';         
         end if;
         wait for 10 ns;
         LOCAL_WS_CHAR <= "00000000";
         wait for 10 ns;
        
      end loop; -- Word separater loop
              
   end loop;  -- test data loop

   -- We are no longer at load point...  (TODO)
                         
   -- Indicate the read is complete
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA <= "00000000";  -- End of record flag
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE <= '0';
   
   -- Now, wait for TAU to go un-busy
   
   if MC_TAPE_BUSY /= '1' then
      wait until MC_TAPE_BUSY = '1' for 25 us;
   end if;
   assert MC_TAPE_BUSY = '1' report "Read Test 1, TAU Stayed busy after EOR" severity failure;     
   
   if MC_TAPE_IN_PROCESS /= '1' then
      wait until MC_TAPE_IN_PROCESS = '1' for 25 us;
   end if;
   assert MC_TAPE_IN_PROCESS = '1' report "Read Test 1, TAU Stayed in process after EOR" 
      severity failure; 
   
---------------------------------------------------------------------------------------------

-- Now, lets WRITE a faux record from unit 0
   
   wait until MC_WRITE_TAPE_CALL_STAR_E_CH = '0' for 10 ms;
   wait for 20 ns;
   
   assert MC_WRITE_TAPE_CALL_STAR_E_CH = '0' report
      "Write Test 1, Didn't wait long enough for Write Call" severity failure;

   if MC_ODD_PARITY_TO_TAPE_STAR_E_CH = '0' then
      LOCAL_ODD_PARITY_MASK <= "01000000";
   else
     LOCAL_ODD_PARITY_MASK <= "00000000";
   end if;
   
   
   assert MC_TAPE_BUSY = '0' report "Write Test 1, TAU did not go busy" severity failure;

   -- For a write, the TAU should STAY busy

   wait for 10 ns;
   assert MC_TAPE_BUSY = '0' report "Write Test 1, TAU did not stay busy" severity failure;  
   assert MC_TAPE_IN_PROCESS = '0' report "Write Test 1, TAU not In Process" severity failure; 
      
   -- Wait for the TAU to send something to the PC... the unit number
   -- This thing reacts quickly - strobe might already be set!
   
   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "Write Test 1, No unit char transmitted" severity failure;
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Write Test 1, Unit NOT 0" severity failure;
   wait for 20 ns;
   
   -- Wait again for the TAU to send something to the PC... a WRITE request.

   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "Write Test 1, No request char transmitted" severity failure;
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';

   
   assert LOCAL_TAU_XMT_CHAR = "00000010" report "Write Test 1, Request not Write" severity failure;
   wait for 20 ns;  -- Wait for XMT strobe to go away 
     
   -- Now expect a 20 byte record
   
   for i in 0 to 19 loop
   
      report "Waiting for UART Strobe";
      LOCAL_i <= i;
      
      
      -- If the test data has a word mark, and we are testing load mode, then we need to do both
      -- the word separator check and the character check in this "i" loop
      
      LOCAL_WS_FLAG <= '1';  -- Have to go thru the loop at least once
      if TapeTestDataWM(i) = '1' and LOCAL_WS_TEST = '1' then
         LOCAL_WS_CHAR <= WORD_SEPARATOR_CHAR;
      else
         LOCAL_WS_CHAR <= "00000000";
      end if;
      wait for 10 ns;  -- Make the above take effect
      
      while LOCAL_WS_FLAG = '1' loop
      
         -- Wait for TAU to send the next character...
         if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
            wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
         end if;
         assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
            report "Write Test 1, No data char transmitted" severity failure;
         wait for 10 ns; -- Grant Delay
   
         -- Issue a grant for the request, and snag the data.
   
         LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
         IBM1410_TAU_XMT_UART_GRANT <= '1';   
         wait for 20 ns;
         IBM1410_TAU_XMT_UART_GRANT <= '0';
         
         -- Check that the data matches what was sent to 1410 during read test
         -- (If this is supposed to be a word separator, check that the first time thru)
      
         if LOCAL_WS_CHAR /= "00000000" then
            assert LOCAL_TAU_XMT_CHAR = (LOCAL_WS_CHAR xor LOCAL_ODD_PARITY_MASK)
               report "Write Test 1, Data send to PC not expected Word Separator" severity failure;
         else
            assert LOCAL_TAU_XMT_CHAR = (tapeTestDataEven(i) xor LOCAL_ODD_PARITY_MASK) 
               report "Write Test 1, Data sent to PC is not as expected" severity failure;
         end if;
         wait for 100 ns;   

         -- Wait for the channel strobe from the TAU for the next character
      
         report "Waiting for strobe to channel";

         if MC_TAPE_WRITE_STROBE /= '0' then
            wait until MC_TAPE_WRITE_STROBE = '0' for 100 us;
         end if;
         
         assert MC_TAPE_WRITE_STROBE = '0' report "Write Test 1, No Write Strobe from TAU"
            severity failure;
         
         -- Until the last character, TAU should stay busy...
      
         if i /= 19 or LOCAL_WS_CHAR /= "00000000" then           

            -- Need to wait - normally our serial port will be slower than the channel
            wait for 1 us;
                     
            assert MC_TAPE_BUSY = '0' report "Write Test 1, TAU did not stay busy" severity failure;  
            assert MC_TAPE_IN_PROCESS = '0' report "Write Test 1, TAU did not stay In Process" 
              severity failure;
         end if;
         
         -- IF we just got a WS character while testign with word parms, then
         -- leave LOCAL_WS_FLAG set, otherwise, clar it.
         -- Clear the remembered WS Character regardless.
         
         if LOCAL_WS_CHAR /= "00000000" then
            LOCAL_WS_FLAG <= '1';
         else
            LOCAL_WS_FLAG <= '0';         
         end if;
         wait for 10 ns;
         LOCAL_WS_CHAR <= "00000000";
         wait for 10 ns;
         
      end loop;  -- Word Separator handling loop
                    
   end loop;  -- "i" count loop
   
   -- At this point, we are expecting a disconnect from the Channel -- handled in TAU

   -- After the disconnect, we should see the EOR get transmitted

   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "Write Test 1, No EOR char transmitted" severity failure;
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';

   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Write Test 1, Did not get X'40' EOR" 
      severity failure;
   wait for 100 ns;   
   
   -- Now, wait for TAU to go un-busy
   
   if MC_TAPE_BUSY /= '1' then
      wait until MC_TAPE_BUSY = '1' for 25 us;
   end if;
   assert MC_TAPE_BUSY = '1' report "Write Test 1, TAU Stayed busy after EOR" severity failure;     
   
   if MC_TAPE_IN_PROCESS /= '1' then
      wait until MC_TAPE_IN_PROCESS = '1' for 25 us;
   end if;
   assert MC_TAPE_IN_PROCESS = '1' report "Write Test 1, TAU Stayed in process after EOR" 
      severity failure; 
   
   wait for 100 ns;


---------------------------------------------------------------------------------------------

   -- Write Tape Mark Test

   -- Wait for the request
   
   wait until MC_WRITE_TAPE_MK_CALL_STAR_E_CH = '0' for 25 ms;
   
   assert MC_WRITE_TAPE_MK_CALL_STAR_E_CH = '0' report "WTM Test, No Tape Mark Call" severity failure;
      
   -- For a WTM, the TAU should STAY busy for a little while.

   wait for 20 ns;
   assert MC_TAPE_BUSY = '0' report "WTM Test, TAU did not go busy" severity failure;  
   assert MC_TAPE_IN_PROCESS = '0' report "WTM, TAU not In Process" severity failure; 
      
   -- Wait for the TAU to send something to the PC... the unit number
   -- This thing reacts quickly - strobe might already be set!
   
   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "WTM Test, No unit char transmitted" severity failure;
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "WTM Test, Unit NOT 0" severity failure;
   wait for 20 ns;
   
   -- Wait again for the TAU to send something to the PC... WTM.
   
   if IBM1410_TAU_XMT_UART_REQUEST  /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST  = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST = '1' 
      report "WTM Test, No request char transmitted" severity failure;
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA;
   IBM1410_TAU_XMT_UART_GRANT <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT <= '0';

   
   assert LOCAL_TAU_XMT_CHAR = "00010000" report "WTM Test, Request not WTM" severity failure;   
   
   -- Make sure it doesn't strobe the channel
   
   wait until MC_TAPE_WRITE_STROBE = '0' for 10 us;
   
   assert MC_TAPE_WRITE_STROBE = '1' report "WTM Test, Strobed Channel but should not.";
   
   -- Wait for the 1410 to issue a disconnect (it might not?)
   
   if MC_DISCONNECT_CALL_STAR_E_CH = '1' then
      wait until MC_DISCONNECT_CALL_STAR_E_CH = '0' for 25 us;
   end if;
   
   -- Apparently, there is no disconnect call from a WTM (makes sense, I guess)
   -- assert MC_DISCONNECT_CALL_STAR_E_CH = '0' report "WTM Test, No Disconnect Call" severity failure;
   
   -- Everything should be done, now.
   
   assert MC_TAPE_BUSY = '1' report "WTM Test, TAU still busy" severity failure;  
   assert MC_TAPE_IN_PROCESS = '1' report "WTM Test 1, TAU did still In Process" 
      severity failure;  

   -- We are no longer at load point...  (TODO)
                           
   wait for 100 ns;
   
end if;  -- If testing E Channel


-- ===============================================================================================

if LOCAL_F_CH_TEST = '1' then     
      
   -- Set Tape unit 0 not at load point, and ready   
   
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= "00000000";  -- Indicate we will provide status for Unit 0
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
   wait for 100 ns;

   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= "00000000";     
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(TAPE_UNIT_READ_READY_BIT) <= '1';  -- Set Status to READY
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(TAPE_UNIT_WRITE_READY_BIT) <= '1';  -- Set Status to READY   
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
   wait for 100 ns;

   -- At this point, the CPU has not selected a tape drive.

   assert MC_TAPE_READY_F_CH_JRJ = '1' report "Test 1, Ready w/no unit asserted" severity failure;
   assert MC_SELECT_AT_LOAD_POINT_STAR_F_CH = '1' report "Test 1, Load Point asserted" severity failure;
   assert MC_SEL_OR_TI_ON_CH_2 = '1' report "Test 1, Tape IND asserted" severity failure;
   assert MC_SELECT_AND_REWIND_STAR_F_CH = '1' report "Test 1, Rewind asserted" severity failure;  
      
   SWITCH_MOM_CONS_START <= '1';
   report "Pressed Start";
   wait for 5 us;  -- Normally we'd wait longer
   SWITCH_MOM_CONS_START <= '0';
   wait for 5 us; -- Normally this would take longer
   report "Start released";      
   
   -- Wait for the rewind request
   
   wait until MC_REWIND_CALL_STAR_F_CH = '0';
   wait for 20 ns;
   
   assert MC_TAPE_READY_F_CH_JRJ = '0' report "Test 2, Ready Unit 0 NOT asserted" severity failure;
   assert MC_SELECT_AT_LOAD_POINT_STAR_F_CH = '1' report "Test 2, Load Point asserted" severity failure;
   assert MC_SEL_OR_TI_ON_CH_2 = '1' report "Test 2, Tape IND asserted" severity failure;
   assert MC_SELECT_AND_REWIND_STAR_F_CH = '1' report "Test 0, Rewind NOT asserted" severity failure;  

   -- Wait for the TAU to send something to the PC... the unit number
   
   wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH  = '1' for 25 us;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "UC Test 3, No unit char transmitted" severity failure;
   wait for 10 ns; -- grant delay
         
   -- Save the character and grant the request
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   wait for grantWait;  -- grant delay
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Rewind Test, Unit NOT 0" severity failure;
   
   -- Wait again for the TAU to send something to the PC... a rewind request.
   
   wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH  = '1' for 25 us;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "Rewind Test, No request char transmitted" severity failure;
   wait for grantWait; -- grant delay
   
   -- Save the character and grant the request
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "01000000" report "Rewind Test, Request not Rewind" severity failure;

            
   -- A short pretend rewind period.
   
   wait for 1 ms;
   
   -- Tell the CPU that the rewind has completed.
   
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= "00000000";  -- Indicate we will provide status for Unit 0
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
   wait for 100 ns;

   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= "00000000";     
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(TAPE_UNIT_READ_READY_BIT) <= '1';  -- Set Status to READY
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(TAPE_UNIT_WRITE_READY_BIT) <= '1';  -- Set Status to READY
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(TAPE_UNIT_LOAD_POINT_BIT) <= '1';  -- Set Status to load pt.   
   wait for 100 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
   wait for 100 ns;

   -- assert MC_TAPE_READY_F_CH_JRJ = '0' report "Test 3, Ready Unit 0 NOT asserted" severity failure;
   -- assert MC_SELECT_AT_LOAD_POINT_STAR_F_CH = '0' report "Test 3 Load Point NOT asserted" severity failure;
   -- assert MC_SEL_OR_TI_ON_CH_2 = '1' report "Test 3, Tape IND asserted" severity failure;
   -- assert MC_SELECT_AND_REWIND_STAR_F_CH = '1' report "Test 3, Rewind STILL asserted" severity failure;  
   
   ----------------------------------------------------------------------------------------------
   -- Wait for a read request
   
   -- Set whether or not we are testing load mode
   
   LOCAL_WS_TEST <= '1';
   
   if MC_READ_TAPE_CALL_STAR_F_CH = '1' then
      wait until MC_READ_TAPE_CALL_STAR_F_CH = '0' for 25 ms;
   end if;
   
   assert MC_READ_TAPE_CALL_STAR_F_CH = '0' 
     report "Read Test 1, No Read Call" severity failure;
     
   -- Set our odd parity mask to flip the TEST DATA parity bit.
   
  if MC_ODD_PARITY_TO_TAPE_STAR_F_CH = '0' then
     LOCAL_ODD_PARITY_MASK <= "01000000";
  else
     LOCAL_ODD_PARITY_MASK <= "00000000";
  end if;
   
   -- next, the TAU should issue a UART strobe to send the unit number
   
   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "Read Test 1, No unit char transmitted" severity failure;   
   wait for grantWait; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Read Test 1, Unit NOT 0" severity failure;
   
   -- Wait again for the TAU to send something to the PC... a Read request.
   
   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "Read Test 1, No request char transmitted" severity failure;   
   wait for 10 ns; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "00000001" report "Read Test 1, Request not Read" severity failure;   
   
   -- Now we get to play PC Support program...  Send Unit 9 with the X'40' bit set...
   
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= "01000000";  -- Read data for Unit 0
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
   wait for 100 ns;
   
   -- Now send a 20 byte record 
   
   for i in 0 to 19 loop
   
      -- See if this char has a word separator
      
      LOCAL_WS_FLAG <= '1';  -- Have to go thru loop at least once.
      if TapeTestDataWM(i) = '1' and LOCAL_WS_TEST = '1' then
         LOCAL_WS_CHAR <= WORD_SEPARATOR_CHAR;
      else
         LOCAL_WS_CHAR <= "00000000";
      end if;
      wait for 10 ns;  -- Make the above take effect.

      -- If WM in test data, send WS first
                  
      while LOCAL_WS_FLAG = '1' loop
         if LOCAL_WS_CHAR /= "00000000" then
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= WORD_SEPARATOR_CHAR xor LOCAL_ODD_PARITY_MASK;
         else
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= tapeTestDataEven(i) xor LOCAL_ODD_PARITY_MASK;
         end if;
      
         wait for 10 ns;
         IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
         wait for 10 ns;
         IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
         
         -- Wait for the channel strobe...         
         if MC_TAPE_READ_STROBE /= '0' then
            wait until MC_TAPE_READ_STROBE_F_CH_JRJ = '0' for 25 us;
         end if;
         assert MC_TAPE_READ_STROBE_F_CH_JRJ = '0' report "Read Test 1, no Read Strobe" severity failure;
         wait for 10 ns;
      
         -- Check the data.   It should match what we told the TAU about.
         -- (Word separators are handled in the CPU, not the TAU)
         -- Have to swap location of check bit....
         assert MC_F_CH_TAU_TO_CPU_BUS = not (
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(6) & '0' &
            IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH(5 downto 0))
            report "Read Test 1 Data to Channel mismatch" severity failure;
         -- wait for strobe to go away
         if MC_TAPE_READ_STROBE_F_CH_JRJ /= '1' then
            wait until MC_TAPE_READ_STROBE_F_CH_JRJ = '1' for 25 us;
         end if;
         assert MC_TAPE_READ_STROBE_F_CH_JRJ = '1' report "Read Test 1, Read Strobe Stayed active"
            severity failure;
 
         -- Need to wait as a test - normally our serial port will be slower than the channel
         wait for 1 us;
                     
         assert MC_TAPE_BUSY_F_CH_JRJ = '0' report "Read Test 1, TAU did not stay busy" severity failure;  
         assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '0' report "Read Test 1, TAU did not stay In Process" 
           severity failure;  
        
         -- IF we just wrote a word separator while testing word marks, then 
         -- leave the LOCAL_WS_FLAG set, otherwise clear it.
         -- Clear the remembered WS Character regardless.
        
         if LOCAL_WS_CHAR /= "00000000" then
            LOCAL_WS_FLAG <= '1';
         else
            LOCAL_WS_FLAG <= '0';         
         end if;
         wait for 10 ns;
         LOCAL_WS_CHAR <= "00000000";
         wait for 10 ns;
        
      end loop; -- Word separater loop
      
      wait for 91 us;  -- simulate a UART at 115,000 bps / 11000 cps
              
   end loop;  -- test data loop

   -- We are no longer at load point...  (TODO)
                         
   -- Indicate the read is complete
   IBM1410_TAU_INPUT_FIFO_WRITE_DATA_F_CH <= "00000000";  -- End of record flag
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '1';
   wait for 10 ns;
   IBM1410_TAU_INPUT_FIFO_WRITE_ENABLE_F_CH <= '0';
   
   -- Now, wait for TAU to go un-busy
   
   if MC_TAPE_BUSY_F_CH_JRJ /= '1' then
      wait until MC_TAPE_BUSY_F_CH_JRJ = '1' for 25 us;
   end if;
   assert MC_TAPE_BUSY_F_CH_JRJ = '1' report "Read Test 1, TAU Stayed busy after EOR" severity failure;     
   
   if MC_TAPE_IN_PROCESS_F_CH_JRJ /= '1' then
      wait until MC_TAPE_IN_PROCESS_F_CH_JRJ = '1' for 25 us;
   end if;
   assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '1' report "Read Test 1, TAU Stayed in process after EOR" 
      severity failure; 
   
---------------------------------------------------------------------------------------------

-- Now, lets WRITE a faux record from unit 0
   
   wait until MC_WRITE_TAPE_CALL_STAR_F_CH = '0' for 10 ms;
   wait for 20 ns;
   
   assert MC_WRITE_TAPE_CALL_STAR_F_CH = '0' report
      "Write Test 1, Didn't wait long enough for Write Call" severity failure;

   if MC_ODD_PARITY_TO_TAPE_STAR_F_CH = '0' then
      LOCAL_ODD_PARITY_MASK <= "01000000";
   else
     LOCAL_ODD_PARITY_MASK <= "00000000";
   end if;
   
   
   assert MC_TAPE_BUSY_F_CH_JRJ = '0' report "Write Test 1, TAU did not go busy" severity failure;

   -- For a write, the TAU should STAY busy

   wait for 10 ns;
   assert MC_TAPE_BUSY_F_CH_JRJ = '0' report "Write Test 1, TAU did not stay busy" severity failure;  
   assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '0' report "Write Test 1, TAU not In Process" severity failure; 
      
   -- Wait for the TAU to send something to the PC... the unit number
   -- This thing reacts quickly - strobe might already be set!
   
   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "Write Test 1, No unit char transmitted" severity failure;
   wait for grantWait; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Write Test 1, Unit NOT 0" severity failure;
   wait for 20 ns;
   
   -- Wait again for the TAU to send something to the PC... a WRITE request.

   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "Write Test 1, No request char transmitted" severity failure;
   wait for grantWait; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "00000010" report "Write Test 1, Request not Write" severity failure;
   wait for 20 ns;  -- Wait for XMT strobe to go away 
     
   -- Now expect a 20 byte record
   
   for i in 0 to 19 loop
   
      report "Waiting for UART Strobe";
      LOCAL_i <= i;
      
      -- If the test data has a word mark, and we are testing load mode, then we need to do both
      -- the word separator check and the character check in this "i" loop
      
      LOCAL_WS_FLAG <= '1';  -- Have to go thru the loop at least once
      if TapeTestDataWM(i) = '1' and LOCAL_WS_TEST = '1' then
         LOCAL_WS_CHAR <= WORD_SEPARATOR_CHAR;
      else
         LOCAL_WS_CHAR <= "00000000";
      end if;
      wait for 10 ns;  -- Make the above take effect
      
      while LOCAL_WS_FLAG = '1' loop
      
         -- Wait for TAU to send the next character...
         if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
            wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
         end if;
         assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
            report "Write Test 1, No data char transmitted" severity failure;
         wait for grantWait; -- Grant Delay
   
         -- Issue a grant for the request, and snag the data.
   
         LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
         IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
         wait for 20 ns;
         IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';

         
         -- Check that the data matches what was sent to 1410 during read test
         -- (If this is supposed to be a word separator, check that the first time thru)
      
         if LOCAL_WS_CHAR /= "00000000" then
            assert LOCAL_TAU_XMT_CHAR = (LOCAL_WS_CHAR xor LOCAL_ODD_PARITY_MASK)
               report "Write Test 1, Data send to PC not expected Word Separator" severity failure;
         else
            assert LOCAL_TAU_XMT_CHAR = (tapeTestDataEven(i) xor LOCAL_ODD_PARITY_MASK) 
               report "Write Test 1, Data sent to PC is not as expected" severity failure;
         end if;
         wait for 100 ns;   

         -- Wait for the channel strobe from the TAU for the next character
      
         report "Waiting for strobe to channel";

         if MC_TAPE_WRITE_STROBE_F_CH_JRJ /= '0' then
            wait until MC_TAPE_WRITE_STROBE_F_CH_JRJ = '0' for 25 us;
         end if;
         
         assert MC_TAPE_WRITE_STROBE_F_CH_JRJ = '0' report "Write Test 1, No Write Strobe from TAU"
            severity failure;
         
         -- Until the last character, TAU should stay busy...
      
         if i /= 19 or LOCAL_WS_CHAR /= "00000000" then           

            -- Need to wait - normally our serial port will be slower than the channel
            wait for 1 us;
                     
            assert MC_TAPE_BUSY_F_CH_JRJ = '0' report "Write Test 1, TAU did not stay busy" severity failure;  
            assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '0' report "Write Test 1, TAU did not stay In Process" 
              severity failure;
         end if;
         
         -- IF we just got a WS character while testign with word parms, then
         -- leave LOCAL_WS_FLAG set, otherwise, clar it.
         -- Clear the remembered WS Character regardless.
         
         if LOCAL_WS_CHAR /= "00000000" then
            LOCAL_WS_FLAG <= '1';
         else
            LOCAL_WS_FLAG <= '0';         
         end if;
         wait for 10 ns;
         LOCAL_WS_CHAR <= "00000000";
         wait for 10 ns;
         
      end loop;  -- Word Separator handling loop
              
   end loop;  -- "i" count loop
   
   -- At this point, we are expecting a disconnect from the Channel -- handled in TAU

   -- After the disconnect, we should see the EOR get transmitted

   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "Write Test 1, No EOR char transmitted" severity failure;
   wait for grantWait; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "Write Test 1, Did not get X'40' EOR" 
      severity failure;
   wait for 100 ns;   
   
   -- Now, wait for TAU to go un-busy
   
   if MC_TAPE_BUSY_F_CH_JRJ /= '1' then
      wait until MC_TAPE_BUSY_F_CH_JRJ = '1' for 25 us;
   end if;
   assert MC_TAPE_BUSY_F_CH_JRJ = '1' report "Write Test 1, TAU Stayed busy after EOR" severity failure;     
   
   if MC_TAPE_IN_PROCESS_F_CH_JRJ /= '1' then
      wait until MC_TAPE_IN_PROCESS_F_CH_JRJ = '1' for 25 us;
   end if;
   assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '1' report "Write Test 1, TAU Stayed in process after EOR" 
      severity failure; 
   
   wait for 100 ns;


---------------------------------------------------------------------------------------------

   -- Write Tape Mark Test

   -- Wait for the request
   
   wait until MC_WRITE_TAPE_MK_CALL_STAR_F_CH = '0' for 25 ms;
   
   assert MC_WRITE_TAPE_MK_CALL_STAR_F_CH = '0' report "WTM Test, No Tape Mark Call" severity failure;
      
   -- For a WTM, the TAU should STAY busy for a little while.

   wait for 20 ns;
   assert MC_TAPE_BUSY_F_CH_JRJ = '0' report "WTM Test, TAU did not go busy" severity failure;  
   assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '0' report "WTM, TAU not In Process" severity failure; 
      
   -- Wait for the TAU to send something to the PC... the unit number
   -- This thing reacts quickly - strobe might already be set!
   
   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "WTM Test, No unit char transmitted" severity failure;
   wait for grantWait; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   -- It should be for unit 0
   
   assert LOCAL_TAU_XMT_CHAR = "00000000" report "WTM Test, Unit NOT 0" severity failure;
   wait for 20 ns;
   
   -- Wait again for the TAU to send something to the PC... WTM.
   
   if IBM1410_TAU_XMT_UART_REQUEST_F_CH /= '1' then
      wait until IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' for 25 us;
   end if;
   assert IBM1410_TAU_XMT_UART_REQUEST_F_CH = '1' 
      report "WTM Test, No request char transmitted" severity failure;
   wait for grantWait; -- Grant Delay
   
   -- Issue a grant for the request, and snag the data.
   
   LOCAL_TAU_XMT_CHAR <= IBM1410_TAU_XMT_UART_DATA_F_CH;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '1';   
   wait for 20 ns;
   IBM1410_TAU_XMT_UART_GRANT_F_CH <= '0';
   
   assert LOCAL_TAU_XMT_CHAR = "00010000" report "WTM Test, Request not WTM" severity failure;   
   
   -- Make sure it doesn't strobe the channel
   
   wait until MC_TAPE_WRITE_STROBE_F_CH_JRJ = '0' for 10 us;
   
   assert MC_TAPE_WRITE_STROBE_F_CH_JRJ = '1' report "WTM Test, Strobed Channel but should not.";
   
   -- Wait for the 1410 to issue a disconnect (it might not?)
   
   if MC_DISCONNECT_CALL_STAR_F_CH = '1' then
      wait until MC_DISCONNECT_CALL_STAR_F_CH = '0' for 25 us;
   end if;
   
   -- Apparently, there is no disconnect call from a WTM (makes sense, I guess)
   -- assert MC_DISCONNECT_CALL_STAR_E_CH = '0' report "WTM Test, No Disconnect Call" severity failure;
   
   -- Everything should be done, now.
   
   assert MC_TAPE_BUSY_F_CH_JRJ = '1' report "WTM Test, TAU still busy" severity failure;  
   assert MC_TAPE_IN_PROCESS_F_CH_JRJ = '1' report "WTM Test 1, TAU did still In Process" 
      severity failure;  

   -- We are no longer at load point...  (TODO)
                           
   wait for 100 ns;
   
end if;  -- If testing F Channel

      
   wait for 25 ms;  -- Give it a chance to halt somewhere.
   
   -- Stop printout - starts with CR
   
   -- wait until PW_CARRIAGE_RETURN_SOLENOID = '1';
   -- report "Starting Carriage Return";
   -- wait for 520 us;  -- This would normally be 52 ms
   -- MV_CONS_PRINTER_C2_CAM_NC <= '1';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '0';
   
   -- wait until PW_CARRIAGE_RETURN_SOLENOID = '0';
   -- wait for 520 us;  -- This would normally be 52 ms
   -- MV_CONS_PRINTER_C2_CAM_NC <= '0';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '1';  
   -- report "Stop PO Carriage Return Complete";
   
   -- wait for 520 us;  (Wait for T2 solenoid instead)
      
   -- Then we get an "S"
   
--   wait until PW_CONS_PRINTER_T2_SOLENOID = '1';
--   wait for 1 us; -- This would normally be 1 ms;
--   assert PW_CONS_PRINTER_R1_SOLENOID = '0' and
--      PW_CONS_PRINTER_R2_SOLENOID = '1' and
--      PW_CONS_PRINTER_R2A_SOLENOID = '1' and
--      PW_CONS_PRINTER_R5_SOLENOID = '0' and
--      PW_CONS_PRINTER_T1_SOLENOID = '0' report
--      "Console output character is not an 'S'" severity failure;
   
   -- wait for 270 us;  -- This would normally be 27 ms.
   
   -- MV_CONS_PRINTER_C2_CAM_NC <= '1';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '0';
   
   --  During C2, the bits are transferred to mechancial latches 
   --  Note that these signals are ctive LOW
   
   -- MV_CONS_PRINTER_ODD_BIT_CHECK <= not unlatchedConsoleParity; 
   -- MB_CONS_PRINTER_EVEN_BIT_CHECK <= unlatchedConsoleParity;

   -- wait for 197 us; -- This would normally be 19.7 ms
   
   -- MV_CONS_PRINTER_C1_CAM_NC <= '1';
   -- MV_CONS_PRINTER_C1_CAM_NO <= '0';

   -- wait for 126 us; -- this would normally be 12.6 ms

   -- MV_CONS_PRINTER_C2_CAM_NC <= '0';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '1';
   
   -- wait for 36 us; -- this would normally be 3.6 ms

   -- MV_CONS_PRINTER_C1_CAM_NC <= '0';
   -- MV_CONS_PRINTER_C1_CAM_NO <= '1';
   
   -- After C1, the console bit check latches are released
   
   -- MV_CONS_PRINTER_ODD_BIT_CHECK <= '1'; 
   -- MB_CONS_PRINTER_EVEN_BIT_CHECK <= '0';
      
   -- wait until MV_CONS_PRINTER_C2_CAM_NO = '1';
   -- report "'S' output complete";
   
   -- Next we expect a space operation
   
   -- if PW_SPACE_SOLENOID = '0' then
      -- wait until PW_SPACE_SOLENOID = '1';
   -- end if;
   
   -- wait for 267 us;  -- would normally be 7 + 17.9 + 1.8 ms
   
   -- MV_CONS_PRINTER_C2_CAM_NC <= '1';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '0';

   -- wait for 269 us;  -- would normally be 26.9 ms   
   
   -- MV_CONS_PRINTER_C2_CAM_NC <= '0';
   -- MV_CONS_PRINTER_C2_CAM_NO <= '1';
            
   -- IAR readout comes next            
            
   -- wait for 520 us;
   
   -- wait for 25 ms; 
  

   -- SWITCH_MOM_STARTPRINT <= '0';  -- This switch is "backwards"
   -- wait for 200 us;
   
   -- SWITCH_TOG_INHIBIT_PO_PL1 <= '1';
   -- SWITCH_TOG_INHIBIT_PO_PL2 <= '1';
   -- wait for 1 us;
   
   SWITCH_MOM_CONS_STOP_PL1 <= '1';
   wait for 1 us;
   
   -- Help out the stop if instruction readout isn't working
   SWITCH_MOM_CONS_STOP_PL1 <= '0';
   
   -- Your test bench code

   assert false report "Simulation Ended NORMALLY" severity failure;
   
   wait;
   end process;

---- The following is needed for older VHDL simulations to
---- terminate the simulation process.  If your environment
---- does not need it, it may be deleted.

--stop_simulation: process
--   begin
--   wait for 2 ms;  -- Determines how long your simulation runs
--   assert false report "Simulation Ended NORMALLY (TIMEOUT)" severity failure;
--   end process;

-- END USER TEST BENCH PROCESS

END;
