-- Test BenchVHDL for IBM SMS ALD group YLSMSDrvrEncoder
-- Title: YLSMSDrvrEncoder
-- IBM Machine Name 1411
-- Generated by GenerateHDL on 10/16/2020 3:20:25 PM

-- Included from HDLTemplate.vhdl

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;  -- For use in test benches only
use WORK.ALL;

-- End of include from HDLTemplate.vhdl

entity YLSMSDrvrEncoder_tb is
end YLSMSDrvrEncoder_tb;

architecture behavioral of YLSMSDrvrEncoder_tb is

	-- Component Declaration for the Unit Under Test (UUT)

	component YLSMSDrvrEncoder
	    Port (
		FPGA_CLK: in STD_LOGIC;
		MY_Y_WR_1: in STD_LOGIC;
		MY_Y_RD_1: in STD_LOGIC;
		MY_Y_RD_2: in STD_LOGIC;
		MY_Y_WR_2: in STD_LOGIC;
		MY_MEM_AR_NOT_HP_BUS: in STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_HP_BUS: in STD_LOGIC_VECTOR (4 downTo 0);
		MY_MEM_AR_NOT_HP8B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP4B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP2B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP1B_Z: out STD_LOGIC;
		MY_MEM_AR_NOT_HP0B_Z: out STD_LOGIC;
		PY_Y_RD_2: out STD_LOGIC;
		PY_Y_LSMS_DRVR_BUS: out STD_LOGIC_VECTOR (14 downTo 0));
	end component;

	-- Inputs

	signal FPGA_CLK: STD_LOGIC := '0';
	signal MY_Y_WR_1: STD_LOGIC := '1';
	signal MY_Y_RD_1: STD_LOGIC := '1';
	signal MY_Y_RD_2: STD_LOGIC := '1';
	signal MY_Y_WR_2: STD_LOGIC := '1';
	signal MY_MEM_AR_NOT_HP_BUS: STD_LOGIC_VECTOR (4 downTo 0) := "11111";
	signal MY_MEM_AR_HP_BUS: STD_LOGIC_VECTOR (4 downTo 0) := "11111";

	-- Outputs

	signal MY_MEM_AR_NOT_HP8B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP4B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP2B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP1B_Z: STD_LOGIC;
	signal MY_MEM_AR_NOT_HP0B_Z: STD_LOGIC;
	signal PY_Y_RD_2: STD_LOGIC;
	signal PY_Y_LSMS_DRVR_BUS: STD_LOGIC_VECTOR (14 downTo 0);

-- START USER TEST BENCH DECLARATIONS

-- The user test bench declarations, if any, must be
-- placed AFTER the line starts with the first line of text 
-- with -- START USER TEST BENCH DECLARATIONS and ends
-- with the line containing -- END (and the rest of the line) below.
-- This text is preserved when the IBM1410SMS applciation
-- regenerates a test bench

   constant HDL_C_BIT: integer := 7;
   constant HDL_WM_BIT: integer := 6;
   constant HDL_B_BIT: integer := 5;
   constant HDL_A_BIT: integer := 4;
   constant HDL_8_BIT: integer := 3;
   constant HDL_4_BIT: integer := 2;
   constant HDL_2_BIT: integer := 1;
   constant HDL_1_BIT: integer := 0;

   constant MX_X1A_POS: integer := 7;
   constant MX_X6A_POS: integer := 8;

procedure check1(
    checked: in STD_LOGIC;
    val: in STD_LOGIC;
    testname: in string;
    test: in string) is
    begin    
    assert checked = val report testname & " (" & test & ") failed." severity failure;
    end procedure;
      

procedure checkLSMSDrivers(
    checked: in STD_LOGIC_VECTOR(14 downto 0);
    val: in STD_LOGIC_VECTOR(14 downto 0);
    testname: in string;
    test: in string) is
    begin
      for dvr in 1 to 15 loop
         assert checked(dvr-1) = val(dvr-1) report
            testname & " (" & test & ") line " & Integer'image(dvr) & " failed." severity failure; 
      end loop;
    end procedure;


   -- Your test bench declarations go here

-- END USER TEST BENCH DECLARATIONS
   

	begin

	-- Instantiate the Unit Under Test (UUT)

	UUT: YLSMSDrvrEncoder port map(
		FPGA_CLK => FPGA_CLK,
		MY_Y_WR_1 => MY_Y_WR_1,
		MY_Y_RD_1 => MY_Y_RD_1,
		MY_Y_RD_2 => MY_Y_RD_2,
		MY_Y_WR_2 => MY_Y_WR_2,
		MY_MEM_AR_NOT_HP_BUS => MY_MEM_AR_NOT_HP_BUS,
		MY_MEM_AR_HP_BUS => MY_MEM_AR_HP_BUS,
		MY_MEM_AR_NOT_HP8B_Z => MY_MEM_AR_NOT_HP8B_Z,
		MY_MEM_AR_NOT_HP4B_Z => MY_MEM_AR_NOT_HP4B_Z,
		MY_MEM_AR_NOT_HP2B_Z => MY_MEM_AR_NOT_HP2B_Z,
		MY_MEM_AR_NOT_HP1B_Z => MY_MEM_AR_NOT_HP1B_Z,
		MY_MEM_AR_NOT_HP0B_Z => MY_MEM_AR_NOT_HP0B_Z,
		PY_Y_RD_2 => PY_Y_RD_2,
		PY_Y_LSMS_DRVR_BUS => PY_Y_LSMS_DRVR_BUS);

-- START USER TEST BENCH PROCESS

-- The user test bench code MUST be placed between the
-- line that starts with the first line of text that
-- begins with "-- START USERS TEST BENCH PROCESS" 
-- and ends with "-- END"
-- This text is preserved when the IBM1410SMS applciation
-- regenerates a test bench

-- 
-- TestBenchFPGAClock.vhdl
--
-- Process to simulate the FPGA clock for a VHDL test bench
--

fpga_clk_process: process

   constant clk_period : time := 10 ns;

   begin
      fpga_clk <= '0';
      wait for clk_period / 2;
      fpga_clk <= '1';
      wait for clk_period / 2;
   end process;

--
-- End of TestBenchFPGAClock.vhdl
--   

-- Place your test bench code in the uut_process

uut_process: process

   variable testName: string(1 to 18);
   variable subtest: integer;
   variable tv: std_logic_vector(25 downto 0);
   variable a,b,c,d,e,f,g,h,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z: std_logic;
   variable g1, g2, g3, g4, g5, g6, g7, g8, g9, g10: std_logic;

   variable truthTableResults: std_logic_vector(14 downto 0);

   begin

   -- Your test bench code

   testName := "32.10.0%.1        ";

   for rdwr in 0 to 1 loop
      for hpos in 0 to 9 loop

         case rdwr is
            when 0 =>
               MY_Y_WR_1 <= '1'; 
               MY_Y_WR_2 <= '1';
               MY_Y_RD_1 <= '0';
               MY_Y_RD_2 <= '0';
            when others =>
               MY_Y_WR_1 <= '0'; 
               MY_Y_WR_2 <= '0';
               MY_Y_RD_1 <= '1';
               MY_Y_RD_2 <= '1';            
         end case;
         
         MY_MEM_AR_HP_BUS <= not BCD.twoOfFive(hpos);
         MY_MEM_AR_NOT_HP_BUS <= BCD.TwoOfFive(hpos);
         
         case hpos is
             when 0 => truthTableResults := "101110010100101";
             when 1 => truthTableResults := "001101110111000";
             when 2 => truthTableResults := "010110101110100";
             when 3 => truthTableResults := "011011011001100";
             when 4 => truthTableResults := "100111011010010";
             when 5 => truthTableResults := "101010101101010";
             when 6 => truthTableResults := "110001110100110";
             when 7 => truthTableResults := "011111100000011";
             when 8 => truthTableResults := "111000111010001";
             when 9 => truthTableResults := "110101001101001";
         end case;
         
         if(rdwr = 0) then
             truthTableResults := not truthTableResults;
         end if;

         wait for 30 ns;
                                     
	    	check1(MY_MEM_AR_NOT_HP8B_Z,not MY_MEM_AR_HP_BUS(4),testName,"-Y MEM AR NOT HP8B-Z");
         check1(MY_MEM_AR_NOT_HP4B_Z,not MY_MEM_AR_HP_BUS(3),testName,"-Y MEM AR NOT HP4B-Z");
         check1(MY_MEM_AR_NOT_HP2B_Z,not MY_MEM_AR_HP_BUS(2),testName,"-Y MEM AR NOT HP2B-Z");
         check1(MY_MEM_AR_NOT_HP1B_Z,not MY_MEM_AR_HP_BUS(1),testName,"-Y MEM AR NOT HP1B-Z");
         check1(MY_MEM_AR_NOT_HP0B_Z,not MY_MEM_AR_HP_BUS(0),testName,"-Y MEM AR NOT HP0B-Z");
                  
         checkLSMSDrivers(PY_Y_LSMS_DRVR_BUS,truthTableResults,testName,"Y LSMS Driver for " &
            Integer'image(hpos) & ", rdwr: " & Integer'image(rdwr));
            
         check1(PY_Y_RD_2, not MY_Y_RD_2, testName, "+Y Y RD 2");         

      end loop;
   end loop;

   assert false report "Simulation Ended NORMALLY" severity failure;

   wait;
   end process;

-- The following is needed for older VHDL simulations to
-- terminate the simulation process.  If your environment
-- does not need it, it may be deleted.

stop_simulation: process
   begin
   wait for 2 ms;  -- Determines how long your simulation runs
   assert false report "Simulation Ended NORMALLY (TIMEOUT)" severity failure;
   end process;

-- END USER TEST BENCH PROCESS
   

END;
