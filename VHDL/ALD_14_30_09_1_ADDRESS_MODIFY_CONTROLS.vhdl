-- VHDL for IBM SMS ALD page 14.30.09.1
-- Title: ADDRESS MODIFY CONTROLS
-- IBM Machine Name 1411
-- Generated by GenerateHDL at 8/29/2020 1:50:54 PM

-- Included from HDLTemplate.vhdl

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use WORK.ALL;

-- End of include from HDLTemplate.vhdl

entity ALD_14_30_09_1_ADDRESS_MODIFY_CONTROLS is
	    Port (
		FPGA_CLK:		 in STD_LOGIC;
		PS_MINUS_ONE_28_LINE:	 in STD_LOGIC;
		PS_2ND_CLOCK_PULSE_3_JRJ:	 in STD_LOGIC;
		PS_SET_MODIFY_CTRL_LATCHES:	 in STD_LOGIC;
		PS_LOGIC_GATE_A_1:	 in STD_LOGIC;
		PS_PLUS_ONE_18_LINE:	 in STD_LOGIC;
		PS_ADDR_MOD_SET_TO_ZERO:	 in STD_LOGIC;
		PS_RESET_ADDR_MOD_CTRL_LATCH:	 in STD_LOGIC;
		PS_1ST_CLOCK_PULSE_1:	 in STD_LOGIC;
		MS_RESET_ADDR_MOD_CTRL_LATCH:	 out STD_LOGIC;
		PY_RESET_ADDR_MOD_LATCHES:	 out STD_LOGIC;
		MY_1ST_CLOCK_PULSE:	 out STD_LOGIC;
		MY_MODIFY_BY_ZERO:	 out STD_LOGIC;
		PY_MODIFY_BY_ZERO:	 out STD_LOGIC;
		PS_ZERO_LATCH_ON:	 out STD_LOGIC);
end ALD_14_30_09_1_ADDRESS_MODIFY_CONTROLS;

architecture behavioral of ALD_14_30_09_1_ADDRESS_MODIFY_CONTROLS is 

	signal OUT_5A_C: STD_LOGIC;
	signal OUT_4A_C: STD_LOGIC;
	signal OUT_3A_D: STD_LOGIC;
	signal OUT_3A_D_Latch: STD_LOGIC;
	signal OUT_2A_E: STD_LOGIC;
	signal OUT_2A_E_Latch: STD_LOGIC;
	signal OUT_5B_C: STD_LOGIC;
	signal OUT_4B_R: STD_LOGIC;
	signal OUT_3B_C: STD_LOGIC;
	signal OUT_5C_R: STD_LOGIC;
	signal OUT_3C_E: STD_LOGIC;
	signal OUT_5E_F: STD_LOGIC;
	signal OUT_2E_R: STD_LOGIC;
	signal OUT_5F_D: STD_LOGIC;
	signal OUT_2F_B: STD_LOGIC;
	signal OUT_5G_C: STD_LOGIC;
	signal OUT_4G_C: STD_LOGIC;
	signal OUT_4G_C_Latch: STD_LOGIC;
	signal OUT_3G_L: STD_LOGIC;
	signal OUT_3G_L_Latch: STD_LOGIC;
	signal OUT_2G_L: STD_LOGIC;
	signal OUT_5H_P: STD_LOGIC;
	signal OUT_1H_P: STD_LOGIC;
	signal OUT_DOT_3B: STD_LOGIC;
	signal OUT_DOT_4E: STD_LOGIC;

begin

	OUT_5A_C <= NOT(PS_MINUS_ONE_28_LINE );
	OUT_4A_C <= NOT(OUT_5B_C AND PS_2ND_CLOCK_PULSE_3_JRJ );
	OUT_3A_D_Latch <= NOT(OUT_4A_C AND OUT_2A_E AND OUT_DOT_4E );
	OUT_2A_E_Latch <= NOT(OUT_3A_D AND OUT_DOT_3B AND OUT_3C_E );
	OUT_5B_C <= NOT(OUT_5A_C AND OUT_5C_R );
	OUT_4B_R <= NOT(OUT_5A_C AND OUT_5C_R );
	OUT_3B_C <= NOT(PS_2ND_CLOCK_PULSE_3_JRJ AND PS_SET_MODIFY_CTRL_LATCHES );
	OUT_5C_R <= NOT(PS_PLUS_ONE_18_LINE );
	OUT_3C_E <= NOT(PS_2ND_CLOCK_PULSE_3_JRJ AND PS_LOGIC_GATE_A_1 AND PS_ADDR_MOD_SET_TO_ZERO );
	-- Test possible fix...
	-- OUT_3C_E <= NOT(PS_2ND_CLOCK_PULSE_3_JRJ AND PS_LOGIC_GATE_A_1 AND PS_ADDR_MOD_SET_TO_ZERO AND
	--   OUT_5E_F); -- DID NOT WORK
	-- End of testing code
	OUT_5E_F <= NOT PS_RESET_ADDR_MOD_CTRL_LATCH;
	OUT_2E_R <= NOT OUT_DOT_4E;
	OUT_5F_D <= NOT PS_1ST_CLOCK_PULSE_1;
	OUT_2F_B <= NOT PS_1ST_CLOCK_PULSE_1;
	OUT_5G_C <= NOT(OUT_2A_E OR OUT_2F_B );
	OUT_4G_C_Latch <= NOT(OUT_2E_R OR OUT_5G_C OR OUT_3G_L );
	OUT_3G_L_Latch <= NOT(OUT_4G_C OR OUT_5H_P );
	OUT_2G_L <= OUT_3G_L;
	OUT_5H_P <= NOT(OUT_3A_D OR OUT_2F_B );
	OUT_1H_P <= NOT(OUT_2G_L );
	OUT_DOT_3B <= OUT_4B_R OR OUT_3B_C;
	-- OUT_DOT_4E <= OUT_5E_F OR OUT_5F_D;
	-- Test another possible fix
   OUT_DOT_4E <= OUT_5E_F OR OUT_5F_D OR PS_ADDR_MOD_SET_TO_ZERO;

	PY_RESET_ADDR_MOD_LATCHES <= OUT_2E_R;
	MY_1ST_CLOCK_PULSE <= OUT_2F_B;
	PY_MODIFY_BY_ZERO <= OUT_4G_C;
	MY_MODIFY_BY_ZERO <= OUT_2G_L;
	PS_ZERO_LATCH_ON <= OUT_1H_P;
	MS_RESET_ADDR_MOD_CTRL_LATCH <= OUT_DOT_4E;

	Latch_3A: entity DFlipFlop port map (
		C => FPGA_CLK,
		D => OUT_3A_D_Latch,
		Q => OUT_3A_D,
		QBar => OPEN );

	Latch_2A: entity DFlipFlop port map (
		C => FPGA_CLK,
		D => OUT_2A_E_Latch,
		Q => OUT_2A_E,
		QBar => OPEN );

	Latch_4G: entity DFlipFlop port map (
		C => FPGA_CLK,
		D => OUT_4G_C_Latch,
		Q => OUT_4G_C,
		QBar => OPEN );

	Latch_3G: entity DFlipFlop port map (
		C => FPGA_CLK,
		D => OUT_3G_L_Latch,
		Q => OUT_3G_L,
		QBar => OPEN );


end;
